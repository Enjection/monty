[![Documentation](https://img.shields.io/badge/jeelabs.org-docs-blue)](https://monty.jeelabs.org/)
[![Discussions](https://img.shields.io/badge/github-discuss-orange)](https://github.com/jeelabs/monty/discussions)
[![GitHub issues](https://img.shields.io/github/issues/jeelabs/monty)](https://github.com/jeelabs/monty/milestones)
[![Build Status](https://www.travis-ci.com/jeelabs/monty.svg)](https://www.travis-ci.com/jeelabs/monty)

**Monty** is a Virtual Machine which runs bytecode produced by [MicroPython][MPY].  
It's grossly incomplete and totally unfit for general use, but ... it _does_ work.  
There is no compiler, this VM uses `.mpy` files generated by `mpy-cross`.

This project is written from the ground up in C++, but it would not exist without  
the huge amount of thought and work put into the development of MicroPython,  
which proves that a modern dynamic language can run well on embedded µCs.

The reasons for creating this project are: to explore some stackless design ideas  
and to fit more features (multi-tasking, garbage-collection, dataflow) in tiny µCs.  
Monty can be used in as little as 64 kB flash and 8 kB RAM, but the default dev  
target is a low-power ARM Cortex-M4 [Nucleo-L432KC][L432] (256+64 kB @ 80 MHz).

**Features**  
» The µC runs bytecode from `mpy-cross` (no compiler or `eval`/`exec`)  
» Modules are imported as bytecode from a flash-based filesystem  
» Rich data structures, usable from C++ as well as Python  
» Mark-and-sweep garbage collection with compacting vectors  
» Small code base, well under 10,000 lines of C++ for the core + VM  
» Most non-hardware features can also be used on MacOS and Linux  
» C++ and Python test suites are used to drive (and verify) progress  
» Goals: support messaging, dataflow, and scripting on low-power µCs  
» Non-goals: full Python conformance, replicating MicroPython  
» This is experimental code: some things work, many don't, asserts will fail  

**Requirements**  
» [MP cross compiler][MPX] for bytecode generation  
» [PlatformIO][PIO] for native and embedded builds  
» [PyInvoke][INV] for general development workflow  
» Good familiarity with C++11 and Python 3  
» Lots of patience and a long-term perspective :-)

This is a test run on native + embedded, as of mid-Feb 2021:

```text
$ cat pytests/hello.py
print('hello', sys.implementation, sys.version)
$ inv native -f pytests/hello.mpy
main
hello monty f3745d5
done
$ time inv python flash runner
34 tests, 34 matches, 0 failures, 2 skipped
Processing nucleo-l432 (board: nucleo_l432kc; platform: ststm32; framework: cmsis)
STM32 STLink: /dev/cu.usbmodem143202 ser# 066BFF555052836687031442
33 tests, 33 matches, 0 failures, 3 skipped
       11.84 real         1.92 user         0.89 sys
$ inv x-sizes
   text	   data	    bss	    dec	    hex	filename
  50780	   2400	  12712	  65892	  10164	.pio/build/nucleo-l432/firmware.elf
  39136	   2400	  12712	  54248	   d3e8	.pio/build/noassert/firmware.elf
  29976	   2280	  12712	  44968	   afa8	.pio/build/nopyvm/firmware.elf
$
```

The source code & docs are in the public domain and under active development.  
Monty started in June 2020 as a friendly chat between Jean-Claude Wippler and  
Thorsten von Eicken. And then it evolved into an adventure full of discoveries ...

[MPY]: https://micropython.org/
[L432]: https://www.st.com/en/evaluation-tools/nucleo-l432kc.html
[PIO]: https://docs.platformio.org/en/latest/
[MPX]: https://github.com/micropython/micropython/tree/master/mpy-cross
[INV]: https://www.pyinvoke.org/
