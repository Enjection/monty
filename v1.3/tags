!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A	tests/py/bound.py	/^class A:$/;"	c
A	tests/py/derived.py	/^class A:$/;"	c
A	tests/py/dir.py	/^class A:$/;"	c
A	tests/py/except.py	/^class A: pass$/;"	c
A	tests/py/features.py	/^    class A:$/;"	c
A	tests/py/features.py	/^class A:$/;"	c
A	tests/py/repr.py	/^class A: pass$/;"	c
A	tests/py/with.py	/^class A:$/;"	c
ADC	lib/arch-stm32/prelude.h	/^constexpr auto ADC           = 0x50040000;  \/\/ ADC$/;"	v
ADC	lib/mcu/prelude.h	/^constexpr auto ADC           = 0x50040000;  \/\/ ADC$/;"	v
ADC1	lib/arch-stm32/prelude.h	/^    ADC1                  =  18,  \/\/ ADC$/;"	m	struct:IrqVec
ADC1	lib/hall-stm32/hall.h	/^        constexpr Io32  <0x50040000> ADC1;$/;"	m	namespace:hall::dev
ADC1	lib/mcu/prelude.h	/^    ADC1                  =  18,  \/\/ ADC$/;"	m	struct:IrqVec
ADC2	lib/hall-stm32/hall.h	/^        constexpr Io32  <0x50040100> ADC2;$/;"	m	namespace:hall::dev
ADC_Common	lib/hall-stm32/hall.h	/^        constexpr Io32  <0x50040300> ADC_Common;$/;"	m	namespace:hall::dev
ADD_FAIL_AT	lib/doctest/doctest.h	/^#define ADD_FAIL_AT(/;"	d
ADD_FAIL_AT	tests/embed/src/doctestx.h	/^#define ADD_FAIL_AT(/;"	d
ADD_FAIL_CHECK_AT	lib/doctest/doctest.h	/^#define ADD_FAIL_CHECK_AT(/;"	d
ADD_FAIL_CHECK_AT	tests/embed/src/doctestx.h	/^#define ADD_FAIL_CHECK_AT(/;"	d
ADD_MESSAGE_AT	lib/doctest/doctest.h	/^#define ADD_MESSAGE_AT(/;"	d
ADD_MESSAGE_AT	tests/embed/src/doctestx.h	/^#define ADD_MESSAGE_AT(/;"	d
AES	lib/arch-stm32/prelude.h	/^    AES                   =  79,  \/\/ AES$/;"	m	struct:IrqVec
AES	lib/arch-stm32/prelude.h	/^constexpr auto AES           = 0x50060000;  \/\/ AES$/;"	v
AES	lib/hall-stm32/hall.h	/^        constexpr Io32  <0x50060000> AES;$/;"	m	namespace:hall::dev
AES	lib/mcu/prelude.h	/^    AES                   =  79,  \/\/ AES$/;"	m	struct:IrqVec
AES	lib/mcu/prelude.h	/^constexpr auto AES           = 0x50060000;  \/\/ AES$/;"	v
AFRH	lib/mcu/mcu.h	/^                ODR=0x14, BSRR=0x18, AFRL=0x20, AFRH=0x24, BRR=0x28 };$/;"	e	enum:mcu::Pin::__anon27
AFRL	lib/mcu/mcu.h	/^                ODR=0x14, BSRR=0x18, AFRL=0x20, AFRH=0x24, BRR=0x28 };$/;"	e	enum:mcu::Pin::__anon27
AHB1ENR	lib/hall-stm32/stm32l4-uart.cpp	/^    enum { AHB1ENR=0x48, APB1ENR=0x58 };$/;"	e	enum:Uart::__anon2	file:
AHB1ENR	lib/mcu/uart-stm32f4f7.h	/^    constexpr static auto AHB1ENR = 0x30;$/;"	m	struct:Uart
AHB1ENR	lib/mcu/uart-stm32l4.h	/^    constexpr static auto AHB1ENR = 0x48;$/;"	m	struct:Uart
AND_THEN	lib/doctest/doctest.h	/^#define AND_THEN(/;"	d
AND_THEN	tests/embed/src/doctestx.h	/^#define AND_THEN(/;"	d
AND_WHEN	lib/doctest/doctest.h	/^#define AND_WHEN(/;"	d
AND_WHEN	tests/embed/src/doctestx.h	/^#define AND_WHEN(/;"	d
APB1ENR	lib/hall-stm32/stm32l4-uart.cpp	/^    enum { AHB1ENR=0x48, APB1ENR=0x58 };$/;"	e	enum:Uart::__anon2	file:
APB1ENR	lib/mcu/uart-stm32f4f7.h	/^    constexpr static auto APB1ENR = 0x40;$/;"	m	struct:Uart
APB1ENR	lib/mcu/uart-stm32l4.h	/^    constexpr static auto APB1ENR = 0x58;$/;"	m	struct:Uart
ARGS	src/codegen.py	/^def ARGS(block, *arg):$/;"	f
ARM_Family	lib/mcu/mcu.h	/^    enum ARM_Family { STM_F4, STM_F7, STM_L0, STM_L4 };$/;"	g	namespace:mcu
AccessAs	lib/extend/typ-array.cpp	/^struct AccessAs : Accessor {$/;"	s	file:
AccessAsBits	lib/extend/typ-array.cpp	/^struct AccessAsBits : Accessor {                    \/\/ P T N$/;"	s	file:
AccessAsVaryBytes	lib/extend/typ-array.cpp	/^struct AccessAsVaryBytes : Accessor {$/;"	s	file:
AccessAsVaryStr	lib/extend/typ-array.cpp	/^struct AccessAsVaryStr : AccessAsVaryBytes {$/;"	s	file:
Accessor	lib/extend/typ-array.cpp	/^struct Accessor {$/;"	s	file:
AltPins	lib/arch-stm32/altpins.h	/^struct AltPins { uint8_t pin, dev :4, alt :4; };$/;"	s
AltPins	lib/mcu/altpins.h	/^struct AltPins { uint8_t pin, dev :4, alt :4; };$/;"	s
Answer	tests/py/features.py	/^Answer = {}$/;"	v
ArcIter	lib/graphics/twodee.h	/^        ArcIter (unsigned r) : r (r), x (-r), y (0), err (2-2*r) {}$/;"	f	struct:twodee::ArcIter
ArcIter	lib/graphics/twodee.h	/^    struct ArcIter {$/;"	s	namespace:twodee
ArgVec	lib/monty/monty.h	/^        ArgVec (Vector const& vec ={})$/;"	f	struct:monty::ArgVec
ArgVec	lib/monty/monty.h	/^        ArgVec (Vector const& vec, int num, Value const* ptr)$/;"	f	struct:monty::ArgVec
ArgVec	lib/monty/monty.h	/^        constexpr ArgVec (Vector const& vec, int num, int off =0)$/;"	f	struct:monty::ArgVec
ArgVec	lib/monty/monty.h	/^    struct ArgVec {$/;"	s	namespace:monty
ArithmeticError	lib/monty/monty.h	/^        ArithmeticError,     \/\/ Exception$/;"	m	class:monty::E
Array	lib/extend/typ-array.cpp	/^Array::Array (char type, uint32_t len) {$/;"	f	class:Array
Array	lib/extend/typ-array.h	/^    struct Array : Bytes {$/;"	s	namespace:monty
AssertData	lib/doctest/doctest.h	/^struct DOCTEST_INTERFACE AssertData$/;"	s	namespace:doctest
AssertData	tests/embed/src/doctestx.h	/^struct DOCTEST_INTERFACE AssertData$/;"	s	namespace:doctest
AssertionError	lib/monty/monty.h	/^        AssertionError,      \/\/ Exception$/;"	m	class:monty::E
AttributeError	lib/monty/monty.h	/^        AttributeError,      \/\/ Exception$/;"	m	class:monty::E
AttributesImpl	src/xmltodict.py	/^from xml.sax.xmlreader import AttributesImpl$/;"	i
B	tests/py/derived.py	/^class B(A):$/;"	c
B	tests/py/repr.py	/^class B(A):$/;"	c
BDCR	lib/hall-stm32/stm32l4.cpp	/^        enum { BDCR=0x70 };$/;"	e	enum:hall::rtc::__anon6	file:
BIND	src/codegen.py	/^def BIND(block, fun, *arg):$/;"	f
BINOPS	src/codegen.py	/^def BINOPS(block, fname, count):$/;"	f
BKPR	lib/hall-stm32/stm32l4.cpp	/^        enum { TR=0x00,DR=0x04,CR=0x08,ISR=0x0C,WPR=0x24,BKPR=0x50 };$/;"	e	enum:hall::rtc::__anon5	file:
BOARD	src/codegen.py	/^def BOARD(block, board, device, env):$/;"	f
BRR	lib/arch-stm32/uart-f1.h	/^    enum { SR=0x00,DR=0x04,BRR=0x08,CR1=0x0C,CR3=0x14 };$/;"	e	enum:Uart::__anon12
BRR	lib/arch-stm32/uart-f4.h	/^    enum { SR=0x00,DR=0x04,BRR=0x08,CR1=0x0C,CR3=0x14 };$/;"	e	enum:Uart::__anon20
BRR	lib/arch-stm32/uart-l0.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon16
BRR	lib/arch-stm32/uart-l4.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon18
BRR	lib/hall-stm32/stm32l4-uart.cpp	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon3	file:
BRR	lib/mcu/mcu.h	/^                ODR=0x14, BSRR=0x18, AFRL=0x20, AFRH=0x24, BRR=0x28 };$/;"	e	enum:mcu::Pin::__anon27
BRR	lib/mcu/mcu.h	/^        enum { CRL=0x00, CRH=0x04, IDR=0x08, ODR=0x0C, BSRR=0x10, BRR=0x14 };$/;"	e	enum:mcu::Pin::__anon26
BRR	lib/mcu/uart-stm32f4f7.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon31
BRR	lib/mcu/uart-stm32f4f7.h	/^    enum { SR=0x00,RDR=0x04,TDR=0x04,BRR=0x08,CR1=0x0C,CR3=0x14 };$/;"	e	enum:Uart::__anon30
BRR	lib/mcu/uart-stm32l4.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon28
BSRR	lib/hall-stm32/hall.h	/^        enum { IDR=0x08+OFF, ODR=0x0C+OFF, BSRR=0x10+OFF };$/;"	e	enum:hall::Pin::__anon1
BSRR	lib/mcu/mcu.h	/^                ODR=0x14, BSRR=0x18, AFRL=0x20, AFRH=0x24, BRR=0x28 };$/;"	e	enum:mcu::Pin::__anon27
BSRR	lib/mcu/mcu.h	/^        enum { CRL=0x00, CRH=0x04, IDR=0x08, ODR=0x0C, BSRR=0x10, BRR=0x14 };$/;"	e	enum:mcu::Pin::__anon26
BUILTINS	src/codegen.py	/^def BUILTINS(block):$/;"	f
Base	lib/monty/monty.h	/^        struct Base {$/;"	s	struct:monty::Method
BaseException	lib/monty/monty.h	/^        BaseException,       \/\/ -$/;"	m	class:monty::E
BinaryOpMulti	lib/pyvm/pyvm.cpp	/^    BinaryOpMulti          = 0xD7,$/;"	e	enum:uint8_t	file:
BlockIRQ	lib/hall-stm32/hall.h	/^        BlockIRQ () { asm ("cpsid i"); }$/;"	f	struct:hall::BlockIRQ
BlockIRQ	lib/hall-stm32/hall.h	/^    struct BlockIRQ {$/;"	s	namespace:hall
BlockIRQ	lib/mcu/mcu.h	/^        BlockIRQ () { asm ("cpsid i"); }$/;"	f	struct:mcu::BlockIRQ
BlockIRQ	lib/mcu/mcu.h	/^    struct BlockIRQ {$/;"	s	namespace:mcu
Blue	lib/doctest/doctest.h	/^        Blue,$/;"	e	enum:doctest::Color::Enum
Blue	tests/embed/src/doctestx.h	/^        Blue,$/;"	e	enum:doctest::Color::Enum
Bool	lib/monty/monty.h	/^    struct Bool : StaticObj {$/;"	s	namespace:monty
BoundMeth	lib/pyvm/pyvm.cpp	/^    BoundMeth (Object const& f, Value o) : _meth (f), _self (o) {}$/;"	f	struct:BoundMeth
BoundMeth	lib/pyvm/pyvm.cpp	/^struct BoundMeth : Object {$/;"	s	file:
Bright	lib/doctest/doctest.h	/^        Bright = 0x10,$/;"	e	enum:doctest::Color::Enum
Bright	tests/embed/src/doctestx.h	/^        Bright = 0x10,$/;"	e	enum:doctest::Color::Enum
BrightGreen	lib/doctest/doctest.h	/^        BrightGreen = Bright | Green,$/;"	e	enum:doctest::Color::Enum
BrightGreen	tests/embed/src/doctestx.h	/^        BrightGreen = Bright | Green,$/;"	e	enum:doctest::Color::Enum
BrightRed	lib/doctest/doctest.h	/^        BrightRed   = Bright | Red,$/;"	e	enum:doctest::Color::Enum
BrightRed	tests/embed/src/doctestx.h	/^        BrightRed   = Bright | Red,$/;"	e	enum:doctest::Color::Enum
BrightWhite	lib/doctest/doctest.h	/^        BrightWhite = Bright | White$/;"	e	enum:doctest::Color::Enum
BrightWhite	tests/embed/src/doctestx.h	/^        BrightWhite = Bright | White$/;"	e	enum:doctest::Color::Enum
Buf	lib/boss/boss.h	/^        static auto at (Id_t) -> Buf&;$/;"	m	struct:boss::pool::Buf
Buf	lib/boss/boss.h	/^    struct Buf {$/;"	s	namespace:boss::pool
Buf	tests/buffers/main.cpp	/^        auto next () -> Buf&;$/;"	m	struct:buf::Buf	file:
Buf	tests/buffers/main.cpp	/^        auto operator= (Buf const&) -> Buf& =delete;$/;"	m	struct:buf::Buf	file:
Buf	tests/buffers/main.cpp	/^        auto operator= (Buf&&) -> Buf& =default;$/;"	m	struct:buf::Buf	file:
Buf	tests/buffers/main.cpp	/^        auto operator= (Buf&) -> Buf&;$/;"	m	struct:buf::Buf	file:
Buf	tests/buffers/main.cpp	/^        auto pull () -> Buf;$/;"	m	struct:buf::Queue	file:
Buf	tests/buffers/main.cpp	/^    Buf::Buf (Buf& b) : id (b.id) { b.id = 0; }$/;"	f	class:buf::Buf
Buf	tests/buffers/main.cpp	/^    Buf::Buf (void* p) : id (((uint8_t*) p - bufs) \/ nBufs) {}$/;"	f	class:buf::Buf
Buf	tests/buffers/main.cpp	/^    struct Buf {$/;"	s	namespace:buf	file:
Buffer	lib/monty/monty.h	/^        auto operator<< (Value v) -> Buffer&;$/;"	m	struct:monty::Buffer
Buffer	lib/monty/monty.h	/^    struct Buffer : Bytes {$/;"	s	namespace:monty
BuildList	lib/pyvm/pyvm.cpp	/^    BuildList              = 0x2B,$/;"	e	enum:uint8_t	file:
BuildMap	lib/pyvm/pyvm.cpp	/^    BuildMap               = 0x2C,$/;"	e	enum:uint8_t	file:
BuildSet	lib/pyvm/pyvm.cpp	/^    BuildSet               = 0x2D,$/;"	e	enum:uint8_t	file:
BuildSlice	lib/pyvm/pyvm.cpp	/^    BuildSlice             = 0x2E,$/;"	e	enum:uint8_t	file:
BuildTuple	lib/pyvm/pyvm.cpp	/^    BuildTuple             = 0x2A,$/;"	e	enum:uint8_t	file:
BusFault_Handler	lib/arch-stm32/arch.cpp	/^extern "C" void BusFault_Handler   () { panic("bus fault"); };$/;"	f
Bytecode	lib/pyvm/loader.h	/^struct Bytecode : List, CodePrefix {$/;"	s
Bytes	lib/monty/monty.h	/^    struct Bytes : Object, ByteVec {$/;"	s	namespace:monty
Bytes	lib/monty/type.cpp	/^Bytes::Bytes (void const* ptr, uint32_t len) {$/;"	f	class:Bytes
C	tests/py/derived.py	/^class C(B):$/;"	c
CAN1	lib/arch-stm32/prelude.h	/^constexpr auto CAN1          = 0x40006400;  \/\/ CAN$/;"	v
CAN1	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40006400> CAN1;$/;"	m	namespace:hall::dev
CAN1	lib/mcu/prelude.h	/^constexpr auto CAN1          = 0x40006400;  \/\/ CAN$/;"	v
CAN1_RX0	lib/arch-stm32/prelude.h	/^    CAN1_RX0              =  20,  \/\/ CAN$/;"	m	struct:IrqVec
CAN1_RX0	lib/mcu/prelude.h	/^    CAN1_RX0              =  20,  \/\/ CAN$/;"	m	struct:IrqVec
CAN1_RX1	lib/arch-stm32/prelude.h	/^    CAN1_RX1              =  21,  \/\/ CAN$/;"	m	struct:IrqVec
CAN1_RX1	lib/mcu/prelude.h	/^    CAN1_RX1              =  21,  \/\/ CAN$/;"	m	struct:IrqVec
CAN1_SCE	lib/arch-stm32/prelude.h	/^    CAN1_SCE              =  22,  \/\/ CAN$/;"	m	struct:IrqVec
CAN1_SCE	lib/mcu/prelude.h	/^    CAN1_SCE              =  22,  \/\/ CAN$/;"	m	struct:IrqVec
CAN1_TX	lib/arch-stm32/prelude.h	/^    CAN1_TX               =  19,  \/\/ CAN$/;"	m	struct:IrqVec
CAN1_TX	lib/mcu/prelude.h	/^    CAN1_TX               =  19,  \/\/ CAN$/;"	m	struct:IrqVec
CAPTURE	lib/doctest/doctest.h	/^#define CAPTURE(/;"	d
CAPTURE	tests/embed/src/doctestx.h	/^#define CAPTURE(/;"	d
CCR	lib/arch-stm32/uart-f1.h	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14 };$/;"	e	enum:Uart::__anon13
CCR	lib/arch-stm32/uart-l0.h	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon17
CCR	lib/arch-stm32/uart-l4.h	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon19
CCR	lib/hall-stm32/stm32l4-uart.cpp	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon4	file:
CCR	lib/mcu/uart-stm32l4.h	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon29
CHECK	lib/doctest/doctest.h	/^#define CHECK(/;"	d
CHECK	tests/embed/src/doctestx.h	/^#define CHECK(/;"	d
CHECK_EQ	lib/doctest/doctest.h	/^#define CHECK_EQ(/;"	d
CHECK_EQ	tests/embed/src/doctestx.h	/^#define CHECK_EQ(/;"	d
CHECK_FALSE	lib/doctest/doctest.h	/^#define CHECK_FALSE(/;"	d
CHECK_FALSE	tests/embed/src/doctestx.h	/^#define CHECK_FALSE(/;"	d
CHECK_FALSE_MESSAGE	lib/doctest/doctest.h	/^#define CHECK_FALSE_MESSAGE(/;"	d
CHECK_FALSE_MESSAGE	tests/embed/src/doctestx.h	/^#define CHECK_FALSE_MESSAGE(/;"	d
CHECK_GE	lib/doctest/doctest.h	/^#define CHECK_GE(/;"	d
CHECK_GE	tests/embed/src/doctestx.h	/^#define CHECK_GE(/;"	d
CHECK_GT	lib/doctest/doctest.h	/^#define CHECK_GT(/;"	d
CHECK_GT	tests/embed/src/doctestx.h	/^#define CHECK_GT(/;"	d
CHECK_LE	lib/doctest/doctest.h	/^#define CHECK_LE(/;"	d
CHECK_LE	tests/embed/src/doctestx.h	/^#define CHECK_LE(/;"	d
CHECK_LT	lib/doctest/doctest.h	/^#define CHECK_LT(/;"	d
CHECK_LT	tests/embed/src/doctestx.h	/^#define CHECK_LT(/;"	d
CHECK_MESSAGE	lib/doctest/doctest.h	/^#define CHECK_MESSAGE(/;"	d
CHECK_MESSAGE	tests/embed/src/doctestx.h	/^#define CHECK_MESSAGE(/;"	d
CHECK_NE	lib/doctest/doctest.h	/^#define CHECK_NE(/;"	d
CHECK_NE	tests/embed/src/doctestx.h	/^#define CHECK_NE(/;"	d
CHECK_NOTHROW	lib/doctest/doctest.h	/^#define CHECK_NOTHROW(/;"	d
CHECK_NOTHROW	tests/embed/src/doctestx.h	/^#define CHECK_NOTHROW(/;"	d
CHECK_NOTHROW_MESSAGE	lib/doctest/doctest.h	/^#define CHECK_NOTHROW_MESSAGE(/;"	d
CHECK_NOTHROW_MESSAGE	tests/embed/src/doctestx.h	/^#define CHECK_NOTHROW_MESSAGE(/;"	d
CHECK_THROWS	lib/doctest/doctest.h	/^#define CHECK_THROWS(/;"	d
CHECK_THROWS	tests/embed/src/doctestx.h	/^#define CHECK_THROWS(/;"	d
CHECK_THROWS_AS	lib/doctest/doctest.h	/^#define CHECK_THROWS_AS(/;"	d
CHECK_THROWS_AS	tests/embed/src/doctestx.h	/^#define CHECK_THROWS_AS(/;"	d
CHECK_THROWS_AS_MESSAGE	lib/doctest/doctest.h	/^#define CHECK_THROWS_AS_MESSAGE(/;"	d
CHECK_THROWS_AS_MESSAGE	tests/embed/src/doctestx.h	/^#define CHECK_THROWS_AS_MESSAGE(/;"	d
CHECK_THROWS_MESSAGE	lib/doctest/doctest.h	/^#define CHECK_THROWS_MESSAGE(/;"	d
CHECK_THROWS_MESSAGE	tests/embed/src/doctestx.h	/^#define CHECK_THROWS_MESSAGE(/;"	d
CHECK_THROWS_WITH	lib/doctest/doctest.h	/^#define CHECK_THROWS_WITH(/;"	d
CHECK_THROWS_WITH	tests/embed/src/doctestx.h	/^#define CHECK_THROWS_WITH(/;"	d
CHECK_THROWS_WITH_AS	lib/doctest/doctest.h	/^#define CHECK_THROWS_WITH_AS(/;"	d
CHECK_THROWS_WITH_AS	tests/embed/src/doctestx.h	/^#define CHECK_THROWS_WITH_AS(/;"	d
CHECK_THROWS_WITH_AS_MESSAGE	lib/doctest/doctest.h	/^#define CHECK_THROWS_WITH_AS_MESSAGE(/;"	d
CHECK_THROWS_WITH_AS_MESSAGE	tests/embed/src/doctestx.h	/^#define CHECK_THROWS_WITH_AS_MESSAGE(/;"	d
CHECK_THROWS_WITH_MESSAGE	lib/doctest/doctest.h	/^#define CHECK_THROWS_WITH_MESSAGE(/;"	d
CHECK_THROWS_WITH_MESSAGE	tests/embed/src/doctestx.h	/^#define CHECK_THROWS_WITH_MESSAGE(/;"	d
CHECK_UNARY	lib/doctest/doctest.h	/^#define CHECK_UNARY(/;"	d
CHECK_UNARY	tests/embed/src/doctestx.h	/^#define CHECK_UNARY(/;"	d
CHECK_UNARY_FALSE	lib/doctest/doctest.h	/^#define CHECK_UNARY_FALSE(/;"	d
CHECK_UNARY_FALSE	tests/embed/src/doctestx.h	/^#define CHECK_UNARY_FALSE(/;"	d
CLR0	tests/gpio/gpio.cpp	/^        enum { LEV0=0x34, SET0=0x1C, CLR0=0x28 };$/;"	e	enum:gpio::Pin::__anon37	file:
CMAR	lib/arch-stm32/uart-f1.h	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14 };$/;"	e	enum:Uart::__anon13
CMAR	lib/arch-stm32/uart-l0.h	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon17
CMAR	lib/arch-stm32/uart-l4.h	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon19
CMAR	lib/hall-stm32/stm32l4-uart.cpp	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon4	file:
CMAR	lib/mcu/uart-stm32l4.h	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon29
CNDTR	lib/arch-stm32/uart-f1.h	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14 };$/;"	e	enum:Uart::__anon13
CNDTR	lib/arch-stm32/uart-l0.h	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon17
CNDTR	lib/arch-stm32/uart-l4.h	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon19
CNDTR	lib/hall-stm32/stm32l4-uart.cpp	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon4	file:
CNDTR	lib/mcu/uart-stm32l4.h	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon29
COMP	lib/arch-stm32/prelude.h	/^    COMP                  =  64,  \/\/ COMP$/;"	m	struct:IrqVec
COMP	lib/arch-stm32/prelude.h	/^constexpr auto COMP          = 0x40010200;  \/\/ COMP$/;"	v
COMP	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40010200> COMP;$/;"	m	namespace:hall::dev
COMP	lib/mcu/prelude.h	/^    COMP                  =  64,  \/\/ COMP$/;"	m	struct:IrqVec
COMP	lib/mcu/prelude.h	/^constexpr auto COMP          = 0x40010200;  \/\/ COMP$/;"	v
CONFIG	src/codegen.py	/^def CONFIG(block, name, *args, **kw):$/;"	f
CPAR	lib/arch-stm32/uart-f1.h	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14 };$/;"	e	enum:Uart::__anon13
CPAR	lib/arch-stm32/uart-l0.h	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon17
CPAR	lib/arch-stm32/uart-l4.h	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon19
CPAR	lib/hall-stm32/stm32l4-uart.cpp	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon4	file:
CPAR	lib/mcu/uart-stm32l4.h	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon29
CR	lib/arch-stm32/uart-l0.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon16
CR	lib/arch-stm32/uart-l4.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon18
CR	lib/hall-stm32/stm32l4-uart.cpp	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon3	file:
CR	lib/hall-stm32/stm32l4.cpp	/^        enum { TR=0x00,DR=0x04,CR=0x08,ISR=0x0C,WPR=0x24,BKPR=0x50 };$/;"	e	enum:hall::rtc::__anon5	file:
CR	lib/mcu/uart-stm32f4f7.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon31
CR	lib/mcu/uart-stm32l4.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon28
CR1	lib/arch-stm32/uart-f1.h	/^    enum { SR=0x00,DR=0x04,BRR=0x08,CR1=0x0C,CR3=0x14 };$/;"	e	enum:Uart::__anon12
CR1	lib/arch-stm32/uart-f4.h	/^    enum { SR=0x00,DR=0x04,BRR=0x08,CR1=0x0C,CR3=0x14 };$/;"	e	enum:Uart::__anon20
CR1	lib/arch-stm32/uart-l0.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon16
CR1	lib/arch-stm32/uart-l4.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon18
CR1	lib/hall-stm32/stm32l4-uart.cpp	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon3	file:
CR1	lib/mcu/uart-stm32f4f7.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon31
CR1	lib/mcu/uart-stm32f4f7.h	/^    enum { SR=0x00,RDR=0x04,TDR=0x04,BRR=0x08,CR1=0x0C,CR3=0x14 };$/;"	e	enum:Uart::__anon30
CR1	lib/mcu/uart-stm32l4.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon28
CR3	lib/arch-stm32/uart-f1.h	/^    enum { SR=0x00,DR=0x04,BRR=0x08,CR1=0x0C,CR3=0x14 };$/;"	e	enum:Uart::__anon12
CR3	lib/arch-stm32/uart-f4.h	/^    enum { SR=0x00,DR=0x04,BRR=0x08,CR1=0x0C,CR3=0x14 };$/;"	e	enum:Uart::__anon20
CR3	lib/arch-stm32/uart-l0.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon16
CR3	lib/arch-stm32/uart-l4.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon18
CR3	lib/hall-stm32/stm32l4-uart.cpp	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon3	file:
CR3	lib/mcu/uart-stm32f4f7.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon31
CR3	lib/mcu/uart-stm32f4f7.h	/^    enum { SR=0x00,RDR=0x04,TDR=0x04,BRR=0x08,CR1=0x0C,CR3=0x14 };$/;"	e	enum:Uart::__anon30
CR3	lib/mcu/uart-stm32l4.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon28
CRC	lib/arch-stm32/prelude.h	/^constexpr auto CRC           = 0x40023000;  \/\/ CRC$/;"	v
CRC	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40023000> CRC;$/;"	m	namespace:hall::dev
CRC	lib/mcu/prelude.h	/^constexpr auto CRC           = 0x40023000;  \/\/ CRC$/;"	v
CRH	lib/mcu/mcu.h	/^        enum { CRL=0x00, CRH=0x04, IDR=0x08, ODR=0x0C, BSRR=0x10, BRR=0x14 };$/;"	e	enum:mcu::Pin::__anon26
CRL	lib/mcu/mcu.h	/^        enum { CRL=0x00, CRH=0x04, IDR=0x08, ODR=0x0C, BSRR=0x10, BRR=0x14 };$/;"	e	enum:mcu::Pin::__anon26
CRS	lib/arch-stm32/prelude.h	/^    CRS                   =  82,  \/\/ CRS$/;"	m	struct:IrqVec
CRS	lib/arch-stm32/prelude.h	/^constexpr auto CRS           = 0x40006000;  \/\/ CRS$/;"	v
CRS	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40006000> CRS;$/;"	m	namespace:hall::dev
CRS	lib/mcu/prelude.h	/^    CRS                   =  82,  \/\/ CRS$/;"	m	struct:IrqVec
CRS	lib/mcu/prelude.h	/^constexpr auto CRS           = 0x40006000;  \/\/ CRS$/;"	v
CSELR	lib/arch-stm32/uart-l0.h	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon17
CSELR	lib/arch-stm32/uart-l4.h	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon19
CSELR	lib/hall-stm32/stm32l4-uart.cpp	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon4	file:
CSELR	lib/mcu/uart-stm32l4.h	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon29
CXXFLAGS	tests/buffers/Makefile	/^CXXFLAGS = -std=c++17 -Wall -Wextra$/;"	m
CXXFLAGS	tests/gpio/Makefile	/^CXXFLAGS = -std=c++17 -Wall -Wextra$/;"	m
CXXFLAGS	tests/native/Makefile	/^CXXFLAGS = -std=c++17 -Wall -Wextra$/;"	m
CXXFLAGS	tests/tdd/Makefile	/^CXXFLAGS = -std=c++17 -Wall -Wextra$/;"	m
CallFunction	lib/pyvm/pyvm.cpp	/^    CallFunction           = 0x34,$/;"	e	enum:uint8_t	file:
CallFunctionVarKw	lib/pyvm/pyvm.cpp	/^    CallFunctionVarKw      = 0x35,$/;"	e	enum:uint8_t	file:
CallMethod	lib/pyvm/pyvm.cpp	/^    CallMethod             = 0x36,$/;"	e	enum:uint8_t	file:
CallMethodVarKw	lib/pyvm/pyvm.cpp	/^    CallMethodVarKw        = 0x37,$/;"	e	enum:uint8_t	file:
Callable	lib/pyvm/loader.h	/^    static auto load (void const*, Value) -> Callable*;$/;"	m	struct:Bytecode
Callable	lib/pyvm/pyvm.cpp	/^    Callable (Bytecode const& callee, Value pos, Value kw)$/;"	f	struct:Callable
Callable	lib/pyvm/pyvm.cpp	/^Callable::Callable (Bytecode const& callee, Module* mod, Tuple* t, Dict* d)$/;"	f	class:Callable
Callable	lib/pyvm/pyvm.cpp	/^struct Callable : Object {$/;"	s	file:
Cell	lib/pyvm/pyvm.cpp	/^    Cell (Value val) : _val (val) {}$/;"	f	struct:Cell
Cell	lib/pyvm/pyvm.cpp	/^struct Cell : Object {$/;"	s	file:
Chunk	lib/mcu/mcu.h	/^    struct Chunk { uint8_t* buf; uint32_t len; };$/;"	s	namespace:mcu
Class	lib/monty/monty.h	/^    struct Class : Type {$/;"	s	namespace:monty
Class	lib/monty/type.cpp	/^Class::Class (ArgVec const& args) : Type (args[1], nullptr, Inst::create) {$/;"	f	class:Class
Closure	lib/pyvm/pyvm.cpp	/^    Closure (Object const& func, ArgVec const& args) : _func (func) {$/;"	f	struct:Closure
Closure	lib/pyvm/pyvm.cpp	/^struct Closure : List {$/;"	s	file:
Cmd	lib/monty/parser.h	/^    enum State : uint8_t { Ini, Cmd, Hex, Obj, Err,$/;"	m	struct:Parser	typeref:enum:Parser::
CodePrefix	lib/pyvm/loader.h	/^struct CodePrefix {$/;"	s
Color	lib/doctest/doctest.h	/^namespace Color {$/;"	n	namespace:doctest
Color	tests/embed/src/doctestx.h	/^namespace Color {$/;"	n	namespace:doctest
Context	lib/arch-stm32/arch.h	/^    auto cliTask () -> monty::Context*;$/;"	m	class:arch::monty
Context	lib/monty/monty.h	/^    auto vmLaunch (void const* data) -> Context*;$/;"	m	namespace:monty
Context	lib/monty/monty.h	/^    struct Context : Stacklet {$/;"	s	namespace:monty
ContextOptions	lib/doctest/doctest.h	/^struct ContextOptions \/\/!OCLINT too many fields$/;"	s	namespace:doctest
ContextOptions	tests/embed/src/doctestx.h	/^struct ContextOptions \/\/!OCLINT too many fields$/;"	s	namespace:doctest
Cyan	lib/doctest/doctest.h	/^        Cyan,$/;"	e	enum:doctest::Color::Enum
Cyan	tests/embed/src/doctestx.h	/^        Cyan,$/;"	e	enum:doctest::Color::Enum
D	lib/monty/gc.cpp	/^#define D(/;"	d	file:
D	tests/py/derived.py	/^class D: pass$/;"	c
DAC1	lib/arch-stm32/prelude.h	/^constexpr auto DAC1          = 0x40007400;  \/\/ DAC$/;"	v
DAC1	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40007400> DAC1;$/;"	m	namespace:hall::dev
DAC1	lib/mcu/prelude.h	/^constexpr auto DAC1          = 0x40007400;  \/\/ DAC$/;"	v
DBGMCU	lib/arch-stm32/prelude.h	/^constexpr auto DBGMCU        = 0xE0042000;  \/\/ DBGMCU$/;"	v
DBGMCU	lib/hall-stm32/hall.h	/^        constexpr Io32  <0xE0042000> DBGMCU;$/;"	m	namespace:hall::dev
DBGMCU	lib/mcu/prelude.h	/^constexpr auto DBGMCU        = 0xE0042000;  \/\/ DBGMCU$/;"	v
DFSDM	lib/arch-stm32/prelude.h	/^constexpr auto DFSDM         = 0x40016000;  \/\/ DFSDM$/;"	v
DFSDM	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40016000> DFSDM;$/;"	m	namespace:hall::dev
DFSDM	lib/mcu/prelude.h	/^constexpr auto DFSDM         = 0x40016000;  \/\/ DFSDM$/;"	v
DFSDM1	lib/arch-stm32/prelude.h	/^    DFSDM1                =  61,  \/\/ DFSDM$/;"	m	struct:IrqVec
DFSDM1	lib/mcu/prelude.h	/^    DFSDM1                =  61,  \/\/ DFSDM$/;"	m	struct:IrqVec
DFSDM1_FLT2	lib/arch-stm32/prelude.h	/^    DFSDM1_FLT2           =  63,  \/\/ DFSDM$/;"	m	struct:IrqVec
DFSDM1_FLT2	lib/mcu/prelude.h	/^    DFSDM1_FLT2           =  63,  \/\/ DFSDM$/;"	m	struct:IrqVec
DFSDM1_FLT3	lib/arch-stm32/prelude.h	/^    DFSDM1_FLT3           =  42,  \/\/ DFSDM$/;"	m	struct:IrqVec
DFSDM1_FLT3	lib/mcu/prelude.h	/^    DFSDM1_FLT3           =  42,  \/\/ DFSDM$/;"	m	struct:IrqVec
DFSDM2	lib/arch-stm32/prelude.h	/^    DFSDM2                =  62,  \/\/ DFSDM$/;"	m	struct:IrqVec
DFSDM2	lib/mcu/prelude.h	/^    DFSDM2                =  62,  \/\/ DFSDM$/;"	m	struct:IrqVec
DIRS	src/Makefile	/^DIRS = doctest hall-native boss monty extend arch-native pyvm$/;"	m
DIRS	tests/buffers/Makefile	/^DIRS = doctest # hall-native boss$/;"	m
DIRS	tests/gpio/Makefile	/^DIRS = doctest hall-native boss$/;"	m
DIRS	tests/native/Makefile	/^DIRS = doctest hall-native boss monty extend arch-native pyvm$/;"	m
DIRS	tests/tdd/Makefile	/^DIRS = # doctest$/;"	m
DMA1	lib/arch-stm32/prelude.h	/^constexpr auto DMA1          = 0x40020000;  \/\/ DMA$/;"	v
DMA1	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40020000> DMA1;$/;"	m	namespace:hall::dev
DMA1	lib/mcu/prelude.h	/^constexpr auto DMA1          = 0x40020000;  \/\/ DMA$/;"	v
DMA1_CH1	lib/arch-stm32/prelude.h	/^    DMA1_CH1              =  11,  \/\/ DMA$/;"	m	struct:IrqVec
DMA1_CH1	lib/mcu/prelude.h	/^    DMA1_CH1              =  11,  \/\/ DMA$/;"	m	struct:IrqVec
DMA1_CH2	lib/arch-stm32/prelude.h	/^    DMA1_CH2              =  12,  \/\/ DMA$/;"	m	struct:IrqVec
DMA1_CH2	lib/mcu/prelude.h	/^    DMA1_CH2              =  12,  \/\/ DMA$/;"	m	struct:IrqVec
DMA1_CH3	lib/arch-stm32/prelude.h	/^    DMA1_CH3              =  13,  \/\/ DMA$/;"	m	struct:IrqVec
DMA1_CH3	lib/mcu/prelude.h	/^    DMA1_CH3              =  13,  \/\/ DMA$/;"	m	struct:IrqVec
DMA1_CH4	lib/arch-stm32/prelude.h	/^    DMA1_CH4              =  14,  \/\/ DMA$/;"	m	struct:IrqVec
DMA1_CH4	lib/mcu/prelude.h	/^    DMA1_CH4              =  14,  \/\/ DMA$/;"	m	struct:IrqVec
DMA1_CH5	lib/arch-stm32/prelude.h	/^    DMA1_CH5              =  15,  \/\/ DMA$/;"	m	struct:IrqVec
DMA1_CH5	lib/mcu/prelude.h	/^    DMA1_CH5              =  15,  \/\/ DMA$/;"	m	struct:IrqVec
DMA1_CH6	lib/arch-stm32/prelude.h	/^    DMA1_CH6              =  16,  \/\/ DMA$/;"	m	struct:IrqVec
DMA1_CH6	lib/mcu/prelude.h	/^    DMA1_CH6              =  16,  \/\/ DMA$/;"	m	struct:IrqVec
DMA1_CH7	lib/arch-stm32/prelude.h	/^    DMA1_CH7              =  17,  \/\/ DMA$/;"	m	struct:IrqVec
DMA1_CH7	lib/mcu/prelude.h	/^    DMA1_CH7              =  17,  \/\/ DMA$/;"	m	struct:IrqVec
DMA2	lib/arch-stm32/prelude.h	/^constexpr auto DMA2          = 0x40020400;  \/\/ DMA$/;"	v
DMA2	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40020400> DMA2;$/;"	m	namespace:hall::dev
DMA2	lib/mcu/prelude.h	/^constexpr auto DMA2          = 0x40020400;  \/\/ DMA$/;"	v
DMA2_CH1	lib/arch-stm32/prelude.h	/^    DMA2_CH1              =  56,  \/\/ DMA$/;"	m	struct:IrqVec
DMA2_CH1	lib/mcu/prelude.h	/^    DMA2_CH1              =  56,  \/\/ DMA$/;"	m	struct:IrqVec
DMA2_CH2	lib/arch-stm32/prelude.h	/^    DMA2_CH2              =  57,  \/\/ DMA$/;"	m	struct:IrqVec
DMA2_CH2	lib/mcu/prelude.h	/^    DMA2_CH2              =  57,  \/\/ DMA$/;"	m	struct:IrqVec
DMA2_CH3	lib/arch-stm32/prelude.h	/^    DMA2_CH3              =  58,  \/\/ DMA$/;"	m	struct:IrqVec
DMA2_CH3	lib/mcu/prelude.h	/^    DMA2_CH3              =  58,  \/\/ DMA$/;"	m	struct:IrqVec
DMA2_CH4	lib/arch-stm32/prelude.h	/^    DMA2_CH4              =  59,  \/\/ DMA$/;"	m	struct:IrqVec
DMA2_CH4	lib/mcu/prelude.h	/^    DMA2_CH4              =  59,  \/\/ DMA$/;"	m	struct:IrqVec
DMA2_CH5	lib/arch-stm32/prelude.h	/^    DMA2_CH5              =  60,  \/\/ DMA$/;"	m	struct:IrqVec
DMA2_CH5	lib/mcu/prelude.h	/^    DMA2_CH5              =  60,  \/\/ DMA$/;"	m	struct:IrqVec
DMA2_CH6	lib/arch-stm32/prelude.h	/^    DMA2_CH6              =  68,  \/\/ DMA$/;"	m	struct:IrqVec
DMA2_CH6	lib/mcu/prelude.h	/^    DMA2_CH6              =  68,  \/\/ DMA$/;"	m	struct:IrqVec
DMA2_CH7	lib/arch-stm32/prelude.h	/^    DMA2_CH7              =  69,  \/\/ DMA$/;"	m	struct:IrqVec
DMA2_CH7	lib/mcu/prelude.h	/^    DMA2_CH7              =  69,  \/\/ DMA$/;"	m	struct:IrqVec
DOCTEST_ADD_AT_IMPL	lib/doctest/doctest.h	/^#define DOCTEST_ADD_AT_IMPL(/;"	d
DOCTEST_ADD_AT_IMPL	tests/embed/src/doctestx.h	/^#define DOCTEST_ADD_AT_IMPL(/;"	d
DOCTEST_ADD_FAIL_AT	lib/doctest/doctest.h	/^#define DOCTEST_ADD_FAIL_AT(/;"	d
DOCTEST_ADD_FAIL_AT	tests/embed/src/doctestx.h	/^#define DOCTEST_ADD_FAIL_AT(/;"	d
DOCTEST_ADD_FAIL_CHECK_AT	lib/doctest/doctest.h	/^#define DOCTEST_ADD_FAIL_CHECK_AT(/;"	d
DOCTEST_ADD_FAIL_CHECK_AT	tests/embed/src/doctestx.h	/^#define DOCTEST_ADD_FAIL_CHECK_AT(/;"	d
DOCTEST_ADD_MESSAGE_AT	lib/doctest/doctest.h	/^#define DOCTEST_ADD_MESSAGE_AT(/;"	d
DOCTEST_ADD_MESSAGE_AT	tests/embed/src/doctestx.h	/^#define DOCTEST_ADD_MESSAGE_AT(/;"	d
DOCTEST_ALIGNMENT	lib/doctest/doctest.h	/^#define DOCTEST_ALIGNMENT(/;"	d
DOCTEST_ALIGNMENT	tests/embed/src/doctestx.h	/^#define DOCTEST_ALIGNMENT(/;"	d
DOCTEST_AND_THEN	lib/doctest/doctest.h	/^#define DOCTEST_AND_THEN(/;"	d
DOCTEST_AND_THEN	tests/embed/src/doctestx.h	/^#define DOCTEST_AND_THEN(/;"	d
DOCTEST_AND_WHEN	lib/doctest/doctest.h	/^#define DOCTEST_AND_WHEN(/;"	d
DOCTEST_AND_WHEN	tests/embed/src/doctestx.h	/^#define DOCTEST_AND_WHEN(/;"	d
DOCTEST_ANONYMOUS	lib/doctest/doctest.h	/^#define DOCTEST_ANONYMOUS(/;"	d
DOCTEST_ANONYMOUS	tests/embed/src/doctestx.h	/^#define DOCTEST_ANONYMOUS(/;"	d
DOCTEST_APPROX_PREFIX	lib/doctest/doctest.h	/^#define DOCTEST_APPROX_PREFIX /;"	d
DOCTEST_APPROX_PREFIX	lib/doctest/doctest.h	/^#undef DOCTEST_APPROX_PREFIX$/;"	d
DOCTEST_APPROX_PREFIX	tests/embed/src/doctestx.h	/^#define DOCTEST_APPROX_PREFIX /;"	d
DOCTEST_APPROX_PREFIX	tests/embed/src/doctestx.h	/^#undef DOCTEST_APPROX_PREFIX$/;"	d
DOCTEST_ASSERT_IMPLEMENT_1	lib/doctest/doctest.h	/^#define DOCTEST_ASSERT_IMPLEMENT_1(/;"	d
DOCTEST_ASSERT_IMPLEMENT_1	tests/embed/src/doctestx.h	/^#define DOCTEST_ASSERT_IMPLEMENT_1(/;"	d
DOCTEST_ASSERT_IMPLEMENT_2	lib/doctest/doctest.h	/^#define DOCTEST_ASSERT_IMPLEMENT_2(/;"	d
DOCTEST_ASSERT_IMPLEMENT_2	tests/embed/src/doctestx.h	/^#define DOCTEST_ASSERT_IMPLEMENT_2(/;"	d
DOCTEST_ASSERT_IN_TESTS	lib/doctest/doctest.h	/^#define DOCTEST_ASSERT_IN_TESTS(/;"	d
DOCTEST_ASSERT_IN_TESTS	tests/embed/src/doctestx.h	/^#define DOCTEST_ASSERT_IN_TESTS(/;"	d
DOCTEST_ASSERT_LOG_AND_REACT	lib/doctest/doctest.h	/^#define DOCTEST_ASSERT_LOG_AND_REACT(/;"	d
DOCTEST_ASSERT_LOG_AND_REACT	tests/embed/src/doctestx.h	/^#define DOCTEST_ASSERT_LOG_AND_REACT(/;"	d
DOCTEST_ASSERT_NOTHROW	lib/doctest/doctest.h	/^#define DOCTEST_ASSERT_NOTHROW(/;"	d
DOCTEST_ASSERT_NOTHROW	tests/embed/src/doctestx.h	/^#define DOCTEST_ASSERT_NOTHROW(/;"	d
DOCTEST_ASSERT_OUT_OF_TESTS	lib/doctest/doctest.h	/^#define DOCTEST_ASSERT_OUT_OF_TESTS(/;"	d
DOCTEST_ASSERT_OUT_OF_TESTS	tests/embed/src/doctestx.h	/^#define DOCTEST_ASSERT_OUT_OF_TESTS(/;"	d
DOCTEST_ASSERT_THROWS_AS	lib/doctest/doctest.h	/^#define DOCTEST_ASSERT_THROWS_AS(/;"	d
DOCTEST_ASSERT_THROWS_AS	tests/embed/src/doctestx.h	/^#define DOCTEST_ASSERT_THROWS_AS(/;"	d
DOCTEST_ASSERT_THROWS_WITH	lib/doctest/doctest.h	/^#define DOCTEST_ASSERT_THROWS_WITH(/;"	d
DOCTEST_ASSERT_THROWS_WITH	tests/embed/src/doctestx.h	/^#define DOCTEST_ASSERT_THROWS_WITH(/;"	d
DOCTEST_BINARY_ASSERT	lib/doctest/doctest.h	/^#define DOCTEST_BINARY_ASSERT(/;"	d
DOCTEST_BINARY_ASSERT	tests/embed/src/doctestx.h	/^#define DOCTEST_BINARY_ASSERT(/;"	d
DOCTEST_BINARY_RELATIONAL_OP	lib/doctest/doctest.h	/^#define DOCTEST_BINARY_RELATIONAL_OP(/;"	d
DOCTEST_BINARY_RELATIONAL_OP	tests/embed/src/doctestx.h	/^#define DOCTEST_BINARY_RELATIONAL_OP(/;"	d
DOCTEST_BRANCH_ON_DISABLED	lib/doctest/doctest.h	/^#define DOCTEST_BRANCH_ON_DISABLED(/;"	d
DOCTEST_BRANCH_ON_DISABLED	tests/embed/src/doctestx.h	/^#define DOCTEST_BRANCH_ON_DISABLED(/;"	d
DOCTEST_BREAK_INTO_DEBUGGER	lib/doctest/doctest.h	/^#define DOCTEST_BREAK_INTO_DEBUGGER(/;"	d
DOCTEST_BREAK_INTO_DEBUGGER	tests/embed/src/doctestx.h	/^#define DOCTEST_BREAK_INTO_DEBUGGER(/;"	d
DOCTEST_CAPTURE	lib/doctest/doctest.h	/^#define DOCTEST_CAPTURE(/;"	d
DOCTEST_CAPTURE	tests/embed/src/doctestx.h	/^#define DOCTEST_CAPTURE(/;"	d
DOCTEST_CAST_TO_VOID	lib/doctest/doctest.h	/^#define DOCTEST_CAST_TO_VOID(/;"	d
DOCTEST_CAST_TO_VOID	tests/embed/src/doctestx.h	/^#define DOCTEST_CAST_TO_VOID(/;"	d
DOCTEST_CAT	lib/doctest/doctest.h	/^#define DOCTEST_CAT(/;"	d
DOCTEST_CAT	tests/embed/src/doctestx.h	/^#define DOCTEST_CAT(/;"	d
DOCTEST_CAT_IMPL	lib/doctest/doctest.h	/^#define DOCTEST_CAT_IMPL(/;"	d
DOCTEST_CAT_IMPL	tests/embed/src/doctestx.h	/^#define DOCTEST_CAT_IMPL(/;"	d
DOCTEST_CHECK	lib/doctest/doctest.h	/^#define DOCTEST_CHECK(/;"	d
DOCTEST_CHECK	tests/embed/src/doctestx.h	/^#define DOCTEST_CHECK(/;"	d
DOCTEST_CHECK_EQ	lib/doctest/doctest.h	/^#define DOCTEST_CHECK_EQ(/;"	d
DOCTEST_CHECK_EQ	tests/embed/src/doctestx.h	/^#define DOCTEST_CHECK_EQ(/;"	d
DOCTEST_CHECK_FALSE	lib/doctest/doctest.h	/^#define DOCTEST_CHECK_FALSE(/;"	d
DOCTEST_CHECK_FALSE	tests/embed/src/doctestx.h	/^#define DOCTEST_CHECK_FALSE(/;"	d
DOCTEST_CHECK_FALSE_MESSAGE	lib/doctest/doctest.h	/^#define DOCTEST_CHECK_FALSE_MESSAGE(/;"	d
DOCTEST_CHECK_FALSE_MESSAGE	tests/embed/src/doctestx.h	/^#define DOCTEST_CHECK_FALSE_MESSAGE(/;"	d
DOCTEST_CHECK_GE	lib/doctest/doctest.h	/^#define DOCTEST_CHECK_GE(/;"	d
DOCTEST_CHECK_GE	tests/embed/src/doctestx.h	/^#define DOCTEST_CHECK_GE(/;"	d
DOCTEST_CHECK_GT	lib/doctest/doctest.h	/^#define DOCTEST_CHECK_GT(/;"	d
DOCTEST_CHECK_GT	tests/embed/src/doctestx.h	/^#define DOCTEST_CHECK_GT(/;"	d
DOCTEST_CHECK_LE	lib/doctest/doctest.h	/^#define DOCTEST_CHECK_LE(/;"	d
DOCTEST_CHECK_LE	tests/embed/src/doctestx.h	/^#define DOCTEST_CHECK_LE(/;"	d
DOCTEST_CHECK_LT	lib/doctest/doctest.h	/^#define DOCTEST_CHECK_LT(/;"	d
DOCTEST_CHECK_LT	tests/embed/src/doctestx.h	/^#define DOCTEST_CHECK_LT(/;"	d
DOCTEST_CHECK_MESSAGE	lib/doctest/doctest.h	/^#define DOCTEST_CHECK_MESSAGE(/;"	d
DOCTEST_CHECK_MESSAGE	tests/embed/src/doctestx.h	/^#define DOCTEST_CHECK_MESSAGE(/;"	d
DOCTEST_CHECK_NE	lib/doctest/doctest.h	/^#define DOCTEST_CHECK_NE(/;"	d
DOCTEST_CHECK_NE	tests/embed/src/doctestx.h	/^#define DOCTEST_CHECK_NE(/;"	d
DOCTEST_CHECK_NOTHROW	lib/doctest/doctest.h	/^#define DOCTEST_CHECK_NOTHROW(/;"	d
DOCTEST_CHECK_NOTHROW	lib/doctest/doctest.h	/^#undef DOCTEST_CHECK_NOTHROW$/;"	d
DOCTEST_CHECK_NOTHROW	tests/embed/src/doctestx.h	/^#define DOCTEST_CHECK_NOTHROW(/;"	d
DOCTEST_CHECK_NOTHROW	tests/embed/src/doctestx.h	/^#undef DOCTEST_CHECK_NOTHROW$/;"	d
DOCTEST_CHECK_NOTHROW_MESSAGE	lib/doctest/doctest.h	/^#define DOCTEST_CHECK_NOTHROW_MESSAGE(/;"	d
DOCTEST_CHECK_NOTHROW_MESSAGE	lib/doctest/doctest.h	/^#undef DOCTEST_CHECK_NOTHROW_MESSAGE$/;"	d
DOCTEST_CHECK_NOTHROW_MESSAGE	tests/embed/src/doctestx.h	/^#define DOCTEST_CHECK_NOTHROW_MESSAGE(/;"	d
DOCTEST_CHECK_NOTHROW_MESSAGE	tests/embed/src/doctestx.h	/^#undef DOCTEST_CHECK_NOTHROW_MESSAGE$/;"	d
DOCTEST_CHECK_THROWS	lib/doctest/doctest.h	/^#define DOCTEST_CHECK_THROWS(/;"	d
DOCTEST_CHECK_THROWS	lib/doctest/doctest.h	/^#undef DOCTEST_CHECK_THROWS$/;"	d
DOCTEST_CHECK_THROWS	tests/embed/src/doctestx.h	/^#define DOCTEST_CHECK_THROWS(/;"	d
DOCTEST_CHECK_THROWS	tests/embed/src/doctestx.h	/^#undef DOCTEST_CHECK_THROWS$/;"	d
DOCTEST_CHECK_THROWS_AS	lib/doctest/doctest.h	/^#define DOCTEST_CHECK_THROWS_AS(/;"	d
DOCTEST_CHECK_THROWS_AS	lib/doctest/doctest.h	/^#undef DOCTEST_CHECK_THROWS_AS$/;"	d
DOCTEST_CHECK_THROWS_AS	tests/embed/src/doctestx.h	/^#define DOCTEST_CHECK_THROWS_AS(/;"	d
DOCTEST_CHECK_THROWS_AS	tests/embed/src/doctestx.h	/^#undef DOCTEST_CHECK_THROWS_AS$/;"	d
DOCTEST_CHECK_THROWS_AS_MESSAGE	lib/doctest/doctest.h	/^#define DOCTEST_CHECK_THROWS_AS_MESSAGE(/;"	d
DOCTEST_CHECK_THROWS_AS_MESSAGE	lib/doctest/doctest.h	/^#undef DOCTEST_CHECK_THROWS_AS_MESSAGE$/;"	d
DOCTEST_CHECK_THROWS_AS_MESSAGE	tests/embed/src/doctestx.h	/^#define DOCTEST_CHECK_THROWS_AS_MESSAGE(/;"	d
DOCTEST_CHECK_THROWS_AS_MESSAGE	tests/embed/src/doctestx.h	/^#undef DOCTEST_CHECK_THROWS_AS_MESSAGE$/;"	d
DOCTEST_CHECK_THROWS_MESSAGE	lib/doctest/doctest.h	/^#define DOCTEST_CHECK_THROWS_MESSAGE(/;"	d
DOCTEST_CHECK_THROWS_MESSAGE	lib/doctest/doctest.h	/^#undef DOCTEST_CHECK_THROWS_MESSAGE$/;"	d
DOCTEST_CHECK_THROWS_MESSAGE	tests/embed/src/doctestx.h	/^#define DOCTEST_CHECK_THROWS_MESSAGE(/;"	d
DOCTEST_CHECK_THROWS_MESSAGE	tests/embed/src/doctestx.h	/^#undef DOCTEST_CHECK_THROWS_MESSAGE$/;"	d
DOCTEST_CHECK_THROWS_WITH	lib/doctest/doctest.h	/^#define DOCTEST_CHECK_THROWS_WITH(/;"	d
DOCTEST_CHECK_THROWS_WITH	lib/doctest/doctest.h	/^#undef DOCTEST_CHECK_THROWS_WITH$/;"	d
DOCTEST_CHECK_THROWS_WITH	tests/embed/src/doctestx.h	/^#define DOCTEST_CHECK_THROWS_WITH(/;"	d
DOCTEST_CHECK_THROWS_WITH	tests/embed/src/doctestx.h	/^#undef DOCTEST_CHECK_THROWS_WITH$/;"	d
DOCTEST_CHECK_THROWS_WITH_AS	lib/doctest/doctest.h	/^#define DOCTEST_CHECK_THROWS_WITH_AS(/;"	d
DOCTEST_CHECK_THROWS_WITH_AS	lib/doctest/doctest.h	/^#undef DOCTEST_CHECK_THROWS_WITH_AS$/;"	d
DOCTEST_CHECK_THROWS_WITH_AS	tests/embed/src/doctestx.h	/^#define DOCTEST_CHECK_THROWS_WITH_AS(/;"	d
DOCTEST_CHECK_THROWS_WITH_AS	tests/embed/src/doctestx.h	/^#undef DOCTEST_CHECK_THROWS_WITH_AS$/;"	d
DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE	lib/doctest/doctest.h	/^#define DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE(/;"	d
DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE	lib/doctest/doctest.h	/^#undef DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE$/;"	d
DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE	tests/embed/src/doctestx.h	/^#define DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE(/;"	d
DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE	tests/embed/src/doctestx.h	/^#undef DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE$/;"	d
DOCTEST_CHECK_THROWS_WITH_MESSAGE	lib/doctest/doctest.h	/^#define DOCTEST_CHECK_THROWS_WITH_MESSAGE(/;"	d
DOCTEST_CHECK_THROWS_WITH_MESSAGE	lib/doctest/doctest.h	/^#undef DOCTEST_CHECK_THROWS_WITH_MESSAGE$/;"	d
DOCTEST_CHECK_THROWS_WITH_MESSAGE	tests/embed/src/doctestx.h	/^#define DOCTEST_CHECK_THROWS_WITH_MESSAGE(/;"	d
DOCTEST_CHECK_THROWS_WITH_MESSAGE	tests/embed/src/doctestx.h	/^#undef DOCTEST_CHECK_THROWS_WITH_MESSAGE$/;"	d
DOCTEST_CHECK_UNARY	lib/doctest/doctest.h	/^#define DOCTEST_CHECK_UNARY(/;"	d
DOCTEST_CHECK_UNARY	tests/embed/src/doctestx.h	/^#define DOCTEST_CHECK_UNARY(/;"	d
DOCTEST_CHECK_UNARY_FALSE	lib/doctest/doctest.h	/^#define DOCTEST_CHECK_UNARY_FALSE(/;"	d
DOCTEST_CHECK_UNARY_FALSE	tests/embed/src/doctestx.h	/^#define DOCTEST_CHECK_UNARY_FALSE(/;"	d
DOCTEST_CLANG	lib/doctest/doctest.h	/^#define DOCTEST_CLANG /;"	d
DOCTEST_CLANG	tests/embed/src/doctestx.h	/^#define DOCTEST_CLANG /;"	d
DOCTEST_CLANG_SUPPRESS_WARNING	lib/doctest/doctest.h	/^#define DOCTEST_CLANG_SUPPRESS_WARNING(/;"	d
DOCTEST_CLANG_SUPPRESS_WARNING	tests/embed/src/doctestx.h	/^#define DOCTEST_CLANG_SUPPRESS_WARNING(/;"	d
DOCTEST_CLANG_SUPPRESS_WARNING_POP	lib/doctest/doctest.h	/^#define DOCTEST_CLANG_SUPPRESS_WARNING_POP /;"	d
DOCTEST_CLANG_SUPPRESS_WARNING_POP	lib/doctest/doctest.h	/^#define DOCTEST_CLANG_SUPPRESS_WARNING_POP$/;"	d
DOCTEST_CLANG_SUPPRESS_WARNING_POP	tests/embed/src/doctestx.h	/^#define DOCTEST_CLANG_SUPPRESS_WARNING_POP /;"	d
DOCTEST_CLANG_SUPPRESS_WARNING_POP	tests/embed/src/doctestx.h	/^#define DOCTEST_CLANG_SUPPRESS_WARNING_POP$/;"	d
DOCTEST_CLANG_SUPPRESS_WARNING_PUSH	lib/doctest/doctest.h	/^#define DOCTEST_CLANG_SUPPRESS_WARNING_PUSH /;"	d
DOCTEST_CLANG_SUPPRESS_WARNING_PUSH	lib/doctest/doctest.h	/^#define DOCTEST_CLANG_SUPPRESS_WARNING_PUSH$/;"	d
DOCTEST_CLANG_SUPPRESS_WARNING_PUSH	tests/embed/src/doctestx.h	/^#define DOCTEST_CLANG_SUPPRESS_WARNING_PUSH /;"	d
DOCTEST_CLANG_SUPPRESS_WARNING_PUSH	tests/embed/src/doctestx.h	/^#define DOCTEST_CLANG_SUPPRESS_WARNING_PUSH$/;"	d
DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH	lib/doctest/doctest.h	/^#define DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH(/;"	d
DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH	tests/embed/src/doctestx.h	/^#define DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH(/;"	d
DOCTEST_CMP_EQ	lib/doctest/doctest.h	/^#define DOCTEST_CMP_EQ(/;"	d
DOCTEST_CMP_EQ	tests/embed/src/doctestx.h	/^#define DOCTEST_CMP_EQ(/;"	d
DOCTEST_CMP_GE	lib/doctest/doctest.h	/^#define DOCTEST_CMP_GE(/;"	d
DOCTEST_CMP_GE	tests/embed/src/doctestx.h	/^#define DOCTEST_CMP_GE(/;"	d
DOCTEST_CMP_GT	lib/doctest/doctest.h	/^#define DOCTEST_CMP_GT(/;"	d
DOCTEST_CMP_GT	tests/embed/src/doctestx.h	/^#define DOCTEST_CMP_GT(/;"	d
DOCTEST_CMP_LE	lib/doctest/doctest.h	/^#define DOCTEST_CMP_LE(/;"	d
DOCTEST_CMP_LE	tests/embed/src/doctestx.h	/^#define DOCTEST_CMP_LE(/;"	d
DOCTEST_CMP_LT	lib/doctest/doctest.h	/^#define DOCTEST_CMP_LT(/;"	d
DOCTEST_CMP_LT	tests/embed/src/doctestx.h	/^#define DOCTEST_CMP_LT(/;"	d
DOCTEST_CMP_NE	lib/doctest/doctest.h	/^#define DOCTEST_CMP_NE(/;"	d
DOCTEST_CMP_NE	tests/embed/src/doctestx.h	/^#define DOCTEST_CMP_NE(/;"	d
DOCTEST_COMPARISON_RETURN_TYPE	lib/doctest/doctest.h	/^#define DOCTEST_COMPARISON_RETURN_TYPE /;"	d
DOCTEST_COMPARISON_RETURN_TYPE	tests/embed/src/doctestx.h	/^#define DOCTEST_COMPARISON_RETURN_TYPE /;"	d
DOCTEST_COMPILER	lib/doctest/doctest.h	/^#define DOCTEST_COMPILER(/;"	d
DOCTEST_COMPILER	tests/embed/src/doctestx.h	/^#define DOCTEST_COMPILER(/;"	d
DOCTEST_CONFIG_COLORS_NONE	tests/embed/src/main.cpp	/^#define DOCTEST_CONFIG_COLORS_NONE$/;"	d	file:
DOCTEST_CONFIG_IMPLEMENT	lib/doctest/doctest.cpp	/^#define DOCTEST_CONFIG_IMPLEMENT$/;"	d	file:
DOCTEST_CONFIG_IMPLEMENT	lib/doctest/doctest.h	/^#define DOCTEST_CONFIG_IMPLEMENT$/;"	d
DOCTEST_CONFIG_IMPLEMENT	tests/embed/src/doctestx.h	/^#define DOCTEST_CONFIG_IMPLEMENT$/;"	d
DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN	tests/embed/src/main.cpp	/^#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN$/;"	d	file:
DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN	tests/gpio/main.cpp	/^#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN$/;"	d	file:
DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS	lib/doctest/doctest.h	/^#define DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS$/;"	d
DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS	tests/embed/src/doctestx.h	/^#define DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS$/;"	d
DOCTEST_CONFIG_NO_EXCEPTIONS	lib/doctest/doctest.h	/^#define DOCTEST_CONFIG_NO_EXCEPTIONS$/;"	d
DOCTEST_CONFIG_NO_EXCEPTIONS	tests/embed/src/doctestx.h	/^#define DOCTEST_CONFIG_NO_EXCEPTIONS$/;"	d
DOCTEST_CONFIG_NO_MULTI_LANE_ATOMICS	lib/doctest/doctest.h	/^#define DOCTEST_CONFIG_NO_MULTI_LANE_ATOMICS$/;"	d
DOCTEST_CONFIG_NO_MULTI_LANE_ATOMICS	tests/embed/src/doctestx.h	/^#define DOCTEST_CONFIG_NO_MULTI_LANE_ATOMICS$/;"	d
DOCTEST_CONFIG_NO_MULTI_LANE_ATOMICS	tests/embed/src/main.cpp	/^#define DOCTEST_CONFIG_NO_MULTI_LANE_ATOMICS$/;"	d	file:
DOCTEST_CONFIG_NO_POSIX_SIGNALS	tests/embed/src/main.cpp	/^#define DOCTEST_CONFIG_NO_POSIX_SIGNALS$/;"	d	file:
DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS	lib/doctest/doctest.h	/^#define DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS$/;"	d
DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS	tests/embed/src/doctestx.h	/^#define DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS$/;"	d
DOCTEST_CONFIG_OPTIONS_PREFIX	lib/doctest/doctest.h	/^#define DOCTEST_CONFIG_OPTIONS_PREFIX /;"	d
DOCTEST_CONFIG_OPTIONS_PREFIX	tests/embed/src/doctestx.h	/^#define DOCTEST_CONFIG_OPTIONS_PREFIX /;"	d
DOCTEST_CONFIG_POSIX_SIGNALS	lib/doctest/doctest.h	/^#define DOCTEST_CONFIG_POSIX_SIGNALS$/;"	d
DOCTEST_CONFIG_POSIX_SIGNALS	lib/doctest/doctest.h	/^#undef DOCTEST_CONFIG_POSIX_SIGNALS$/;"	d
DOCTEST_CONFIG_POSIX_SIGNALS	tests/embed/src/doctestx.h	/^#define DOCTEST_CONFIG_POSIX_SIGNALS$/;"	d
DOCTEST_CONFIG_POSIX_SIGNALS	tests/embed/src/doctestx.h	/^#undef DOCTEST_CONFIG_POSIX_SIGNALS$/;"	d
DOCTEST_CONFIG_USE_STD_HEADERS	lib/doctest/doctest.h	/^#define DOCTEST_CONFIG_USE_STD_HEADERS$/;"	d
DOCTEST_CONFIG_USE_STD_HEADERS	tests/embed/src/doctestx.h	/^#define DOCTEST_CONFIG_USE_STD_HEADERS$/;"	d
DOCTEST_CONFIG_WINDOWS_SEH	lib/doctest/doctest.h	/^#define DOCTEST_CONFIG_WINDOWS_SEH$/;"	d
DOCTEST_CONFIG_WINDOWS_SEH	lib/doctest/doctest.h	/^#undef DOCTEST_CONFIG_WINDOWS_SEH$/;"	d
DOCTEST_CONFIG_WINDOWS_SEH	tests/embed/src/doctestx.h	/^#define DOCTEST_CONFIG_WINDOWS_SEH$/;"	d
DOCTEST_CONFIG_WINDOWS_SEH	tests/embed/src/doctestx.h	/^#undef DOCTEST_CONFIG_WINDOWS_SEH$/;"	d
DOCTEST_COUNTOF	lib/doctest/doctest.h	/^#define DOCTEST_COUNTOF(/;"	d
DOCTEST_COUNTOF	tests/embed/src/doctestx.h	/^#define DOCTEST_COUNTOF(/;"	d
DOCTEST_CREATE_AND_REGISTER_FUNCTION	lib/doctest/doctest.h	/^#define DOCTEST_CREATE_AND_REGISTER_FUNCTION(/;"	d
DOCTEST_CREATE_AND_REGISTER_FUNCTION	tests/embed/src/doctestx.h	/^#define DOCTEST_CREATE_AND_REGISTER_FUNCTION(/;"	d
DOCTEST_CREATE_AND_REGISTER_FUNCTION_IN_CLASS	lib/doctest/doctest.h	/^#define DOCTEST_CREATE_AND_REGISTER_FUNCTION_IN_CLASS(/;"	d
DOCTEST_CREATE_AND_REGISTER_FUNCTION_IN_CLASS	tests/embed/src/doctestx.h	/^#define DOCTEST_CREATE_AND_REGISTER_FUNCTION_IN_CLASS(/;"	d
DOCTEST_DEFINE_DECORATOR	lib/doctest/doctest.h	/^#define DOCTEST_DEFINE_DECORATOR(/;"	d
DOCTEST_DEFINE_DECORATOR	tests/embed/src/doctestx.h	/^#define DOCTEST_DEFINE_DECORATOR(/;"	d
DOCTEST_DO_BINARY_EXPRESSION_COMPARISON	lib/doctest/doctest.h	/^#define DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(/;"	d
DOCTEST_DO_BINARY_EXPRESSION_COMPARISON	tests/embed/src/doctestx.h	/^#define DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(/;"	d
DOCTEST_EMPTY	lib/doctest/doctest.h	/^#define DOCTEST_EMPTY$/;"	d
DOCTEST_EMPTY	tests/embed/src/doctestx.h	/^#define DOCTEST_EMPTY$/;"	d
DOCTEST_FAIL	lib/doctest/doctest.h	/^#define DOCTEST_FAIL(/;"	d
DOCTEST_FAIL	tests/embed/src/doctestx.h	/^#define DOCTEST_FAIL(/;"	d
DOCTEST_FAIL_CHECK	lib/doctest/doctest.h	/^#define DOCTEST_FAIL_CHECK(/;"	d
DOCTEST_FAIL_CHECK	tests/embed/src/doctestx.h	/^#define DOCTEST_FAIL_CHECK(/;"	d
DOCTEST_FAST_CHECK_EQ	lib/doctest/doctest.h	/^#define DOCTEST_FAST_CHECK_EQ /;"	d
DOCTEST_FAST_CHECK_EQ	tests/embed/src/doctestx.h	/^#define DOCTEST_FAST_CHECK_EQ /;"	d
DOCTEST_FAST_CHECK_GE	lib/doctest/doctest.h	/^#define DOCTEST_FAST_CHECK_GE /;"	d
DOCTEST_FAST_CHECK_GE	tests/embed/src/doctestx.h	/^#define DOCTEST_FAST_CHECK_GE /;"	d
DOCTEST_FAST_CHECK_GT	lib/doctest/doctest.h	/^#define DOCTEST_FAST_CHECK_GT /;"	d
DOCTEST_FAST_CHECK_GT	tests/embed/src/doctestx.h	/^#define DOCTEST_FAST_CHECK_GT /;"	d
DOCTEST_FAST_CHECK_LE	lib/doctest/doctest.h	/^#define DOCTEST_FAST_CHECK_LE /;"	d
DOCTEST_FAST_CHECK_LE	tests/embed/src/doctestx.h	/^#define DOCTEST_FAST_CHECK_LE /;"	d
DOCTEST_FAST_CHECK_LT	lib/doctest/doctest.h	/^#define DOCTEST_FAST_CHECK_LT /;"	d
DOCTEST_FAST_CHECK_LT	tests/embed/src/doctestx.h	/^#define DOCTEST_FAST_CHECK_LT /;"	d
DOCTEST_FAST_CHECK_NE	lib/doctest/doctest.h	/^#define DOCTEST_FAST_CHECK_NE /;"	d
DOCTEST_FAST_CHECK_NE	tests/embed/src/doctestx.h	/^#define DOCTEST_FAST_CHECK_NE /;"	d
DOCTEST_FAST_CHECK_UNARY	lib/doctest/doctest.h	/^#define DOCTEST_FAST_CHECK_UNARY /;"	d
DOCTEST_FAST_CHECK_UNARY	tests/embed/src/doctestx.h	/^#define DOCTEST_FAST_CHECK_UNARY /;"	d
DOCTEST_FAST_CHECK_UNARY_FALSE	lib/doctest/doctest.h	/^#define DOCTEST_FAST_CHECK_UNARY_FALSE /;"	d
DOCTEST_FAST_CHECK_UNARY_FALSE	tests/embed/src/doctestx.h	/^#define DOCTEST_FAST_CHECK_UNARY_FALSE /;"	d
DOCTEST_FAST_REQUIRE_EQ	lib/doctest/doctest.h	/^#define DOCTEST_FAST_REQUIRE_EQ /;"	d
DOCTEST_FAST_REQUIRE_EQ	tests/embed/src/doctestx.h	/^#define DOCTEST_FAST_REQUIRE_EQ /;"	d
DOCTEST_FAST_REQUIRE_GE	lib/doctest/doctest.h	/^#define DOCTEST_FAST_REQUIRE_GE /;"	d
DOCTEST_FAST_REQUIRE_GE	tests/embed/src/doctestx.h	/^#define DOCTEST_FAST_REQUIRE_GE /;"	d
DOCTEST_FAST_REQUIRE_GT	lib/doctest/doctest.h	/^#define DOCTEST_FAST_REQUIRE_GT /;"	d
DOCTEST_FAST_REQUIRE_GT	tests/embed/src/doctestx.h	/^#define DOCTEST_FAST_REQUIRE_GT /;"	d
DOCTEST_FAST_REQUIRE_LE	lib/doctest/doctest.h	/^#define DOCTEST_FAST_REQUIRE_LE /;"	d
DOCTEST_FAST_REQUIRE_LE	tests/embed/src/doctestx.h	/^#define DOCTEST_FAST_REQUIRE_LE /;"	d
DOCTEST_FAST_REQUIRE_LT	lib/doctest/doctest.h	/^#define DOCTEST_FAST_REQUIRE_LT /;"	d
DOCTEST_FAST_REQUIRE_LT	tests/embed/src/doctestx.h	/^#define DOCTEST_FAST_REQUIRE_LT /;"	d
DOCTEST_FAST_REQUIRE_NE	lib/doctest/doctest.h	/^#define DOCTEST_FAST_REQUIRE_NE /;"	d
DOCTEST_FAST_REQUIRE_NE	tests/embed/src/doctestx.h	/^#define DOCTEST_FAST_REQUIRE_NE /;"	d
DOCTEST_FAST_REQUIRE_UNARY	lib/doctest/doctest.h	/^#define DOCTEST_FAST_REQUIRE_UNARY /;"	d
DOCTEST_FAST_REQUIRE_UNARY	tests/embed/src/doctestx.h	/^#define DOCTEST_FAST_REQUIRE_UNARY /;"	d
DOCTEST_FAST_REQUIRE_UNARY_FALSE	lib/doctest/doctest.h	/^#define DOCTEST_FAST_REQUIRE_UNARY_FALSE /;"	d
DOCTEST_FAST_REQUIRE_UNARY_FALSE	tests/embed/src/doctestx.h	/^#define DOCTEST_FAST_REQUIRE_UNARY_FALSE /;"	d
DOCTEST_FAST_WARN_EQ	lib/doctest/doctest.h	/^#define DOCTEST_FAST_WARN_EQ /;"	d
DOCTEST_FAST_WARN_EQ	tests/embed/src/doctestx.h	/^#define DOCTEST_FAST_WARN_EQ /;"	d
DOCTEST_FAST_WARN_GE	lib/doctest/doctest.h	/^#define DOCTEST_FAST_WARN_GE /;"	d
DOCTEST_FAST_WARN_GE	tests/embed/src/doctestx.h	/^#define DOCTEST_FAST_WARN_GE /;"	d
DOCTEST_FAST_WARN_GT	lib/doctest/doctest.h	/^#define DOCTEST_FAST_WARN_GT /;"	d
DOCTEST_FAST_WARN_GT	tests/embed/src/doctestx.h	/^#define DOCTEST_FAST_WARN_GT /;"	d
DOCTEST_FAST_WARN_LE	lib/doctest/doctest.h	/^#define DOCTEST_FAST_WARN_LE /;"	d
DOCTEST_FAST_WARN_LE	tests/embed/src/doctestx.h	/^#define DOCTEST_FAST_WARN_LE /;"	d
DOCTEST_FAST_WARN_LT	lib/doctest/doctest.h	/^#define DOCTEST_FAST_WARN_LT /;"	d
DOCTEST_FAST_WARN_LT	tests/embed/src/doctestx.h	/^#define DOCTEST_FAST_WARN_LT /;"	d
DOCTEST_FAST_WARN_NE	lib/doctest/doctest.h	/^#define DOCTEST_FAST_WARN_NE /;"	d
DOCTEST_FAST_WARN_NE	tests/embed/src/doctestx.h	/^#define DOCTEST_FAST_WARN_NE /;"	d
DOCTEST_FAST_WARN_UNARY	lib/doctest/doctest.h	/^#define DOCTEST_FAST_WARN_UNARY /;"	d
DOCTEST_FAST_WARN_UNARY	tests/embed/src/doctestx.h	/^#define DOCTEST_FAST_WARN_UNARY /;"	d
DOCTEST_FAST_WARN_UNARY_FALSE	lib/doctest/doctest.h	/^#define DOCTEST_FAST_WARN_UNARY_FALSE /;"	d
DOCTEST_FAST_WARN_UNARY_FALSE	tests/embed/src/doctestx.h	/^#define DOCTEST_FAST_WARN_UNARY_FALSE /;"	d
DOCTEST_FORBIT_EXPRESSION	lib/doctest/doctest.h	/^#define DOCTEST_FORBIT_EXPRESSION(/;"	d
DOCTEST_FORBIT_EXPRESSION	tests/embed/src/doctestx.h	/^#define DOCTEST_FORBIT_EXPRESSION(/;"	d
DOCTEST_GCC	lib/doctest/doctest.h	/^#define DOCTEST_GCC /;"	d
DOCTEST_GCC	tests/embed/src/doctestx.h	/^#define DOCTEST_GCC /;"	d
DOCTEST_GCC_SUPPRESS_WARNING	lib/doctest/doctest.h	/^#define DOCTEST_GCC_SUPPRESS_WARNING(/;"	d
DOCTEST_GCC_SUPPRESS_WARNING	tests/embed/src/doctestx.h	/^#define DOCTEST_GCC_SUPPRESS_WARNING(/;"	d
DOCTEST_GCC_SUPPRESS_WARNING_POP	lib/doctest/doctest.h	/^#define DOCTEST_GCC_SUPPRESS_WARNING_POP /;"	d
DOCTEST_GCC_SUPPRESS_WARNING_POP	lib/doctest/doctest.h	/^#define DOCTEST_GCC_SUPPRESS_WARNING_POP$/;"	d
DOCTEST_GCC_SUPPRESS_WARNING_POP	tests/embed/src/doctestx.h	/^#define DOCTEST_GCC_SUPPRESS_WARNING_POP /;"	d
DOCTEST_GCC_SUPPRESS_WARNING_POP	tests/embed/src/doctestx.h	/^#define DOCTEST_GCC_SUPPRESS_WARNING_POP$/;"	d
DOCTEST_GCC_SUPPRESS_WARNING_PUSH	lib/doctest/doctest.h	/^#define DOCTEST_GCC_SUPPRESS_WARNING_PUSH /;"	d
DOCTEST_GCC_SUPPRESS_WARNING_PUSH	lib/doctest/doctest.h	/^#define DOCTEST_GCC_SUPPRESS_WARNING_PUSH$/;"	d
DOCTEST_GCC_SUPPRESS_WARNING_PUSH	tests/embed/src/doctestx.h	/^#define DOCTEST_GCC_SUPPRESS_WARNING_PUSH /;"	d
DOCTEST_GCC_SUPPRESS_WARNING_PUSH	tests/embed/src/doctestx.h	/^#define DOCTEST_GCC_SUPPRESS_WARNING_PUSH$/;"	d
DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH	lib/doctest/doctest.h	/^#define DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH(/;"	d
DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH	tests/embed/src/doctestx.h	/^#define DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH(/;"	d
DOCTEST_GIVEN	lib/doctest/doctest.h	/^#define DOCTEST_GIVEN(/;"	d
DOCTEST_GIVEN	tests/embed/src/doctestx.h	/^#define DOCTEST_GIVEN(/;"	d
DOCTEST_GLOBAL_NO_WARNINGS	lib/doctest/doctest.h	/^#define DOCTEST_GLOBAL_NO_WARNINGS(/;"	d
DOCTEST_GLOBAL_NO_WARNINGS	tests/embed/src/doctestx.h	/^#define DOCTEST_GLOBAL_NO_WARNINGS(/;"	d
DOCTEST_GLOBAL_NO_WARNINGS_END	lib/doctest/doctest.h	/^#define DOCTEST_GLOBAL_NO_WARNINGS_END(/;"	d
DOCTEST_GLOBAL_NO_WARNINGS_END	tests/embed/src/doctestx.h	/^#define DOCTEST_GLOBAL_NO_WARNINGS_END(/;"	d
DOCTEST_IMPLEMENT_FIXTURE	lib/doctest/doctest.h	/^#define DOCTEST_IMPLEMENT_FIXTURE(/;"	d
DOCTEST_IMPLEMENT_FIXTURE	tests/embed/src/doctestx.h	/^#define DOCTEST_IMPLEMENT_FIXTURE(/;"	d
DOCTEST_INFO	lib/doctest/doctest.h	/^#define DOCTEST_INFO(/;"	d
DOCTEST_INFO	tests/embed/src/doctestx.h	/^#define DOCTEST_INFO(/;"	d
DOCTEST_INFO_IMPL	lib/doctest/doctest.h	/^#define DOCTEST_INFO_IMPL(/;"	d
DOCTEST_INFO_IMPL	tests/embed/src/doctestx.h	/^#define DOCTEST_INFO_IMPL(/;"	d
DOCTEST_INTERFACE	lib/doctest/doctest.h	/^#define DOCTEST_INTERFACE /;"	d
DOCTEST_INTERFACE	tests/embed/src/doctestx.h	/^#define DOCTEST_INTERFACE /;"	d
DOCTEST_LIBRARY_IMPLEMENTATION	lib/doctest/doctest.h	/^#define DOCTEST_LIBRARY_IMPLEMENTATION$/;"	d
DOCTEST_LIBRARY_IMPLEMENTATION	tests/embed/src/doctestx.h	/^#define DOCTEST_LIBRARY_IMPLEMENTATION$/;"	d
DOCTEST_LIBRARY_INCLUDED	lib/doctest/doctest.h	/^#define DOCTEST_LIBRARY_INCLUDED$/;"	d
DOCTEST_LIBRARY_INCLUDED	tests/embed/src/doctestx.h	/^#define DOCTEST_LIBRARY_INCLUDED$/;"	d
DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_BEGIN	lib/doctest/doctest.h	/^#define DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_BEGIN /;"	d
DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_BEGIN	tests/embed/src/doctestx.h	/^#define DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_BEGIN /;"	d
DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_END	lib/doctest/doctest.h	/^#define DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_END /;"	d
DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_END	tests/embed/src/doctestx.h	/^#define DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_END /;"	d
DOCTEST_MESSAGE	lib/doctest/doctest.h	/^#define DOCTEST_MESSAGE(/;"	d
DOCTEST_MESSAGE	tests/embed/src/doctestx.h	/^#define DOCTEST_MESSAGE(/;"	d
DOCTEST_MSVC	lib/doctest/doctest.h	/^#define DOCTEST_MSVC /;"	d
DOCTEST_MSVC	tests/embed/src/doctestx.h	/^#define DOCTEST_MSVC /;"	d
DOCTEST_MSVC_SUPPRESS_WARNING	lib/doctest/doctest.h	/^#define DOCTEST_MSVC_SUPPRESS_WARNING(/;"	d
DOCTEST_MSVC_SUPPRESS_WARNING	tests/embed/src/doctestx.h	/^#define DOCTEST_MSVC_SUPPRESS_WARNING(/;"	d
DOCTEST_MSVC_SUPPRESS_WARNING_POP	lib/doctest/doctest.h	/^#define DOCTEST_MSVC_SUPPRESS_WARNING_POP /;"	d
DOCTEST_MSVC_SUPPRESS_WARNING_POP	lib/doctest/doctest.h	/^#define DOCTEST_MSVC_SUPPRESS_WARNING_POP$/;"	d
DOCTEST_MSVC_SUPPRESS_WARNING_POP	tests/embed/src/doctestx.h	/^#define DOCTEST_MSVC_SUPPRESS_WARNING_POP /;"	d
DOCTEST_MSVC_SUPPRESS_WARNING_POP	tests/embed/src/doctestx.h	/^#define DOCTEST_MSVC_SUPPRESS_WARNING_POP$/;"	d
DOCTEST_MSVC_SUPPRESS_WARNING_PUSH	lib/doctest/doctest.h	/^#define DOCTEST_MSVC_SUPPRESS_WARNING_PUSH /;"	d
DOCTEST_MSVC_SUPPRESS_WARNING_PUSH	lib/doctest/doctest.h	/^#define DOCTEST_MSVC_SUPPRESS_WARNING_PUSH$/;"	d
DOCTEST_MSVC_SUPPRESS_WARNING_PUSH	tests/embed/src/doctestx.h	/^#define DOCTEST_MSVC_SUPPRESS_WARNING_PUSH /;"	d
DOCTEST_MSVC_SUPPRESS_WARNING_PUSH	tests/embed/src/doctestx.h	/^#define DOCTEST_MSVC_SUPPRESS_WARNING_PUSH$/;"	d
DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH	lib/doctest/doctest.h	/^#define DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(/;"	d
DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH	tests/embed/src/doctestx.h	/^#define DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(/;"	d
DOCTEST_MULTI_LANE_ATOMICS_CACHE_LINE_SIZE	lib/doctest/doctest.h	/^#define DOCTEST_MULTI_LANE_ATOMICS_CACHE_LINE_SIZE /;"	d
DOCTEST_MULTI_LANE_ATOMICS_CACHE_LINE_SIZE	tests/embed/src/doctestx.h	/^#define DOCTEST_MULTI_LANE_ATOMICS_CACHE_LINE_SIZE /;"	d
DOCTEST_MULTI_LANE_ATOMICS_THREAD_LANES	lib/doctest/doctest.h	/^#define DOCTEST_MULTI_LANE_ATOMICS_THREAD_LANES /;"	d
DOCTEST_MULTI_LANE_ATOMICS_THREAD_LANES	tests/embed/src/doctestx.h	/^#define DOCTEST_MULTI_LANE_ATOMICS_THREAD_LANES /;"	d
DOCTEST_NOEXCEPT	lib/doctest/doctest.h	/^#define DOCTEST_NOEXCEPT /;"	d
DOCTEST_NOEXCEPT	tests/embed/src/doctestx.h	/^#define DOCTEST_NOEXCEPT /;"	d
DOCTEST_NOINLINE	lib/doctest/doctest.h	/^#define DOCTEST_NOINLINE /;"	d
DOCTEST_NOINLINE	tests/embed/src/doctestx.h	/^#define DOCTEST_NOINLINE /;"	d
DOCTEST_NORETURN	lib/doctest/doctest.h	/^#define DOCTEST_NORETURN /;"	d
DOCTEST_NORETURN	tests/embed/src/doctestx.h	/^#define DOCTEST_NORETURN /;"	d
DOCTEST_OPTIONS_PREFIX_DISPLAY	lib/doctest/doctest.h	/^#define DOCTEST_OPTIONS_PREFIX_DISPLAY /;"	d
DOCTEST_OPTIONS_PREFIX_DISPLAY	tests/embed/src/doctestx.h	/^#define DOCTEST_OPTIONS_PREFIX_DISPLAY /;"	d
DOCTEST_PLATFORM_MAC	lib/doctest/doctest.h	/^#define DOCTEST_PLATFORM_MAC$/;"	d
DOCTEST_PLATFORM_MAC	tests/embed/src/doctestx.h	/^#define DOCTEST_PLATFORM_MAC$/;"	d
DOCTEST_PRAGMA_TO_STR	lib/doctest/doctest.h	/^#define DOCTEST_PRAGMA_TO_STR(/;"	d
DOCTEST_PRAGMA_TO_STR	tests/embed/src/doctestx.h	/^#define DOCTEST_PRAGMA_TO_STR(/;"	d
DOCTEST_REF_WRAP	lib/doctest/doctest.h	/^#define DOCTEST_REF_WRAP(/;"	d
DOCTEST_REF_WRAP	tests/embed/src/doctestx.h	/^#define DOCTEST_REF_WRAP(/;"	d
DOCTEST_REGISTER_EXCEPTION_TRANSLATOR	lib/doctest/doctest.h	/^#define DOCTEST_REGISTER_EXCEPTION_TRANSLATOR(/;"	d
DOCTEST_REGISTER_EXCEPTION_TRANSLATOR	tests/embed/src/doctestx.h	/^#define DOCTEST_REGISTER_EXCEPTION_TRANSLATOR(/;"	d
DOCTEST_REGISTER_EXCEPTION_TRANSLATOR_IMPL	lib/doctest/doctest.h	/^#define DOCTEST_REGISTER_EXCEPTION_TRANSLATOR_IMPL(/;"	d
DOCTEST_REGISTER_EXCEPTION_TRANSLATOR_IMPL	tests/embed/src/doctestx.h	/^#define DOCTEST_REGISTER_EXCEPTION_TRANSLATOR_IMPL(/;"	d
DOCTEST_REGISTER_FUNCTION	lib/doctest/doctest.h	/^#define DOCTEST_REGISTER_FUNCTION(/;"	d
DOCTEST_REGISTER_FUNCTION	tests/embed/src/doctestx.h	/^#define DOCTEST_REGISTER_FUNCTION(/;"	d
DOCTEST_REGISTER_LISTENER	lib/doctest/doctest.h	/^#define DOCTEST_REGISTER_LISTENER(/;"	d
DOCTEST_REGISTER_LISTENER	tests/embed/src/doctestx.h	/^#define DOCTEST_REGISTER_LISTENER(/;"	d
DOCTEST_REGISTER_REPORTER	lib/doctest/doctest.h	/^#define DOCTEST_REGISTER_REPORTER(/;"	d
DOCTEST_REGISTER_REPORTER	tests/embed/src/doctestx.h	/^#define DOCTEST_REGISTER_REPORTER(/;"	d
DOCTEST_RELATIONAL_OP	lib/doctest/doctest.h	/^#define DOCTEST_RELATIONAL_OP(/;"	d
DOCTEST_RELATIONAL_OP	tests/embed/src/doctestx.h	/^#define DOCTEST_RELATIONAL_OP(/;"	d
DOCTEST_REQUIRE	lib/doctest/doctest.h	/^#define DOCTEST_REQUIRE(/;"	d
DOCTEST_REQUIRE	tests/embed/src/doctestx.h	/^#define DOCTEST_REQUIRE(/;"	d
DOCTEST_REQUIRE_EQ	lib/doctest/doctest.h	/^#define DOCTEST_REQUIRE_EQ(/;"	d
DOCTEST_REQUIRE_EQ	tests/embed/src/doctestx.h	/^#define DOCTEST_REQUIRE_EQ(/;"	d
DOCTEST_REQUIRE_FALSE	lib/doctest/doctest.h	/^#define DOCTEST_REQUIRE_FALSE(/;"	d
DOCTEST_REQUIRE_FALSE	tests/embed/src/doctestx.h	/^#define DOCTEST_REQUIRE_FALSE(/;"	d
DOCTEST_REQUIRE_FALSE_MESSAGE	lib/doctest/doctest.h	/^#define DOCTEST_REQUIRE_FALSE_MESSAGE(/;"	d
DOCTEST_REQUIRE_FALSE_MESSAGE	tests/embed/src/doctestx.h	/^#define DOCTEST_REQUIRE_FALSE_MESSAGE(/;"	d
DOCTEST_REQUIRE_GE	lib/doctest/doctest.h	/^#define DOCTEST_REQUIRE_GE(/;"	d
DOCTEST_REQUIRE_GE	tests/embed/src/doctestx.h	/^#define DOCTEST_REQUIRE_GE(/;"	d
DOCTEST_REQUIRE_GT	lib/doctest/doctest.h	/^#define DOCTEST_REQUIRE_GT(/;"	d
DOCTEST_REQUIRE_GT	tests/embed/src/doctestx.h	/^#define DOCTEST_REQUIRE_GT(/;"	d
DOCTEST_REQUIRE_LE	lib/doctest/doctest.h	/^#define DOCTEST_REQUIRE_LE(/;"	d
DOCTEST_REQUIRE_LE	tests/embed/src/doctestx.h	/^#define DOCTEST_REQUIRE_LE(/;"	d
DOCTEST_REQUIRE_LT	lib/doctest/doctest.h	/^#define DOCTEST_REQUIRE_LT(/;"	d
DOCTEST_REQUIRE_LT	tests/embed/src/doctestx.h	/^#define DOCTEST_REQUIRE_LT(/;"	d
DOCTEST_REQUIRE_MESSAGE	lib/doctest/doctest.h	/^#define DOCTEST_REQUIRE_MESSAGE(/;"	d
DOCTEST_REQUIRE_MESSAGE	tests/embed/src/doctestx.h	/^#define DOCTEST_REQUIRE_MESSAGE(/;"	d
DOCTEST_REQUIRE_NE	lib/doctest/doctest.h	/^#define DOCTEST_REQUIRE_NE(/;"	d
DOCTEST_REQUIRE_NE	tests/embed/src/doctestx.h	/^#define DOCTEST_REQUIRE_NE(/;"	d
DOCTEST_REQUIRE_NOTHROW	lib/doctest/doctest.h	/^#define DOCTEST_REQUIRE_NOTHROW(/;"	d
DOCTEST_REQUIRE_NOTHROW	lib/doctest/doctest.h	/^#undef DOCTEST_REQUIRE_NOTHROW$/;"	d
DOCTEST_REQUIRE_NOTHROW	tests/embed/src/doctestx.h	/^#define DOCTEST_REQUIRE_NOTHROW(/;"	d
DOCTEST_REQUIRE_NOTHROW	tests/embed/src/doctestx.h	/^#undef DOCTEST_REQUIRE_NOTHROW$/;"	d
DOCTEST_REQUIRE_NOTHROW_MESSAGE	lib/doctest/doctest.h	/^#define DOCTEST_REQUIRE_NOTHROW_MESSAGE(/;"	d
DOCTEST_REQUIRE_NOTHROW_MESSAGE	lib/doctest/doctest.h	/^#undef DOCTEST_REQUIRE_NOTHROW_MESSAGE$/;"	d
DOCTEST_REQUIRE_NOTHROW_MESSAGE	tests/embed/src/doctestx.h	/^#define DOCTEST_REQUIRE_NOTHROW_MESSAGE(/;"	d
DOCTEST_REQUIRE_NOTHROW_MESSAGE	tests/embed/src/doctestx.h	/^#undef DOCTEST_REQUIRE_NOTHROW_MESSAGE$/;"	d
DOCTEST_REQUIRE_THROWS	lib/doctest/doctest.h	/^#define DOCTEST_REQUIRE_THROWS(/;"	d
DOCTEST_REQUIRE_THROWS	lib/doctest/doctest.h	/^#undef DOCTEST_REQUIRE_THROWS$/;"	d
DOCTEST_REQUIRE_THROWS	tests/embed/src/doctestx.h	/^#define DOCTEST_REQUIRE_THROWS(/;"	d
DOCTEST_REQUIRE_THROWS	tests/embed/src/doctestx.h	/^#undef DOCTEST_REQUIRE_THROWS$/;"	d
DOCTEST_REQUIRE_THROWS_AS	lib/doctest/doctest.h	/^#define DOCTEST_REQUIRE_THROWS_AS(/;"	d
DOCTEST_REQUIRE_THROWS_AS	lib/doctest/doctest.h	/^#undef DOCTEST_REQUIRE_THROWS_AS$/;"	d
DOCTEST_REQUIRE_THROWS_AS	tests/embed/src/doctestx.h	/^#define DOCTEST_REQUIRE_THROWS_AS(/;"	d
DOCTEST_REQUIRE_THROWS_AS	tests/embed/src/doctestx.h	/^#undef DOCTEST_REQUIRE_THROWS_AS$/;"	d
DOCTEST_REQUIRE_THROWS_AS_MESSAGE	lib/doctest/doctest.h	/^#define DOCTEST_REQUIRE_THROWS_AS_MESSAGE(/;"	d
DOCTEST_REQUIRE_THROWS_AS_MESSAGE	lib/doctest/doctest.h	/^#undef DOCTEST_REQUIRE_THROWS_AS_MESSAGE$/;"	d
DOCTEST_REQUIRE_THROWS_AS_MESSAGE	tests/embed/src/doctestx.h	/^#define DOCTEST_REQUIRE_THROWS_AS_MESSAGE(/;"	d
DOCTEST_REQUIRE_THROWS_AS_MESSAGE	tests/embed/src/doctestx.h	/^#undef DOCTEST_REQUIRE_THROWS_AS_MESSAGE$/;"	d
DOCTEST_REQUIRE_THROWS_MESSAGE	lib/doctest/doctest.h	/^#define DOCTEST_REQUIRE_THROWS_MESSAGE(/;"	d
DOCTEST_REQUIRE_THROWS_MESSAGE	lib/doctest/doctest.h	/^#undef DOCTEST_REQUIRE_THROWS_MESSAGE$/;"	d
DOCTEST_REQUIRE_THROWS_MESSAGE	tests/embed/src/doctestx.h	/^#define DOCTEST_REQUIRE_THROWS_MESSAGE(/;"	d
DOCTEST_REQUIRE_THROWS_MESSAGE	tests/embed/src/doctestx.h	/^#undef DOCTEST_REQUIRE_THROWS_MESSAGE$/;"	d
DOCTEST_REQUIRE_THROWS_WITH	lib/doctest/doctest.h	/^#define DOCTEST_REQUIRE_THROWS_WITH(/;"	d
DOCTEST_REQUIRE_THROWS_WITH	lib/doctest/doctest.h	/^#undef DOCTEST_REQUIRE_THROWS_WITH$/;"	d
DOCTEST_REQUIRE_THROWS_WITH	tests/embed/src/doctestx.h	/^#define DOCTEST_REQUIRE_THROWS_WITH(/;"	d
DOCTEST_REQUIRE_THROWS_WITH	tests/embed/src/doctestx.h	/^#undef DOCTEST_REQUIRE_THROWS_WITH$/;"	d
DOCTEST_REQUIRE_THROWS_WITH_AS	lib/doctest/doctest.h	/^#define DOCTEST_REQUIRE_THROWS_WITH_AS(/;"	d
DOCTEST_REQUIRE_THROWS_WITH_AS	lib/doctest/doctest.h	/^#undef DOCTEST_REQUIRE_THROWS_WITH_AS$/;"	d
DOCTEST_REQUIRE_THROWS_WITH_AS	tests/embed/src/doctestx.h	/^#define DOCTEST_REQUIRE_THROWS_WITH_AS(/;"	d
DOCTEST_REQUIRE_THROWS_WITH_AS	tests/embed/src/doctestx.h	/^#undef DOCTEST_REQUIRE_THROWS_WITH_AS$/;"	d
DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE	lib/doctest/doctest.h	/^#define DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE(/;"	d
DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE	lib/doctest/doctest.h	/^#undef DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE$/;"	d
DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE	tests/embed/src/doctestx.h	/^#define DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE(/;"	d
DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE	tests/embed/src/doctestx.h	/^#undef DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE$/;"	d
DOCTEST_REQUIRE_THROWS_WITH_MESSAGE	lib/doctest/doctest.h	/^#define DOCTEST_REQUIRE_THROWS_WITH_MESSAGE(/;"	d
DOCTEST_REQUIRE_THROWS_WITH_MESSAGE	lib/doctest/doctest.h	/^#undef DOCTEST_REQUIRE_THROWS_WITH_MESSAGE$/;"	d
DOCTEST_REQUIRE_THROWS_WITH_MESSAGE	tests/embed/src/doctestx.h	/^#define DOCTEST_REQUIRE_THROWS_WITH_MESSAGE(/;"	d
DOCTEST_REQUIRE_THROWS_WITH_MESSAGE	tests/embed/src/doctestx.h	/^#undef DOCTEST_REQUIRE_THROWS_WITH_MESSAGE$/;"	d
DOCTEST_REQUIRE_UNARY	lib/doctest/doctest.h	/^#define DOCTEST_REQUIRE_UNARY(/;"	d
DOCTEST_REQUIRE_UNARY	tests/embed/src/doctestx.h	/^#define DOCTEST_REQUIRE_UNARY(/;"	d
DOCTEST_REQUIRE_UNARY_FALSE	lib/doctest/doctest.h	/^#define DOCTEST_REQUIRE_UNARY_FALSE(/;"	d
DOCTEST_REQUIRE_UNARY_FALSE	tests/embed/src/doctestx.h	/^#define DOCTEST_REQUIRE_UNARY_FALSE(/;"	d
DOCTEST_SCENARIO	lib/doctest/doctest.h	/^#define DOCTEST_SCENARIO(/;"	d
DOCTEST_SCENARIO	tests/embed/src/doctestx.h	/^#define DOCTEST_SCENARIO(/;"	d
DOCTEST_SCENARIO_CLASS	lib/doctest/doctest.h	/^#define DOCTEST_SCENARIO_CLASS(/;"	d
DOCTEST_SCENARIO_CLASS	tests/embed/src/doctestx.h	/^#define DOCTEST_SCENARIO_CLASS(/;"	d
DOCTEST_SCENARIO_TEMPLATE	lib/doctest/doctest.h	/^#define DOCTEST_SCENARIO_TEMPLATE(/;"	d
DOCTEST_SCENARIO_TEMPLATE	tests/embed/src/doctestx.h	/^#define DOCTEST_SCENARIO_TEMPLATE(/;"	d
DOCTEST_SCENARIO_TEMPLATE_DEFINE	lib/doctest/doctest.h	/^#define DOCTEST_SCENARIO_TEMPLATE_DEFINE(/;"	d
DOCTEST_SCENARIO_TEMPLATE_DEFINE	tests/embed/src/doctestx.h	/^#define DOCTEST_SCENARIO_TEMPLATE_DEFINE(/;"	d
DOCTEST_SINGLE_HEADER	lib/doctest/doctest.h	/^#define DOCTEST_SINGLE_HEADER$/;"	d
DOCTEST_SINGLE_HEADER	tests/embed/src/doctestx.h	/^#define DOCTEST_SINGLE_HEADER$/;"	d
DOCTEST_SUBCASE	lib/doctest/doctest.h	/^#define DOCTEST_SUBCASE(/;"	d
DOCTEST_SUBCASE	tests/embed/src/doctestx.h	/^#define DOCTEST_SUBCASE(/;"	d
DOCTEST_SYMBOL_EXPORT	lib/doctest/doctest.h	/^#define DOCTEST_SYMBOL_EXPORT /;"	d
DOCTEST_SYMBOL_EXPORT	tests/embed/src/doctestx.h	/^#define DOCTEST_SYMBOL_EXPORT /;"	d
DOCTEST_SYMBOL_IMPORT	lib/doctest/doctest.h	/^#define DOCTEST_SYMBOL_IMPORT /;"	d
DOCTEST_SYMBOL_IMPORT	tests/embed/src/doctestx.h	/^#define DOCTEST_SYMBOL_IMPORT /;"	d
DOCTEST_TEST_CASE	lib/doctest/doctest.h	/^#define DOCTEST_TEST_CASE(/;"	d
DOCTEST_TEST_CASE	tests/embed/src/doctestx.h	/^#define DOCTEST_TEST_CASE(/;"	d
DOCTEST_TEST_CASE_CLASS	lib/doctest/doctest.h	/^#define DOCTEST_TEST_CASE_CLASS(/;"	d
DOCTEST_TEST_CASE_CLASS	tests/embed/src/doctestx.h	/^#define DOCTEST_TEST_CASE_CLASS(/;"	d
DOCTEST_TEST_CASE_FIXTURE	lib/doctest/doctest.h	/^#define DOCTEST_TEST_CASE_FIXTURE(/;"	d
DOCTEST_TEST_CASE_FIXTURE	tests/embed/src/doctestx.h	/^#define DOCTEST_TEST_CASE_FIXTURE(/;"	d
DOCTEST_TEST_CASE_TEMPLATE	lib/doctest/doctest.h	/^#define DOCTEST_TEST_CASE_TEMPLATE(/;"	d
DOCTEST_TEST_CASE_TEMPLATE	tests/embed/src/doctestx.h	/^#define DOCTEST_TEST_CASE_TEMPLATE(/;"	d
DOCTEST_TEST_CASE_TEMPLATE_APPLY	lib/doctest/doctest.h	/^#define DOCTEST_TEST_CASE_TEMPLATE_APPLY(/;"	d
DOCTEST_TEST_CASE_TEMPLATE_APPLY	tests/embed/src/doctestx.h	/^#define DOCTEST_TEST_CASE_TEMPLATE_APPLY(/;"	d
DOCTEST_TEST_CASE_TEMPLATE_DEFINE	lib/doctest/doctest.h	/^#define DOCTEST_TEST_CASE_TEMPLATE_DEFINE(/;"	d
DOCTEST_TEST_CASE_TEMPLATE_DEFINE	tests/embed/src/doctestx.h	/^#define DOCTEST_TEST_CASE_TEMPLATE_DEFINE(/;"	d
DOCTEST_TEST_CASE_TEMPLATE_DEFINE_IMPL	lib/doctest/doctest.h	/^#define DOCTEST_TEST_CASE_TEMPLATE_DEFINE_IMPL(/;"	d
DOCTEST_TEST_CASE_TEMPLATE_DEFINE_IMPL	tests/embed/src/doctestx.h	/^#define DOCTEST_TEST_CASE_TEMPLATE_DEFINE_IMPL(/;"	d
DOCTEST_TEST_CASE_TEMPLATE_IMPL	lib/doctest/doctest.h	/^#define DOCTEST_TEST_CASE_TEMPLATE_IMPL(/;"	d
DOCTEST_TEST_CASE_TEMPLATE_IMPL	tests/embed/src/doctestx.h	/^#define DOCTEST_TEST_CASE_TEMPLATE_IMPL(/;"	d
DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE	lib/doctest/doctest.h	/^#define DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE(/;"	d
DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE	tests/embed/src/doctestx.h	/^#define DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE(/;"	d
DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE_IMPL	lib/doctest/doctest.h	/^#define DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE_IMPL(/;"	d
DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE_IMPL	tests/embed/src/doctestx.h	/^#define DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE_IMPL(/;"	d
DOCTEST_TEST_CASE_TEMPLATE_INVOKE	lib/doctest/doctest.h	/^#define DOCTEST_TEST_CASE_TEMPLATE_INVOKE(/;"	d
DOCTEST_TEST_CASE_TEMPLATE_INVOKE	tests/embed/src/doctestx.h	/^#define DOCTEST_TEST_CASE_TEMPLATE_INVOKE(/;"	d
DOCTEST_TEST_SUITE	lib/doctest/doctest.h	/^#define DOCTEST_TEST_SUITE(/;"	d
DOCTEST_TEST_SUITE	tests/embed/src/doctestx.h	/^#define DOCTEST_TEST_SUITE(/;"	d
DOCTEST_TEST_SUITE_BEGIN	lib/doctest/doctest.h	/^#define DOCTEST_TEST_SUITE_BEGIN(/;"	d
DOCTEST_TEST_SUITE_BEGIN	tests/embed/src/doctestx.h	/^#define DOCTEST_TEST_SUITE_BEGIN(/;"	d
DOCTEST_TEST_SUITE_END	lib/doctest/doctest.h	/^#define DOCTEST_TEST_SUITE_END /;"	d
DOCTEST_TEST_SUITE_END	tests/embed/src/doctestx.h	/^#define DOCTEST_TEST_SUITE_END /;"	d
DOCTEST_TEST_SUITE_IMPL	lib/doctest/doctest.h	/^#define DOCTEST_TEST_SUITE_IMPL(/;"	d
DOCTEST_TEST_SUITE_IMPL	tests/embed/src/doctestx.h	/^#define DOCTEST_TEST_SUITE_IMPL(/;"	d
DOCTEST_THEN	lib/doctest/doctest.h	/^#define DOCTEST_THEN(/;"	d
DOCTEST_THEN	tests/embed/src/doctestx.h	/^#define DOCTEST_THEN(/;"	d
DOCTEST_THREAD_LOCAL	lib/doctest/doctest.h	/^#define DOCTEST_THREAD_LOCAL /;"	d
DOCTEST_THREAD_LOCAL	tests/embed/src/doctestx.h	/^#define DOCTEST_THREAD_LOCAL /;"	d
DOCTEST_TOSTR	lib/doctest/doctest.h	/^#define DOCTEST_TOSTR(/;"	d
DOCTEST_TOSTR	tests/embed/src/doctestx.h	/^#define DOCTEST_TOSTR(/;"	d
DOCTEST_TO_LVALUE	lib/doctest/doctest.h	/^#define DOCTEST_TO_LVALUE(/;"	d
DOCTEST_TO_LVALUE	tests/embed/src/doctestx.h	/^#define DOCTEST_TO_LVALUE(/;"	d
DOCTEST_TO_STRING_OVERLOAD	lib/doctest/doctest.h	/^#define DOCTEST_TO_STRING_OVERLOAD(/;"	d
DOCTEST_TO_STRING_OVERLOAD	tests/embed/src/doctestx.h	/^#define DOCTEST_TO_STRING_OVERLOAD(/;"	d
DOCTEST_TYPE_TO_STRING	lib/doctest/doctest.h	/^#define DOCTEST_TYPE_TO_STRING(/;"	d
DOCTEST_TYPE_TO_STRING	tests/embed/src/doctestx.h	/^#define DOCTEST_TYPE_TO_STRING(/;"	d
DOCTEST_TYPE_TO_STRING_IMPL	lib/doctest/doctest.h	/^#define DOCTEST_TYPE_TO_STRING_IMPL(/;"	d
DOCTEST_TYPE_TO_STRING_IMPL	tests/embed/src/doctestx.h	/^#define DOCTEST_TYPE_TO_STRING_IMPL(/;"	d
DOCTEST_UNARY_ASSERT	lib/doctest/doctest.h	/^#define DOCTEST_UNARY_ASSERT(/;"	d
DOCTEST_UNARY_ASSERT	tests/embed/src/doctestx.h	/^#define DOCTEST_UNARY_ASSERT(/;"	d
DOCTEST_UNUSED	lib/doctest/doctest.h	/^#define DOCTEST_UNUSED$/;"	d
DOCTEST_UNUSED	tests/embed/src/doctestx.h	/^#define DOCTEST_UNUSED$/;"	d
DOCTEST_VERSION	lib/doctest/doctest.h	/^#define DOCTEST_VERSION /;"	d
DOCTEST_VERSION	tests/embed/src/doctestx.h	/^#define DOCTEST_VERSION /;"	d
DOCTEST_VERSION_MAJOR	lib/doctest/doctest.h	/^#define DOCTEST_VERSION_MAJOR /;"	d
DOCTEST_VERSION_MAJOR	tests/embed/src/doctestx.h	/^#define DOCTEST_VERSION_MAJOR /;"	d
DOCTEST_VERSION_MINOR	lib/doctest/doctest.h	/^#define DOCTEST_VERSION_MINOR /;"	d
DOCTEST_VERSION_MINOR	tests/embed/src/doctestx.h	/^#define DOCTEST_VERSION_MINOR /;"	d
DOCTEST_VERSION_PATCH	lib/doctest/doctest.h	/^#define DOCTEST_VERSION_PATCH /;"	d
DOCTEST_VERSION_PATCH	tests/embed/src/doctestx.h	/^#define DOCTEST_VERSION_PATCH /;"	d
DOCTEST_VERSION_STR	lib/doctest/doctest.h	/^#define DOCTEST_VERSION_STR /;"	d
DOCTEST_VERSION_STR	tests/embed/src/doctestx.h	/^#define DOCTEST_VERSION_STR /;"	d
DOCTEST_WARN	lib/doctest/doctest.h	/^#define DOCTEST_WARN(/;"	d
DOCTEST_WARN	tests/embed/src/doctestx.h	/^#define DOCTEST_WARN(/;"	d
DOCTEST_WARN_EQ	lib/doctest/doctest.h	/^#define DOCTEST_WARN_EQ(/;"	d
DOCTEST_WARN_EQ	tests/embed/src/doctestx.h	/^#define DOCTEST_WARN_EQ(/;"	d
DOCTEST_WARN_FALSE	lib/doctest/doctest.h	/^#define DOCTEST_WARN_FALSE(/;"	d
DOCTEST_WARN_FALSE	tests/embed/src/doctestx.h	/^#define DOCTEST_WARN_FALSE(/;"	d
DOCTEST_WARN_FALSE_MESSAGE	lib/doctest/doctest.h	/^#define DOCTEST_WARN_FALSE_MESSAGE(/;"	d
DOCTEST_WARN_FALSE_MESSAGE	tests/embed/src/doctestx.h	/^#define DOCTEST_WARN_FALSE_MESSAGE(/;"	d
DOCTEST_WARN_GE	lib/doctest/doctest.h	/^#define DOCTEST_WARN_GE(/;"	d
DOCTEST_WARN_GE	tests/embed/src/doctestx.h	/^#define DOCTEST_WARN_GE(/;"	d
DOCTEST_WARN_GT	lib/doctest/doctest.h	/^#define DOCTEST_WARN_GT(/;"	d
DOCTEST_WARN_GT	tests/embed/src/doctestx.h	/^#define DOCTEST_WARN_GT(/;"	d
DOCTEST_WARN_LE	lib/doctest/doctest.h	/^#define DOCTEST_WARN_LE(/;"	d
DOCTEST_WARN_LE	tests/embed/src/doctestx.h	/^#define DOCTEST_WARN_LE(/;"	d
DOCTEST_WARN_LT	lib/doctest/doctest.h	/^#define DOCTEST_WARN_LT(/;"	d
DOCTEST_WARN_LT	tests/embed/src/doctestx.h	/^#define DOCTEST_WARN_LT(/;"	d
DOCTEST_WARN_MESSAGE	lib/doctest/doctest.h	/^#define DOCTEST_WARN_MESSAGE(/;"	d
DOCTEST_WARN_MESSAGE	tests/embed/src/doctestx.h	/^#define DOCTEST_WARN_MESSAGE(/;"	d
DOCTEST_WARN_NE	lib/doctest/doctest.h	/^#define DOCTEST_WARN_NE(/;"	d
DOCTEST_WARN_NE	tests/embed/src/doctestx.h	/^#define DOCTEST_WARN_NE(/;"	d
DOCTEST_WARN_NOTHROW	lib/doctest/doctest.h	/^#define DOCTEST_WARN_NOTHROW(/;"	d
DOCTEST_WARN_NOTHROW	lib/doctest/doctest.h	/^#undef DOCTEST_WARN_NOTHROW$/;"	d
DOCTEST_WARN_NOTHROW	tests/embed/src/doctestx.h	/^#define DOCTEST_WARN_NOTHROW(/;"	d
DOCTEST_WARN_NOTHROW	tests/embed/src/doctestx.h	/^#undef DOCTEST_WARN_NOTHROW$/;"	d
DOCTEST_WARN_NOTHROW_MESSAGE	lib/doctest/doctest.h	/^#define DOCTEST_WARN_NOTHROW_MESSAGE(/;"	d
DOCTEST_WARN_NOTHROW_MESSAGE	lib/doctest/doctest.h	/^#undef DOCTEST_WARN_NOTHROW_MESSAGE$/;"	d
DOCTEST_WARN_NOTHROW_MESSAGE	tests/embed/src/doctestx.h	/^#define DOCTEST_WARN_NOTHROW_MESSAGE(/;"	d
DOCTEST_WARN_NOTHROW_MESSAGE	tests/embed/src/doctestx.h	/^#undef DOCTEST_WARN_NOTHROW_MESSAGE$/;"	d
DOCTEST_WARN_THROWS	lib/doctest/doctest.h	/^#define DOCTEST_WARN_THROWS(/;"	d
DOCTEST_WARN_THROWS	lib/doctest/doctest.h	/^#undef DOCTEST_WARN_THROWS$/;"	d
DOCTEST_WARN_THROWS	tests/embed/src/doctestx.h	/^#define DOCTEST_WARN_THROWS(/;"	d
DOCTEST_WARN_THROWS	tests/embed/src/doctestx.h	/^#undef DOCTEST_WARN_THROWS$/;"	d
DOCTEST_WARN_THROWS_AS	lib/doctest/doctest.h	/^#define DOCTEST_WARN_THROWS_AS(/;"	d
DOCTEST_WARN_THROWS_AS	lib/doctest/doctest.h	/^#undef DOCTEST_WARN_THROWS_AS$/;"	d
DOCTEST_WARN_THROWS_AS	tests/embed/src/doctestx.h	/^#define DOCTEST_WARN_THROWS_AS(/;"	d
DOCTEST_WARN_THROWS_AS	tests/embed/src/doctestx.h	/^#undef DOCTEST_WARN_THROWS_AS$/;"	d
DOCTEST_WARN_THROWS_AS_MESSAGE	lib/doctest/doctest.h	/^#define DOCTEST_WARN_THROWS_AS_MESSAGE(/;"	d
DOCTEST_WARN_THROWS_AS_MESSAGE	lib/doctest/doctest.h	/^#undef DOCTEST_WARN_THROWS_AS_MESSAGE$/;"	d
DOCTEST_WARN_THROWS_AS_MESSAGE	tests/embed/src/doctestx.h	/^#define DOCTEST_WARN_THROWS_AS_MESSAGE(/;"	d
DOCTEST_WARN_THROWS_AS_MESSAGE	tests/embed/src/doctestx.h	/^#undef DOCTEST_WARN_THROWS_AS_MESSAGE$/;"	d
DOCTEST_WARN_THROWS_MESSAGE	lib/doctest/doctest.h	/^#define DOCTEST_WARN_THROWS_MESSAGE(/;"	d
DOCTEST_WARN_THROWS_MESSAGE	lib/doctest/doctest.h	/^#undef DOCTEST_WARN_THROWS_MESSAGE$/;"	d
DOCTEST_WARN_THROWS_MESSAGE	tests/embed/src/doctestx.h	/^#define DOCTEST_WARN_THROWS_MESSAGE(/;"	d
DOCTEST_WARN_THROWS_MESSAGE	tests/embed/src/doctestx.h	/^#undef DOCTEST_WARN_THROWS_MESSAGE$/;"	d
DOCTEST_WARN_THROWS_WITH	lib/doctest/doctest.h	/^#define DOCTEST_WARN_THROWS_WITH(/;"	d
DOCTEST_WARN_THROWS_WITH	lib/doctest/doctest.h	/^#undef DOCTEST_WARN_THROWS_WITH$/;"	d
DOCTEST_WARN_THROWS_WITH	tests/embed/src/doctestx.h	/^#define DOCTEST_WARN_THROWS_WITH(/;"	d
DOCTEST_WARN_THROWS_WITH	tests/embed/src/doctestx.h	/^#undef DOCTEST_WARN_THROWS_WITH$/;"	d
DOCTEST_WARN_THROWS_WITH_AS	lib/doctest/doctest.h	/^#define DOCTEST_WARN_THROWS_WITH_AS(/;"	d
DOCTEST_WARN_THROWS_WITH_AS	lib/doctest/doctest.h	/^#undef DOCTEST_WARN_THROWS_WITH_AS$/;"	d
DOCTEST_WARN_THROWS_WITH_AS	tests/embed/src/doctestx.h	/^#define DOCTEST_WARN_THROWS_WITH_AS(/;"	d
DOCTEST_WARN_THROWS_WITH_AS	tests/embed/src/doctestx.h	/^#undef DOCTEST_WARN_THROWS_WITH_AS$/;"	d
DOCTEST_WARN_THROWS_WITH_AS_MESSAGE	lib/doctest/doctest.h	/^#define DOCTEST_WARN_THROWS_WITH_AS_MESSAGE(/;"	d
DOCTEST_WARN_THROWS_WITH_AS_MESSAGE	lib/doctest/doctest.h	/^#undef DOCTEST_WARN_THROWS_WITH_AS_MESSAGE$/;"	d
DOCTEST_WARN_THROWS_WITH_AS_MESSAGE	tests/embed/src/doctestx.h	/^#define DOCTEST_WARN_THROWS_WITH_AS_MESSAGE(/;"	d
DOCTEST_WARN_THROWS_WITH_AS_MESSAGE	tests/embed/src/doctestx.h	/^#undef DOCTEST_WARN_THROWS_WITH_AS_MESSAGE$/;"	d
DOCTEST_WARN_THROWS_WITH_MESSAGE	lib/doctest/doctest.h	/^#define DOCTEST_WARN_THROWS_WITH_MESSAGE(/;"	d
DOCTEST_WARN_THROWS_WITH_MESSAGE	lib/doctest/doctest.h	/^#undef DOCTEST_WARN_THROWS_WITH_MESSAGE$/;"	d
DOCTEST_WARN_THROWS_WITH_MESSAGE	tests/embed/src/doctestx.h	/^#define DOCTEST_WARN_THROWS_WITH_MESSAGE(/;"	d
DOCTEST_WARN_THROWS_WITH_MESSAGE	tests/embed/src/doctestx.h	/^#undef DOCTEST_WARN_THROWS_WITH_MESSAGE$/;"	d
DOCTEST_WARN_UNARY	lib/doctest/doctest.h	/^#define DOCTEST_WARN_UNARY(/;"	d
DOCTEST_WARN_UNARY	tests/embed/src/doctestx.h	/^#define DOCTEST_WARN_UNARY(/;"	d
DOCTEST_WARN_UNARY_FALSE	lib/doctest/doctest.h	/^#define DOCTEST_WARN_UNARY_FALSE(/;"	d
DOCTEST_WARN_UNARY_FALSE	tests/embed/src/doctestx.h	/^#define DOCTEST_WARN_UNARY_FALSE(/;"	d
DOCTEST_WHEN	lib/doctest/doctest.h	/^#define DOCTEST_WHEN(/;"	d
DOCTEST_WHEN	tests/embed/src/doctestx.h	/^#define DOCTEST_WHEN(/;"	d
DOCTEST_WRAP_IN_TRY	lib/doctest/doctest.h	/^#define DOCTEST_WRAP_IN_TRY(/;"	d
DOCTEST_WRAP_IN_TRY	tests/embed/src/doctestx.h	/^#define DOCTEST_WRAP_IN_TRY(/;"	d
DR	lib/arch-stm32/uart-f1.h	/^    enum { SR=0x00,DR=0x04,BRR=0x08,CR1=0x0C,CR3=0x14 };$/;"	e	enum:Uart::__anon12
DR	lib/arch-stm32/uart-f4.h	/^    enum { SR=0x00,DR=0x04,BRR=0x08,CR1=0x0C,CR3=0x14 };$/;"	e	enum:Uart::__anon20
DR	lib/hall-stm32/stm32l4.cpp	/^        enum { TR=0x00,DR=0x04,CR=0x08,ISR=0x0C,WPR=0x24,BKPR=0x50 };$/;"	e	enum:hall::rtc::__anon5	file:
DT_CHECK	lib/doctest/doctest.h	/^        DT_CHECK   = is_normal | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK	tests/embed/src/doctestx.h	/^        DT_CHECK   = is_normal | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_EQ	lib/doctest/doctest.h	/^        DT_CHECK_EQ   = is_normal | is_eq | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_EQ	tests/embed/src/doctestx.h	/^        DT_CHECK_EQ   = is_normal | is_eq | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_FALSE	lib/doctest/doctest.h	/^        DT_CHECK_FALSE   = is_normal | is_false | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_FALSE	tests/embed/src/doctestx.h	/^        DT_CHECK_FALSE   = is_normal | is_false | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_GE	lib/doctest/doctest.h	/^        DT_CHECK_GE   = is_normal | is_ge | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_GE	tests/embed/src/doctestx.h	/^        DT_CHECK_GE   = is_normal | is_ge | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_GT	lib/doctest/doctest.h	/^        DT_CHECK_GT   = is_normal | is_gt | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_GT	tests/embed/src/doctestx.h	/^        DT_CHECK_GT   = is_normal | is_gt | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_LE	lib/doctest/doctest.h	/^        DT_CHECK_LE   = is_normal | is_le | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_LE	tests/embed/src/doctestx.h	/^        DT_CHECK_LE   = is_normal | is_le | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_LT	lib/doctest/doctest.h	/^        DT_CHECK_LT   = is_normal | is_lt | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_LT	tests/embed/src/doctestx.h	/^        DT_CHECK_LT   = is_normal | is_lt | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_NE	lib/doctest/doctest.h	/^        DT_CHECK_NE   = is_normal | is_ne | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_NE	tests/embed/src/doctestx.h	/^        DT_CHECK_NE   = is_normal | is_ne | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_NOTHROW	lib/doctest/doctest.h	/^        DT_CHECK_NOTHROW   = is_nothrow | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_NOTHROW	tests/embed/src/doctestx.h	/^        DT_CHECK_NOTHROW   = is_nothrow | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_THROWS	lib/doctest/doctest.h	/^        DT_CHECK_THROWS   = is_throws | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_THROWS	tests/embed/src/doctestx.h	/^        DT_CHECK_THROWS   = is_throws | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_THROWS_AS	lib/doctest/doctest.h	/^        DT_CHECK_THROWS_AS   = is_throws_as | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_THROWS_AS	tests/embed/src/doctestx.h	/^        DT_CHECK_THROWS_AS   = is_throws_as | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_THROWS_WITH	lib/doctest/doctest.h	/^        DT_CHECK_THROWS_WITH   = is_throws_with | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_THROWS_WITH	tests/embed/src/doctestx.h	/^        DT_CHECK_THROWS_WITH   = is_throws_with | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_THROWS_WITH_AS	lib/doctest/doctest.h	/^        DT_CHECK_THROWS_WITH_AS   = is_throws_with | is_throws_as | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_THROWS_WITH_AS	tests/embed/src/doctestx.h	/^        DT_CHECK_THROWS_WITH_AS   = is_throws_with | is_throws_as | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_UNARY	lib/doctest/doctest.h	/^        DT_CHECK_UNARY   = is_normal | is_unary | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_UNARY	tests/embed/src/doctestx.h	/^        DT_CHECK_UNARY   = is_normal | is_unary | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_UNARY_FALSE	lib/doctest/doctest.h	/^        DT_CHECK_UNARY_FALSE   = is_normal | is_false | is_unary | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_CHECK_UNARY_FALSE	tests/embed/src/doctestx.h	/^        DT_CHECK_UNARY_FALSE   = is_normal | is_false | is_unary | is_check,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE	lib/doctest/doctest.h	/^        DT_REQUIRE = is_normal | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE	tests/embed/src/doctestx.h	/^        DT_REQUIRE = is_normal | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_EQ	lib/doctest/doctest.h	/^        DT_REQUIRE_EQ = is_normal | is_eq | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_EQ	tests/embed/src/doctestx.h	/^        DT_REQUIRE_EQ = is_normal | is_eq | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_FALSE	lib/doctest/doctest.h	/^        DT_REQUIRE_FALSE = is_normal | is_false | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_FALSE	tests/embed/src/doctestx.h	/^        DT_REQUIRE_FALSE = is_normal | is_false | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_GE	lib/doctest/doctest.h	/^        DT_REQUIRE_GE = is_normal | is_ge | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_GE	tests/embed/src/doctestx.h	/^        DT_REQUIRE_GE = is_normal | is_ge | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_GT	lib/doctest/doctest.h	/^        DT_REQUIRE_GT = is_normal | is_gt | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_GT	tests/embed/src/doctestx.h	/^        DT_REQUIRE_GT = is_normal | is_gt | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_LE	lib/doctest/doctest.h	/^        DT_REQUIRE_LE = is_normal | is_le | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_LE	tests/embed/src/doctestx.h	/^        DT_REQUIRE_LE = is_normal | is_le | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_LT	lib/doctest/doctest.h	/^        DT_REQUIRE_LT = is_normal | is_lt | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_LT	tests/embed/src/doctestx.h	/^        DT_REQUIRE_LT = is_normal | is_lt | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_NE	lib/doctest/doctest.h	/^        DT_REQUIRE_NE = is_normal | is_ne | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_NE	tests/embed/src/doctestx.h	/^        DT_REQUIRE_NE = is_normal | is_ne | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_NOTHROW	lib/doctest/doctest.h	/^        DT_REQUIRE_NOTHROW = is_nothrow | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_NOTHROW	tests/embed/src/doctestx.h	/^        DT_REQUIRE_NOTHROW = is_nothrow | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_THROWS	lib/doctest/doctest.h	/^        DT_REQUIRE_THROWS = is_throws | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_THROWS	tests/embed/src/doctestx.h	/^        DT_REQUIRE_THROWS = is_throws | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_THROWS_AS	lib/doctest/doctest.h	/^        DT_REQUIRE_THROWS_AS = is_throws_as | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_THROWS_AS	tests/embed/src/doctestx.h	/^        DT_REQUIRE_THROWS_AS = is_throws_as | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_THROWS_WITH	lib/doctest/doctest.h	/^        DT_REQUIRE_THROWS_WITH = is_throws_with | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_THROWS_WITH	tests/embed/src/doctestx.h	/^        DT_REQUIRE_THROWS_WITH = is_throws_with | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_THROWS_WITH_AS	lib/doctest/doctest.h	/^        DT_REQUIRE_THROWS_WITH_AS = is_throws_with | is_throws_as | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_THROWS_WITH_AS	tests/embed/src/doctestx.h	/^        DT_REQUIRE_THROWS_WITH_AS = is_throws_with | is_throws_as | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_UNARY	lib/doctest/doctest.h	/^        DT_REQUIRE_UNARY = is_normal | is_unary | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_UNARY	tests/embed/src/doctestx.h	/^        DT_REQUIRE_UNARY = is_normal | is_unary | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_UNARY_FALSE	lib/doctest/doctest.h	/^        DT_REQUIRE_UNARY_FALSE = is_normal | is_false | is_unary | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_REQUIRE_UNARY_FALSE	tests/embed/src/doctestx.h	/^        DT_REQUIRE_UNARY_FALSE = is_normal | is_false | is_unary | is_require,$/;"	e	enum:doctest::assertType::Enum
DT_WARN	lib/doctest/doctest.h	/^        DT_WARN    = is_normal | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN	tests/embed/src/doctestx.h	/^        DT_WARN    = is_normal | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_EQ	lib/doctest/doctest.h	/^        DT_WARN_EQ    = is_normal | is_eq | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_EQ	tests/embed/src/doctestx.h	/^        DT_WARN_EQ    = is_normal | is_eq | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_FALSE	lib/doctest/doctest.h	/^        DT_WARN_FALSE    = is_normal | is_false | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_FALSE	tests/embed/src/doctestx.h	/^        DT_WARN_FALSE    = is_normal | is_false | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_GE	lib/doctest/doctest.h	/^        DT_WARN_GE    = is_normal | is_ge | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_GE	tests/embed/src/doctestx.h	/^        DT_WARN_GE    = is_normal | is_ge | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_GT	lib/doctest/doctest.h	/^        DT_WARN_GT    = is_normal | is_gt | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_GT	tests/embed/src/doctestx.h	/^        DT_WARN_GT    = is_normal | is_gt | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_LE	lib/doctest/doctest.h	/^        DT_WARN_LE    = is_normal | is_le | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_LE	tests/embed/src/doctestx.h	/^        DT_WARN_LE    = is_normal | is_le | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_LT	lib/doctest/doctest.h	/^        DT_WARN_LT    = is_normal | is_lt | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_LT	tests/embed/src/doctestx.h	/^        DT_WARN_LT    = is_normal | is_lt | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_NE	lib/doctest/doctest.h	/^        DT_WARN_NE    = is_normal | is_ne | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_NE	tests/embed/src/doctestx.h	/^        DT_WARN_NE    = is_normal | is_ne | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_NOTHROW	lib/doctest/doctest.h	/^        DT_WARN_NOTHROW    = is_nothrow | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_NOTHROW	tests/embed/src/doctestx.h	/^        DT_WARN_NOTHROW    = is_nothrow | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_THROWS	lib/doctest/doctest.h	/^        DT_WARN_THROWS    = is_throws | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_THROWS	tests/embed/src/doctestx.h	/^        DT_WARN_THROWS    = is_throws | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_THROWS_AS	lib/doctest/doctest.h	/^        DT_WARN_THROWS_AS    = is_throws_as | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_THROWS_AS	tests/embed/src/doctestx.h	/^        DT_WARN_THROWS_AS    = is_throws_as | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_THROWS_WITH	lib/doctest/doctest.h	/^        DT_WARN_THROWS_WITH    = is_throws_with | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_THROWS_WITH	tests/embed/src/doctestx.h	/^        DT_WARN_THROWS_WITH    = is_throws_with | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_THROWS_WITH_AS	lib/doctest/doctest.h	/^        DT_WARN_THROWS_WITH_AS    = is_throws_with | is_throws_as | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_THROWS_WITH_AS	tests/embed/src/doctestx.h	/^        DT_WARN_THROWS_WITH_AS    = is_throws_with | is_throws_as | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_UNARY	lib/doctest/doctest.h	/^        DT_WARN_UNARY    = is_normal | is_unary | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_UNARY	tests/embed/src/doctestx.h	/^        DT_WARN_UNARY    = is_normal | is_unary | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_UNARY_FALSE	lib/doctest/doctest.h	/^        DT_WARN_UNARY_FALSE    = is_normal | is_false | is_unary | is_warn,$/;"	e	enum:doctest::assertType::Enum
DT_WARN_UNARY_FALSE	tests/embed/src/doctestx.h	/^        DT_WARN_UNARY_FALSE    = is_normal | is_false | is_unary | is_warn,$/;"	e	enum:doctest::assertType::Enum
DWT	lib/arch-stm32/jee-stm32.h	/^    namespace DWT {$/;"	n	namespace:jeeh
DateTime	lib/hall-stm32/hall.h	/^        auto get () -> DateTime;$/;"	m	namespace:hall::rtc
DateTime	lib/hall-stm32/hall.h	/^        struct DateTime { uint8_t yr, mo, dy, hh, mm, ss; };$/;"	s	namespace:hall::rtc
DateTime	lib/mcu/mcu.h	/^        auto get () -> DateTime;$/;"	m	namespace:mcu::rtc
DateTime	lib/mcu/mcu.h	/^        struct DateTime { uint8_t yr, mo, dy, hh, mm, ss; };$/;"	s	namespace:mcu::rtc
DeleteDeref	lib/pyvm/pyvm.cpp	/^    DeleteDeref            = 0x29,$/;"	e	enum:uint8_t	file:
DeleteFast	lib/pyvm/pyvm.cpp	/^    DeleteFast             = 0x28,$/;"	e	enum:uint8_t	file:
DeleteGlobal	lib/pyvm/pyvm.cpp	/^    DeleteGlobal           = 0x1A,$/;"	e	enum:uint8_t	file:
DeleteName	lib/pyvm/pyvm.cpp	/^    DeleteName             = 0x19,$/;"	e	enum:uint8_t	file:
DevInfo	lib/arch-stm32/prelude.h	/^struct DevInfo {$/;"	s	struct:IrqVec
DevInfo	lib/mcu/prelude.h	/^struct DevInfo {$/;"	s	struct:IrqVec
Device	lib/arch-stm32/arch.h	/^        Device () { regHandler(); }$/;"	f	struct:arch::Device
Device	lib/arch-stm32/arch.h	/^    struct Device : Event {$/;"	s	namespace:arch
Device	lib/boss/boss.h	/^    struct Device {$/;"	s	namespace:boss::boss
Device	lib/hall-stm32/hall.cpp	/^Device::Device () {$/;"	f	class:Device
Device	lib/mcu/mcu.h	/^    struct Device {$/;"	s	namespace:mcu
Dict	lib/monty/monty.h	/^        constexpr Dict (Object const* ch =nullptr) : _chain (ch) {}$/;"	f	struct:monty::Dict
Dict	lib/monty/monty.h	/^    struct Dict : Set {$/;"	s	namespace:monty
Dict	lib/monty/type.cpp	/^Dict::Dict (Value seq) {$/;"	f	class:Dict
DictView	lib/monty/type.cpp	/^    DictView (Dict const& dict, int vtype) : _dict (dict), _vtype (vtype) {}$/;"	f	struct:DictView
DictView	lib/monty/type.cpp	/^struct DictView : Object {$/;"	s	file:
DmaInfo	lib/arch-stm32/prelude.h	/^struct DmaInfo { uint32_t base; uint8_t streams [8]; };$/;"	s	struct:IrqVec
DmaInfo	lib/hall-stm32/stm32l4-uart.cpp	/^struct DmaInfo { uint32_t base; uint8_t streams [8]; };$/;"	s	file:
DmaInfo	lib/mcu/prelude.h	/^struct DmaInfo { uint32_t base; uint8_t streams [8]; };$/;"	s	struct:IrqVec
DupTop	lib/pyvm/pyvm.cpp	/^    DupTop                 = 0x57,$/;"	e	enum:uint8_t	file:
DupTopTwo	lib/pyvm/pyvm.cpp	/^    DupTopTwo              = 0x58,$/;"	e	enum:uint8_t	file:
E	lib/monty/monty.h	/^    enum class E : uint8_t { \/\/ parsed by codegen.py, see builtin.cpp$/;"	c	namespace:monty
END	lib/monty/parser.h	/^            IHEX, SKIP, END, STR, ESC, STRX, STRU, NUM, WORD, ARGS };$/;"	m	struct:Parser	typeref:enum:Parser::
EOFError	lib/monty/monty.h	/^        EOFError,            \/\/ Exception$/;"	m	class:monty::E
ESC	lib/monty/parser.h	/^            IHEX, SKIP, END, STR, ESC, STRX, STRU, NUM, WORD, ARGS };$/;"	m	struct:Parser	typeref:enum:Parser::
EXCEPTIONS	src/codegen.py	/^def EXCEPTIONS(block):$/;"	f
EXCEPTION_EMIT	src/codegen.py	/^def EXCEPTION_EMIT(block, sel='h'):$/;"	f
EXC_STEP	lib/pyvm/pyvm.cpp	/^    static constexpr int EXC_STEP = 3; \/\/ use 3 entries per exception$/;"	m	struct:PyVM	file:
EXTI	lib/arch-stm32/prelude.h	/^constexpr auto EXTI          = 0x40010400;  \/\/ EXTI$/;"	v
EXTI	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40010400> EXTI;$/;"	m	namespace:hall::dev
EXTI	lib/mcu/prelude.h	/^constexpr auto EXTI          = 0x40010400;  \/\/ EXTI$/;"	v
EXTI0	lib/arch-stm32/prelude.h	/^    EXTI0                 =   6,  \/\/ EXTI$/;"	m	struct:IrqVec
EXTI0	lib/mcu/prelude.h	/^    EXTI0                 =   6,  \/\/ EXTI$/;"	m	struct:IrqVec
EXTI1	lib/arch-stm32/prelude.h	/^    EXTI1                 =   7,  \/\/ EXTI$/;"	m	struct:IrqVec
EXTI1	lib/mcu/prelude.h	/^    EXTI1                 =   7,  \/\/ EXTI$/;"	m	struct:IrqVec
EXTI15_10	lib/arch-stm32/prelude.h	/^    EXTI15_10             =  40,  \/\/ EXTI$/;"	m	struct:IrqVec
EXTI15_10	lib/mcu/prelude.h	/^    EXTI15_10             =  40,  \/\/ EXTI$/;"	m	struct:IrqVec
EXTI2	lib/arch-stm32/prelude.h	/^    EXTI2                 =   8,  \/\/ EXTI$/;"	m	struct:IrqVec
EXTI2	lib/mcu/prelude.h	/^    EXTI2                 =   8,  \/\/ EXTI$/;"	m	struct:IrqVec
EXTI3	lib/arch-stm32/prelude.h	/^    EXTI3                 =   9,  \/\/ EXTI$/;"	m	struct:IrqVec
EXTI3	lib/mcu/prelude.h	/^    EXTI3                 =   9,  \/\/ EXTI$/;"	m	struct:IrqVec
EXTI4	lib/arch-stm32/prelude.h	/^    EXTI4                 =  10,  \/\/ EXTI$/;"	m	struct:IrqVec
EXTI4	lib/mcu/prelude.h	/^    EXTI4                 =  10,  \/\/ EXTI$/;"	m	struct:IrqVec
EXTI9_5	lib/arch-stm32/prelude.h	/^    EXTI9_5               =  23,  \/\/ EXTI$/;"	m	struct:IrqVec
EXTI9_5	lib/mcu/prelude.h	/^    EXTI9_5               =  23,  \/\/ EXTI$/;"	m	struct:IrqVec
EndFinally	lib/pyvm/pyvm.cpp	/^    EndFinally             = 0x5D,$/;"	e	enum:uint8_t	file:
Enum	lib/doctest/doctest.h	/^    enum Enum$/;"	g	namespace:doctest::Color
Enum	lib/doctest/doctest.h	/^    enum Enum$/;"	g	namespace:doctest::assertType
Enum	tests/embed/src/doctestx.h	/^    enum Enum$/;"	g	namespace:doctest::Color
Enum	tests/embed/src/doctestx.h	/^    enum Enum$/;"	g	namespace:doctest::assertType
Err	lib/monty/parser.h	/^    enum State : uint8_t { Ini, Cmd, Hex, Obj, Err,$/;"	m	struct:Parser	typeref:enum:Parser::
Event	lib/monty/monty.h	/^    struct Event : Object {$/;"	s	namespace:monty
Exception	lib/monty/builtin.cpp	/^Exception::Exception (E code, ArgVec const& args) : Tuple (args), _code (code) {$/;"	f	class:Exception
Exception	lib/monty/monty.h	/^        Exception,           \/\/ BaseException$/;"	m	class:monty::E
Exception	lib/monty/monty.h	/^    struct Exception : Tuple {$/;"	s	namespace:monty
F1	lib/hall-stm32/hall.h	/^    enum struct STM { F1, F3, F4, F7, G0, H7, L0, L4 };$/;"	m	struct:hall::STM
F3	lib/hall-stm32/hall.h	/^    enum struct STM { F1, F3, F4, F7, G0, H7, L0, L4 };$/;"	m	struct:hall::STM
F4	lib/hall-stm32/hall.h	/^    enum struct STM { F1, F3, F4, F7, G0, H7, L0, L4 };$/;"	m	struct:hall::STM
F7	lib/hall-stm32/hall.h	/^    enum struct STM { F1, F3, F4, F7, G0, H7, L0, L4 };$/;"	m	struct:hall::STM
FAIL	lib/doctest/doctest.h	/^#define FAIL(/;"	d
FAIL	tests/embed/src/doctestx.h	/^#define FAIL(/;"	d
FAIL_CHECK	lib/doctest/doctest.h	/^#define FAIL_CHECK(/;"	d
FAIL_CHECK	tests/embed/src/doctestx.h	/^#define FAIL_CHECK(/;"	d
FAMILY	lib/hall-stm32/hall.h	/^    constexpr auto FAMILY = STM::F1;$/;"	m	namespace:hall
FAMILY	lib/hall-stm32/hall.h	/^    constexpr auto FAMILY = STM::F4;$/;"	m	namespace:hall
FAMILY	lib/hall-stm32/hall.h	/^    constexpr auto FAMILY = STM::F7;$/;"	m	namespace:hall
FAMILY	lib/hall-stm32/hall.h	/^    constexpr auto FAMILY = STM::L0;$/;"	m	namespace:hall
FAMILY	lib/hall-stm32/hall.h	/^    constexpr auto FAMILY = STM::L4;$/;"	m	namespace:hall
FAMILY	lib/mcu/mcu.h	/^    constexpr auto FAMILY = STM_F4;$/;"	m	namespace:mcu
FAMILY	lib/mcu/mcu.h	/^    constexpr auto FAMILY = STM_F7;$/;"	m	namespace:mcu
FAMILY	lib/mcu/mcu.h	/^    constexpr auto FAMILY = STM_L0;$/;"	m	namespace:mcu
FAMILY	lib/mcu/mcu.h	/^    constexpr auto FAMILY = STM_L4;$/;"	m	namespace:mcu
FAST_CHECK_EQ	lib/doctest/doctest.h	/^#define FAST_CHECK_EQ(/;"	d
FAST_CHECK_EQ	tests/embed/src/doctestx.h	/^#define FAST_CHECK_EQ(/;"	d
FAST_CHECK_GE	lib/doctest/doctest.h	/^#define FAST_CHECK_GE(/;"	d
FAST_CHECK_GE	tests/embed/src/doctestx.h	/^#define FAST_CHECK_GE(/;"	d
FAST_CHECK_GT	lib/doctest/doctest.h	/^#define FAST_CHECK_GT(/;"	d
FAST_CHECK_GT	tests/embed/src/doctestx.h	/^#define FAST_CHECK_GT(/;"	d
FAST_CHECK_LE	lib/doctest/doctest.h	/^#define FAST_CHECK_LE(/;"	d
FAST_CHECK_LE	tests/embed/src/doctestx.h	/^#define FAST_CHECK_LE(/;"	d
FAST_CHECK_LT	lib/doctest/doctest.h	/^#define FAST_CHECK_LT(/;"	d
FAST_CHECK_LT	tests/embed/src/doctestx.h	/^#define FAST_CHECK_LT(/;"	d
FAST_CHECK_NE	lib/doctest/doctest.h	/^#define FAST_CHECK_NE(/;"	d
FAST_CHECK_NE	tests/embed/src/doctestx.h	/^#define FAST_CHECK_NE(/;"	d
FAST_CHECK_UNARY	lib/doctest/doctest.h	/^#define FAST_CHECK_UNARY(/;"	d
FAST_CHECK_UNARY	tests/embed/src/doctestx.h	/^#define FAST_CHECK_UNARY(/;"	d
FAST_CHECK_UNARY_FALSE	lib/doctest/doctest.h	/^#define FAST_CHECK_UNARY_FALSE(/;"	d
FAST_CHECK_UNARY_FALSE	tests/embed/src/doctestx.h	/^#define FAST_CHECK_UNARY_FALSE(/;"	d
FAST_REQUIRE_EQ	lib/doctest/doctest.h	/^#define FAST_REQUIRE_EQ(/;"	d
FAST_REQUIRE_EQ	tests/embed/src/doctestx.h	/^#define FAST_REQUIRE_EQ(/;"	d
FAST_REQUIRE_GE	lib/doctest/doctest.h	/^#define FAST_REQUIRE_GE(/;"	d
FAST_REQUIRE_GE	tests/embed/src/doctestx.h	/^#define FAST_REQUIRE_GE(/;"	d
FAST_REQUIRE_GT	lib/doctest/doctest.h	/^#define FAST_REQUIRE_GT(/;"	d
FAST_REQUIRE_GT	tests/embed/src/doctestx.h	/^#define FAST_REQUIRE_GT(/;"	d
FAST_REQUIRE_LE	lib/doctest/doctest.h	/^#define FAST_REQUIRE_LE(/;"	d
FAST_REQUIRE_LE	tests/embed/src/doctestx.h	/^#define FAST_REQUIRE_LE(/;"	d
FAST_REQUIRE_LT	lib/doctest/doctest.h	/^#define FAST_REQUIRE_LT(/;"	d
FAST_REQUIRE_LT	tests/embed/src/doctestx.h	/^#define FAST_REQUIRE_LT(/;"	d
FAST_REQUIRE_NE	lib/doctest/doctest.h	/^#define FAST_REQUIRE_NE(/;"	d
FAST_REQUIRE_NE	tests/embed/src/doctestx.h	/^#define FAST_REQUIRE_NE(/;"	d
FAST_REQUIRE_UNARY	lib/doctest/doctest.h	/^#define FAST_REQUIRE_UNARY(/;"	d
FAST_REQUIRE_UNARY	tests/embed/src/doctestx.h	/^#define FAST_REQUIRE_UNARY(/;"	d
FAST_REQUIRE_UNARY_FALSE	lib/doctest/doctest.h	/^#define FAST_REQUIRE_UNARY_FALSE(/;"	d
FAST_REQUIRE_UNARY_FALSE	tests/embed/src/doctestx.h	/^#define FAST_REQUIRE_UNARY_FALSE(/;"	d
FAST_WARN_EQ	lib/doctest/doctest.h	/^#define FAST_WARN_EQ(/;"	d
FAST_WARN_EQ	tests/embed/src/doctestx.h	/^#define FAST_WARN_EQ(/;"	d
FAST_WARN_GE	lib/doctest/doctest.h	/^#define FAST_WARN_GE(/;"	d
FAST_WARN_GE	tests/embed/src/doctestx.h	/^#define FAST_WARN_GE(/;"	d
FAST_WARN_GT	lib/doctest/doctest.h	/^#define FAST_WARN_GT(/;"	d
FAST_WARN_GT	tests/embed/src/doctestx.h	/^#define FAST_WARN_GT(/;"	d
FAST_WARN_LE	lib/doctest/doctest.h	/^#define FAST_WARN_LE(/;"	d
FAST_WARN_LE	tests/embed/src/doctestx.h	/^#define FAST_WARN_LE(/;"	d
FAST_WARN_LT	lib/doctest/doctest.h	/^#define FAST_WARN_LT(/;"	d
FAST_WARN_LT	tests/embed/src/doctestx.h	/^#define FAST_WARN_LT(/;"	d
FAST_WARN_NE	lib/doctest/doctest.h	/^#define FAST_WARN_NE(/;"	d
FAST_WARN_NE	tests/embed/src/doctestx.h	/^#define FAST_WARN_NE(/;"	d
FAST_WARN_UNARY	lib/doctest/doctest.h	/^#define FAST_WARN_UNARY(/;"	d
FAST_WARN_UNARY	tests/embed/src/doctestx.h	/^#define FAST_WARN_UNARY(/;"	d
FAST_WARN_UNARY_FALSE	lib/doctest/doctest.h	/^#define FAST_WARN_UNARY_FALSE(/;"	d
FAST_WARN_UNARY_FALSE	tests/embed/src/doctestx.h	/^#define FAST_WARN_UNARY_FALSE(/;"	d
FIREWALL	lib/arch-stm32/prelude.h	/^constexpr auto FIREWALL      = 0x40011C00;  \/\/ FIREWALL$/;"	v
FIREWALL	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40011C00> FIREWALL;$/;"	m	namespace:hall::dev
FIREWALL	lib/mcu/prelude.h	/^constexpr auto FIREWALL      = 0x40011C00;  \/\/ FIREWALL$/;"	v
FLASH	lib/arch-stm32/prelude.h	/^    FLASH                 =   4,  \/\/ FLASH$/;"	m	struct:IrqVec
FLASH	lib/arch-stm32/prelude.h	/^constexpr auto FLASH         = 0x40022000;  \/\/ FLASH$/;"	v
FLASH	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40022000> FLASH;$/;"	m	namespace:hall::dev
FLASH	lib/mcu/prelude.h	/^    FLASH                 =   4,  \/\/ FLASH$/;"	m	struct:IrqVec
FLASH	lib/mcu/prelude.h	/^constexpr auto FLASH         = 0x40022000;  \/\/ FLASH$/;"	v
FPU	lib/arch-stm32/prelude.h	/^    FPU                   =  81,  \/\/ VREF$/;"	m	struct:IrqVec
FPU	lib/arch-stm32/prelude.h	/^constexpr auto FPU           = 0xE000EF34;  \/\/ FPU$/;"	v
FPU	lib/hall-stm32/hall.h	/^        constexpr Io32  <0xE000EF34> FPU;$/;"	m	namespace:hall::dev
FPU	lib/mcu/prelude.h	/^    FPU                   =  81,  \/\/ VREF$/;"	m	struct:IrqVec
FPU	lib/mcu/prelude.h	/^constexpr auto FPU           = 0xE000EF34;  \/\/ FPU$/;"	v
FPU_CPACR	lib/arch-stm32/prelude.h	/^constexpr auto FPU_CPACR     = 0xE000ED88;  \/\/ FPU$/;"	v
FPU_CPACR	lib/hall-stm32/hall.h	/^        constexpr Io32  <0xE000ED88> FPU_CPACR;$/;"	m	namespace:hall::dev
FPU_CPACR	lib/mcu/prelude.h	/^constexpr auto FPU_CPACR     = 0xE000ED88;  \/\/ FPU$/;"	v
Fiber	lib/boss/boss.h	/^    struct Fiber {$/;"	s	namespace:boss::boss
Fid_t	lib/boss/boss.h	/^        static auto create (void (*)(void*), void* =nullptr) -> Fid_t;$/;"	m	struct:boss::boss::Fiber
FinallyFlag	lib/pyvm/pyvm.cpp	/^    static constexpr auto FinallyFlag = 1U<<20;$/;"	m	struct:PyVM	file:
FinallyMask	lib/pyvm/pyvm.cpp	/^    static constexpr auto FinallyMask = FinallyFlag - 1;$/;"	m	struct:PyVM	file:
Flags	src/codegen.py	/^class Flags: # make all missing attributes return ""$/;"	c
Font	lib/graphics/twodee.h	/^        Font (uint8_t const* p) : glyphs (p) {$/;"	f	struct:twodee::Font
Font	lib/graphics/twodee.h	/^    struct Font {$/;"	s	namespace:twodee
ForIter	lib/pyvm/pyvm.cpp	/^    ForIter                = 0x4B,$/;"	e	enum:uint8_t	file:
Frame	lib/pyvm/pyvm.cpp	/^    struct Frame {$/;"	s	struct:PyVM	file:
Function	lib/monty/monty.h	/^        constexpr Function (Prim f) : _func (f) {}$/;"	f	struct:monty::Function
Function	lib/monty/monty.h	/^        constexpr Function (char const* d, Prim f) : _func (f), _desc (d) {}$/;"	f	struct:monty::Function
Function	lib/monty/monty.h	/^    struct Function : StaticObj {$/;"	s	namespace:monty
G0	lib/hall-stm32/hall.h	/^    enum struct STM { F1, F3, F4, F7, G0, H7, L0, L4 };$/;"	m	struct:hall::STM
GCStats	lib/monty/monty.h	/^    union GCStats {$/;"	u	namespace:monty
GCStats	tests/native/memTest.cpp	/^union GCStats {$/;"	u	file:
GIVEN	lib/doctest/doctest.h	/^#define GIVEN(/;"	d
GIVEN	tests/embed/src/doctestx.h	/^#define GIVEN(/;"	d
GPIOA	lib/arch-stm32/prelude.h	/^constexpr auto GPIOA         = 0x48000000;  \/\/ GPIO$/;"	v
GPIOA	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x48000000> GPIOA;$/;"	m	namespace:hall::dev
GPIOA	lib/mcu/prelude.h	/^constexpr auto GPIOA         = 0x48000000;  \/\/ GPIO$/;"	v
GPIOB	lib/arch-stm32/prelude.h	/^constexpr auto GPIOB         = 0x48000400;  \/\/ GPIO$/;"	v
GPIOB	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x48000400> GPIOB;$/;"	m	namespace:hall::dev
GPIOB	lib/mcu/prelude.h	/^constexpr auto GPIOB         = 0x48000400;  \/\/ GPIO$/;"	v
GPIOC	lib/arch-stm32/prelude.h	/^constexpr auto GPIOC         = 0x48000800;  \/\/ GPIO$/;"	v
GPIOC	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x48000800> GPIOC;$/;"	m	namespace:hall::dev
GPIOC	lib/mcu/prelude.h	/^constexpr auto GPIOC         = 0x48000800;  \/\/ GPIO$/;"	v
GPIOD	lib/arch-stm32/prelude.h	/^constexpr auto GPIOD         = 0x48000C00;  \/\/ GPIO$/;"	v
GPIOD	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x48000C00> GPIOD;$/;"	m	namespace:hall::dev
GPIOD	lib/mcu/prelude.h	/^constexpr auto GPIOD         = 0x48000C00;  \/\/ GPIO$/;"	v
GPIOE	lib/arch-stm32/prelude.h	/^constexpr auto GPIOE         = 0x48001000;  \/\/ GPIO$/;"	v
GPIOE	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x48001000> GPIOE;$/;"	m	namespace:hall::dev
GPIOE	lib/mcu/prelude.h	/^constexpr auto GPIOE         = 0x48001000;  \/\/ GPIO$/;"	v
GPIOH	lib/arch-stm32/prelude.h	/^constexpr auto GPIOH         = 0x48001C00;  \/\/ GPIO$/;"	v
GPIOH	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x48001C00> GPIOH;$/;"	m	namespace:hall::dev
GPIOH	lib/mcu/prelude.h	/^constexpr auto GPIOH         = 0x48001C00;  \/\/ GPIO$/;"	v
GetIter	lib/pyvm/pyvm.cpp	/^    GetIter                = 0x5E,$/;"	e	enum:uint8_t	file:
GetIterStack	lib/pyvm/pyvm.cpp	/^    GetIterStack           = 0x5F,$/;"	e	enum:uint8_t	file:
Glyph	lib/graphics/twodee.h	/^        Glyph (Font const& font) : font (font) {}$/;"	f	struct:twodee::Glyph
Glyph	lib/graphics/twodee.h	/^    struct Glyph : Rect {$/;"	s	namespace:twodee
Green	lib/doctest/doctest.h	/^        Green,$/;"	e	enum:doctest::Color::Enum
Green	tests/embed/src/doctestx.h	/^        Green,$/;"	e	enum:doctest::Color::Enum
Grey	lib/doctest/doctest.h	/^        Grey,$/;"	e	enum:doctest::Color::Enum
Grey	tests/embed/src/doctestx.h	/^        Grey,$/;"	e	enum:doctest::Color::Enum
H7	lib/hall-stm32/hall.h	/^    enum struct STM { F1, F3, F4, F7, G0, H7, L0, L4 };$/;"	m	struct:hall::STM
HAS_ARRAY	lib/extend/extend.h	/^#define HAS_ARRAY /;"	d
HAS_MRFS	lib/mrfs/mrfs.h	/^#define HAS_MRFS /;"	d
HAS_PYVM	lib/pyvm/pyvm.h	/^#define HAS_PYVM /;"	d
HardFault_Handler	lib/arch-stm32/arch.cpp	/^extern "C" void HardFault_Handler  () { panic("hard fault"); };$/;"	f
HardFault_Handler	lib/mcu/mcu.cpp	/^void HardFault_Handler () {$/;"	f	namespace:mcu
Hex	lib/monty/parser.h	/^    enum State : uint8_t { Ini, Cmd, Hex, Obj, Err,$/;"	m	struct:Parser	typeref:enum:Parser::
HexSerial	lib/arch-stm32/arch.cpp	/^struct HexSerial : LineSerial {$/;"	s	file:
I2C1	lib/arch-stm32/prelude.h	/^constexpr auto I2C1          = 0x40005400;  \/\/ I2C$/;"	v
I2C1	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40005400> I2C1;$/;"	m	namespace:hall::dev
I2C1	lib/mcu/prelude.h	/^constexpr auto I2C1          = 0x40005400;  \/\/ I2C$/;"	v
I2C1_ER	lib/arch-stm32/prelude.h	/^    I2C1_ER               =  32,  \/\/ I2C$/;"	m	struct:IrqVec
I2C1_ER	lib/mcu/prelude.h	/^    I2C1_ER               =  32,  \/\/ I2C$/;"	m	struct:IrqVec
I2C1_EV	lib/arch-stm32/prelude.h	/^    I2C1_EV               =  31,  \/\/ I2C$/;"	m	struct:IrqVec
I2C1_EV	lib/mcu/prelude.h	/^    I2C1_EV               =  31,  \/\/ I2C$/;"	m	struct:IrqVec
I2C2	lib/arch-stm32/prelude.h	/^constexpr auto I2C2          = 0x40005800;  \/\/ I2C$/;"	v
I2C2	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40005800> I2C2;$/;"	m	namespace:hall::dev
I2C2	lib/mcu/prelude.h	/^constexpr auto I2C2          = 0x40005800;  \/\/ I2C$/;"	v
I2C2_ER	lib/arch-stm32/prelude.h	/^    I2C2_ER               =  34,  \/\/ I2C$/;"	m	struct:IrqVec
I2C2_ER	lib/mcu/prelude.h	/^    I2C2_ER               =  34,  \/\/ I2C$/;"	m	struct:IrqVec
I2C2_EV	lib/arch-stm32/prelude.h	/^    I2C2_EV               =  33,  \/\/ I2C$/;"	m	struct:IrqVec
I2C2_EV	lib/mcu/prelude.h	/^    I2C2_EV               =  33,  \/\/ I2C$/;"	m	struct:IrqVec
I2C3	lib/arch-stm32/prelude.h	/^constexpr auto I2C3          = 0x40005C00;  \/\/ I2C$/;"	v
I2C3	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40005C00> I2C3;$/;"	m	namespace:hall::dev
I2C3	lib/mcu/prelude.h	/^constexpr auto I2C3          = 0x40005C00;  \/\/ I2C$/;"	v
I2C3_ER	lib/arch-stm32/prelude.h	/^    I2C3_ER               =  73,  \/\/ I2C$/;"	m	struct:IrqVec
I2C3_ER	lib/mcu/prelude.h	/^    I2C3_ER               =  73,  \/\/ I2C$/;"	m	struct:IrqVec
I2C3_EV	lib/arch-stm32/prelude.h	/^    I2C3_EV               =  72,  \/\/ I2C$/;"	m	struct:IrqVec
I2C3_EV	lib/mcu/prelude.h	/^    I2C3_EV               =  72,  \/\/ I2C$/;"	m	struct:IrqVec
I2C4	lib/arch-stm32/prelude.h	/^constexpr auto I2C4          = 0x40008400;  \/\/ I2C$/;"	v
I2C4	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40008400> I2C4;$/;"	m	namespace:hall::dev
I2C4	lib/mcu/prelude.h	/^constexpr auto I2C4          = 0x40008400;  \/\/ I2C$/;"	v
I2C4_ER	lib/arch-stm32/prelude.h	/^    I2C4_ER               =  84,  \/\/ DFSDM$/;"	m	struct:IrqVec
I2C4_ER	lib/mcu/prelude.h	/^    I2C4_ER               =  84,  \/\/ DFSDM$/;"	m	struct:IrqVec
I2C4_EV	lib/arch-stm32/prelude.h	/^    I2C4_EV               =  83,  \/\/ I2C$/;"	m	struct:IrqVec
I2C4_EV	lib/mcu/prelude.h	/^    I2C4_EV               =  83,  \/\/ I2C$/;"	m	struct:IrqVec
I2cGpio	lib/mcu/mcu.h	/^    struct I2cGpio {$/;"	s	namespace:mcu
IContextScope	lib/doctest/doctest.h	/^struct DOCTEST_INTERFACE IContextScope$/;"	s	namespace:doctest
IContextScope	tests/embed/src/doctestx.h	/^struct DOCTEST_INTERFACE IContextScope$/;"	s	namespace:doctest
IDR	lib/hall-stm32/hall.h	/^        enum { IDR=0x08+OFF, ODR=0x0C+OFF, BSRR=0x10+OFF };$/;"	e	enum:hall::Pin::__anon1
IDR	lib/mcu/mcu.h	/^        enum { CRL=0x00, CRH=0x04, IDR=0x08, ODR=0x0C, BSRR=0x10, BRR=0x14 };$/;"	e	enum:mcu::Pin::__anon26
IDR	lib/mcu/mcu.h	/^        enum { MODER=0x00, TYPER=0x04, OSPEEDR=0x08, PUPDR=0x0C, IDR=0x10,$/;"	e	enum:mcu::Pin::__anon27
IF	src/codegen.py	/^def IF(block, typ, arg):$/;"	f
IFCR	lib/arch-stm32/uart-f1.h	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14 };$/;"	e	enum:Uart::__anon13
IFCR	lib/arch-stm32/uart-l0.h	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon17
IFCR	lib/arch-stm32/uart-l4.h	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon19
IFCR	lib/hall-stm32/stm32l4-uart.cpp	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon4	file:
IFCR	lib/mcu/uart-stm32l4.h	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon29
IHEX	lib/monty/parser.h	/^            IHEX, SKIP, END, STR, ESC, STRX, STRU, NUM, WORD, ARGS };$/;"	m	struct:Parser	typeref:enum:Parser::
IMPORT_PATH	lib/arch-native/arch.cpp	/^constexpr auto IMPORT_PATH = "tests\/py\/%s.mpy";$/;"	v
INCLUDES	src/codegen.py	/^def INCLUDES(block):$/;"	f
INFO	lib/doctest/doctest.h	/^#define INFO(/;"	d
INFO	tests/embed/src/doctestx.h	/^#define INFO(/;"	d
INNER_HOOK	lib/monty/stack.cpp	/^#define INNER_HOOK /;"	d	file:
INNER_HOOK	lib/monty/stack.cpp	/^#define INNER_HOOK$/;"	d	file:
INNER_HOOK	lib/pyvm/pyvm.cpp	/^#define INNER_HOOK /;"	d	file:
INNER_HOOK	lib/pyvm/pyvm.cpp	/^#define INNER_HOOK$/;"	d	file:
IOBit	lib/mcu/mcu.h	/^        struct IOBit {$/;"	s	struct:mcu::IOWord
IOMask	lib/mcu/mcu.h	/^        struct IOMask {$/;"	s	struct:mcu::IOWord
IOWord	lib/mcu/mcu.h	/^    struct IOWord {$/;"	s	namespace:mcu
IRQ	lib/mcu/mcu.cpp	/^#define IRQ(/;"	d	file:
IRQ1_MODEREADY	lib/arch-stm32/jee-rf69.h	/^            IRQ1_MODEREADY    = 1<<7,$/;"	e	enum:jeeh::RF69::__anon25
IRQ1_RXREADY	lib/arch-stm32/jee-rf69.h	/^            IRQ1_RXREADY      = 1<<6,$/;"	e	enum:jeeh::RF69::__anon25
IRQ1_SYNADDRMATCH	lib/arch-stm32/jee-rf69.h	/^            IRQ1_SYNADDRMATCH = 1<<0,$/;"	e	enum:jeeh::RF69::__anon25
IRQ2_FIFONOTEMPTY	lib/arch-stm32/jee-rf69.h	/^            IRQ2_FIFONOTEMPTY = 1<<6,$/;"	e	enum:jeeh::RF69::__anon25
IRQ2_PACKETSENT	lib/arch-stm32/jee-rf69.h	/^            IRQ2_PACKETSENT   = 1<<3,$/;"	e	enum:jeeh::RF69::__anon25
IRQ2_PAYLOADREADY	lib/arch-stm32/jee-rf69.h	/^            IRQ2_PAYLOADREADY = 1<<2,$/;"	e	enum:jeeh::RF69::__anon25
IRQVEC	src/codegen.py	/^def IRQVEC(block, *args):$/;"	f
ISR	lib/arch-stm32/uart-f1.h	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14 };$/;"	e	enum:Uart::__anon13
ISR	lib/arch-stm32/uart-l0.h	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon17
ISR	lib/arch-stm32/uart-l4.h	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon19
ISR	lib/hall-stm32/stm32l4-uart.cpp	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon4	file:
ISR	lib/hall-stm32/stm32l4.cpp	/^        enum { TR=0x00,DR=0x04,CR=0x08,ISR=0x0C,WPR=0x24,BKPR=0x50 };$/;"	e	enum:hall::rtc::__anon5	file:
ISR	lib/mcu/uart-stm32l4.h	/^    enum { ISR=0x00,IFCR=0x04,CCR=0x08,CNDTR=0x0C,CPAR=0x10,CMAR=0x14,CSELR=0xA8 };$/;"	e	enum:Uart::__anon29
IWDG	lib/arch-stm32/prelude.h	/^constexpr auto IWDG          = 0x40003000;  \/\/ IWDG$/;"	v
IWDG	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40003000> IWDG;$/;"	m	namespace:hall::dev
IWDG	lib/mcu/prelude.h	/^constexpr auto IWDG          = 0x40003000;  \/\/ IWDG$/;"	v
Id_t	lib/boss/boss.h	/^        auto pull () -> Id_t;$/;"	m	struct:boss::pool::Queue
Id_t	lib/boss/boss.h	/^        auto tag () -> Id_t&;$/;"	m	struct:boss::pool::Buf
Id_t	lib/boss/boss.h	/^        static auto asId (void const*) -> Id_t;$/;"	m	struct:boss::pool::Buf
ImportError	lib/monty/monty.h	/^        ImportError,         \/\/ Exception$/;"	m	class:monty::E
ImportFrom	lib/pyvm/pyvm.cpp	/^    ImportFrom             = 0x1C,$/;"	e	enum:uint8_t	file:
ImportName	lib/pyvm/pyvm.cpp	/^    ImportName             = 0x1B,$/;"	e	enum:uint8_t	file:
ImportStar	lib/pyvm/pyvm.cpp	/^    ImportStar             = 0x69,$/;"	e	enum:uint8_t	file:
IndexError	lib/monty/monty.h	/^        IndexError,          \/\/ LookupError$/;"	m	class:monty::E
Info	lib/mrfs/mrfs.h	/^    struct Info {$/;"	s	namespace:mrfs
Inst	lib/monty/monty.h	/^    struct Inst : Dict {$/;"	s	namespace:monty
Inst	lib/monty/type.cpp	/^Inst::Inst (ArgVec const& args, Class const& cls) : Dict (&cls) {$/;"	f	class:Inst
Int	lib/monty/monty.h	/^        constexpr Int (int64_t i64) : _i64 (i64) {}$/;"	f	struct:monty::Int
Int	lib/monty/monty.h	/^        enum Tag { Nil, Int, Str, Obj };$/;"	e	enum:monty::Value::Tag
Int	lib/monty/monty.h	/^    struct Int : Object {$/;"	s	namespace:monty
Io32	lib/hall-stm32/hall.h	/^    struct Io32 : IoBase<uint32_t,ADDR> {$/;"	s	namespace:hall
Io32	tests/gpio/gpio.cpp	/^        struct Io32 : IoBase<uint32_t,ADDR> {$/;"	s	namespace:gpio	file:
Io32b	lib/hall-stm32/hall.h	/^    struct Io32b : Io32<ADDR> {$/;"	s	namespace:hall
IoBase	lib/hall-stm32/hall.h	/^    struct IoBase {$/;"	s	namespace:hall
IoBase	tests/gpio/gpio.cpp	/^        struct IoBase {$/;"	s	namespace:gpio	file:
IrqVec	lib/arch-stm32/prelude.h	/^enum struct IrqVec : uint8_t {$/;"	s
IrqVec	lib/mcu/prelude.h	/^enum struct IrqVec : uint8_t {$/;"	s
Item	lib/monty/monty.h	/^        struct Item { Q k; Value v; };$/;"	s	struct:monty::Lookup
Iterator	lib/monty/monty.h	/^        Iterator (Value obj, Value pos ={}) : RawIter (obj, pos) {}$/;"	f	struct:monty::Iterator
Iterator	lib/monty/monty.h	/^    struct Iterator : Object, RawIter {$/;"	s	namespace:monty
Jump	lib/pyvm/pyvm.cpp	/^    Jump                   = 0x42,$/;"	e	enum:uint8_t	file:
JumpIfFalseOrPop	lib/pyvm/pyvm.cpp	/^    JumpIfFalseOrPop       = 0x46,$/;"	e	enum:uint8_t	file:
JumpIfTrueOrPop	lib/pyvm/pyvm.cpp	/^    JumpIfTrueOrPop        = 0x45,$/;"	e	enum:uint8_t	file:
KWARGS	src/codegen.py	/^def KWARGS(block, *arg):$/;"	f
KeyError	lib/monty/monty.h	/^        KeyError,            \/\/ LookupError$/;"	m	class:monty::E
L0	lib/hall-stm32/hall.h	/^    enum struct STM { F1, F3, F4, F7, G0, H7, L0, L4 };$/;"	m	struct:hall::STM
LCD	lib/arch-stm32/prelude.h	/^    LCD                   =  78,  \/\/ LCD$/;"	m	struct:IrqVec
LCD	lib/arch-stm32/prelude.h	/^constexpr auto LCD           = 0x40002400;  \/\/ LCD$/;"	v
LCD	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40002400> LCD;$/;"	m	namespace:hall::dev
LCD	lib/mcu/prelude.h	/^    LCD                   =  78,  \/\/ LCD$/;"	m	struct:IrqVec
LCD	lib/mcu/prelude.h	/^constexpr auto LCD           = 0x40002400;  \/\/ LCD$/;"	v
LEN_BITS	lib/extend/typ-array.h	/^        constexpr static auto LEN_BITS = 27;$/;"	m	struct:monty::Array
LEV0	tests/gpio/gpio.cpp	/^        enum { LEV0=0x34, SET0=0x1C, CLR0=0x28 };$/;"	e	enum:gpio::Pin::__anon37	file:
LIBS	src/Makefile	/^LIBS = ..\/lib$/;"	m
LIBS	tests/buffers/Makefile	/^LIBS = ..\/..\/lib$/;"	m
LIBS	tests/gpio/Makefile	/^LIBS = ..\/..\/lib$/;"	m
LIBS	tests/native/Makefile	/^LIBS = ..\/..\/lib$/;"	m
LIBS	tests/tdd/Makefile	/^LIBS = ..\/..\/lib$/;"	m
LIFCR	lib/arch-stm32/uart-f4.h	/^    enum { LISR=0x00,LIFCR=0x08,SCR=0x10,SNDTR=0x14,SPAR=0x18,SM0AR=0x1C };$/;"	e	enum:Uart::__anon21
LIFCR	lib/mcu/uart-stm32f4f7.h	/^    enum { LISR=0x00,LIFCR=0x08,SCR=0x10,SNDTR=0x14,SPAR=0x18,SM0AR=0x1C };$/;"	e	enum:Uart::__anon32
LISR	lib/arch-stm32/uart-f4.h	/^    enum { LISR=0x00,LIFCR=0x08,SCR=0x10,SNDTR=0x14,SPAR=0x18,SM0AR=0x1C };$/;"	e	enum:Uart::__anon21
LISR	lib/mcu/uart-stm32f4f7.h	/^    enum { LISR=0x00,LIFCR=0x08,SCR=0x10,SNDTR=0x14,SPAR=0x18,SM0AR=0x1C };$/;"	e	enum:Uart::__anon32
LPTIM1	lib/arch-stm32/prelude.h	/^    LPTIM1                =  65,  \/\/ LPTIM$/;"	m	struct:IrqVec
LPTIM1	lib/arch-stm32/prelude.h	/^constexpr auto LPTIM1        = 0x40007C00;  \/\/ LPTIM$/;"	v
LPTIM1	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40007C00> LPTIM1;$/;"	m	namespace:hall::dev
LPTIM1	lib/mcu/prelude.h	/^    LPTIM1                =  65,  \/\/ LPTIM$/;"	m	struct:IrqVec
LPTIM1	lib/mcu/prelude.h	/^constexpr auto LPTIM1        = 0x40007C00;  \/\/ LPTIM$/;"	v
LPTIM2	lib/arch-stm32/prelude.h	/^    LPTIM2                =  66,  \/\/ LPTIM$/;"	m	struct:IrqVec
LPTIM2	lib/arch-stm32/prelude.h	/^constexpr auto LPTIM2        = 0x40009400;  \/\/ LPTIM$/;"	v
LPTIM2	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40009400> LPTIM2;$/;"	m	namespace:hall::dev
LPTIM2	lib/mcu/prelude.h	/^    LPTIM2                =  66,  \/\/ LPTIM$/;"	m	struct:IrqVec
LPTIM2	lib/mcu/prelude.h	/^constexpr auto LPTIM2        = 0x40009400;  \/\/ LPTIM$/;"	v
LPUART1	lib/arch-stm32/prelude.h	/^    LPUART1               =  70,  \/\/ USART$/;"	m	struct:IrqVec
LPUART1	lib/arch-stm32/prelude.h	/^constexpr auto LPUART1       = 0x40008000;  \/\/ USART$/;"	v
LPUART1	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40008000> LPUART1;$/;"	m	namespace:hall::dev
LPUART1	lib/mcu/prelude.h	/^    LPUART1               =  70,  \/\/ USART$/;"	m	struct:IrqVec
LPUART1	lib/mcu/prelude.h	/^constexpr auto LPUART1       = 0x40008000;  \/\/ USART$/;"	v
LightGrey	lib/doctest/doctest.h	/^        LightGrey   = Bright | Grey,$/;"	e	enum:doctest::Color::Enum
LightGrey	tests/embed/src/doctestx.h	/^        LightGrey   = Bright | Grey,$/;"	e	enum:doctest::Color::Enum
LineIter	lib/graphics/twodee.h	/^        LineIter (Point p1, Point p2) : x1 (p2.x-p1.x), y1 (p2.y-p1.y),$/;"	f	struct:twodee::LineIter
LineIter	lib/graphics/twodee.h	/^    struct LineIter {$/;"	s	namespace:twodee
LineSerial	lib/arch-stm32/arch.cpp	/^    LineSerial () : incoming (*new Event) {$/;"	f	struct:LineSerial
LineSerial	lib/arch-stm32/arch.cpp	/^struct LineSerial : Context {$/;"	s	file:
List	lib/monty/monty.h	/^    struct List : Tuple {$/;"	s	namespace:monty
LoadAttr	lib/pyvm/pyvm.cpp	/^    LoadAttr               = 0x13,$/;"	e	enum:uint8_t	file:
LoadBuildClass	lib/pyvm/pyvm.cpp	/^    LoadBuildClass         = 0x54,$/;"	e	enum:uint8_t	file:
LoadConstFalse	lib/pyvm/pyvm.cpp	/^    LoadConstFalse         = 0x50,$/;"	e	enum:uint8_t	file:
LoadConstNone	lib/pyvm/pyvm.cpp	/^    LoadConstNone          = 0x51,$/;"	e	enum:uint8_t	file:
LoadConstObj	lib/pyvm/pyvm.cpp	/^    LoadConstObj           = 0x23,$/;"	e	enum:uint8_t	file:
LoadConstSmallInt	lib/pyvm/pyvm.cpp	/^    LoadConstSmallInt      = 0x22,$/;"	e	enum:uint8_t	file:
LoadConstSmallIntMulti	lib/pyvm/pyvm.cpp	/^    LoadConstSmallIntMulti = 0x70,$/;"	e	enum:uint8_t	file:
LoadConstString	lib/pyvm/pyvm.cpp	/^    LoadConstString        = 0x10,$/;"	e	enum:uint8_t	file:
LoadConstTrue	lib/pyvm/pyvm.cpp	/^    LoadConstTrue          = 0x52,$/;"	e	enum:uint8_t	file:
LoadDeref	lib/pyvm/pyvm.cpp	/^    LoadDeref              = 0x25,$/;"	e	enum:uint8_t	file:
LoadFastMulti	lib/pyvm/pyvm.cpp	/^    LoadFastMulti          = 0xB0,$/;"	e	enum:uint8_t	file:
LoadFastN	lib/pyvm/pyvm.cpp	/^    LoadFastN              = 0x24,$/;"	e	enum:uint8_t	file:
LoadGlobal	lib/pyvm/pyvm.cpp	/^    LoadGlobal             = 0x12,$/;"	e	enum:uint8_t	file:
LoadMethod	lib/pyvm/pyvm.cpp	/^    LoadMethod             = 0x14,$/;"	e	enum:uint8_t	file:
LoadName	lib/pyvm/pyvm.cpp	/^    LoadName               = 0x11,$/;"	e	enum:uint8_t	file:
LoadNull	lib/pyvm/pyvm.cpp	/^    LoadNull               = 0x53,$/;"	e	enum:uint8_t	file:
LoadSubscr	lib/pyvm/pyvm.cpp	/^    LoadSubscr             = 0x55,$/;"	e	enum:uint8_t	file:
LoadSuperMethod	lib/pyvm/pyvm.cpp	/^    LoadSuperMethod        = 0x15,$/;"	e	enum:uint8_t	file:
Loader	lib/pyvm/loader.h	/^    Loader (VaryVec* vv =nullptr) : vvec (vv) {}$/;"	f	struct:Loader
Loader	lib/pyvm/loader.h	/^struct Loader {$/;"	s
Lookup	lib/monty/monty.h	/^        constexpr Lookup (Item const (&items)[N], Lookup const* chain =nullptr)$/;"	f	struct:monty::Lookup
Lookup	lib/monty/monty.h	/^        constexpr Lookup (Lookup const* chain =nullptr) : _chain (chain) {}$/;"	f	struct:monty::Lookup
Lookup	lib/monty/monty.h	/^    struct Lookup : StaticObj {$/;"	s	namespace:monty
LookupError	lib/monty/monty.h	/^        LookupError,         \/\/ Exception$/;"	m	class:monty::E
MAGIC	lib/mrfs/mrfs.h	/^    constexpr auto MAGIC = 0x3079746D; \/\/ 'mty0'$/;"	m	namespace:mrfs
MESSAGE	lib/doctest/doctest.h	/^#define MESSAGE(/;"	d
MESSAGE	tests/embed/src/doctestx.h	/^#define MESSAGE(/;"	d
MODER	lib/mcu/mcu.h	/^        enum { MODER=0x00, TYPER=0x04, OSPEEDR=0x08, PUPDR=0x0C, IDR=0x10,$/;"	e	enum:mcu::Pin::__anon27
MODE_RECEIVE	lib/arch-stm32/jee-rf69.h	/^            MODE_RECEIVE      = 4<<2,$/;"	e	enum:jeeh::RF69::__anon25
MODE_SLEEP	lib/arch-stm32/jee-rf69.h	/^            MODE_SLEEP        = 0<<2,$/;"	e	enum:jeeh::RF69::__anon25
MODE_STANDBY	lib/arch-stm32/jee-rf69.h	/^            MODE_STANDBY      = 1<<2,$/;"	e	enum:jeeh::RF69::__anon25
MODE_TRANSMIT	lib/arch-stm32/jee-rf69.h	/^            MODE_TRANSMIT     = 3<<2,$/;"	e	enum:jeeh::RF69::__anon25
MODULE	src/codegen.py	/^def MODULE(block, mod):$/;"	f
MODULE_END	src/codegen.py	/^def MODULE_END(block):$/;"	f
MOD_LIST	src/codegen.py	/^def MOD_LIST(block, sel):$/;"	f
MPU	lib/arch-stm32/prelude.h	/^constexpr auto MPU           = 0xE000ED90;  \/\/ MPU$/;"	v
MPU	lib/hall-stm32/hall.h	/^        constexpr Io32  <0xE000ED90> MPU;$/;"	m	namespace:hall::dev
MPU	lib/mcu/prelude.h	/^constexpr auto MPU           = 0xE000ED90;  \/\/ MPU$/;"	v
MagicStart	lib/arch-stm32/arch.cpp	/^    enum { MagicStart = 987654321, MagicValid = 123456789 };$/;"	e	enum:HexSerial::__anon15	file:
MagicValid	lib/arch-stm32/arch.cpp	/^    enum { MagicStart = 987654321, MagicValid = 123456789 };$/;"	e	enum:HexSerial::__anon15	file:
MakeClosure	lib/pyvm/pyvm.cpp	/^    MakeClosure            = 0x20,$/;"	e	enum:uint8_t	file:
MakeClosureDefargs	lib/pyvm/pyvm.cpp	/^    MakeClosureDefargs     = 0x21,$/;"	e	enum:uint8_t	file:
MakeFunction	lib/pyvm/pyvm.cpp	/^    MakeFunction           = 0x32,$/;"	e	enum:uint8_t	file:
MakeFunctionDefargs	lib/pyvm/pyvm.cpp	/^    MakeFunctionDefargs    = 0x33,$/;"	e	enum:uint8_t	file:
MarkObj	lib/monty/gc.cpp	/^    MarkObj (Object* o =0) : other (o) { ++created; }$/;"	f	struct:MarkObj
MarkObj	lib/monty/gc.cpp	/^struct MarkObj : Object {$/;"	s	file:
MarkObj	tests/unit/mem/main.cpp	/^    MarkObj (Object* o =0) : other (o) { ++created; }$/;"	f	struct:MarkObj
MarkObj	tests/unit/mem/main.cpp	/^struct MarkObj : Object {$/;"	s	file:
MemManage_Handler	lib/arch-stm32/arch.cpp	/^extern "C" void MemManage_Handler  () { panic("mem fault"); };$/;"	f
MemoryError	lib/monty/monty.h	/^        MemoryError,         \/\/ Exception$/;"	m	class:monty::E
MessageData	lib/doctest/doctest.h	/^struct DOCTEST_INTERFACE MessageData$/;"	s	namespace:doctest
MessageData	tests/embed/src/doctestx.h	/^struct DOCTEST_INTERFACE MessageData$/;"	s	namespace:doctest
Method	lib/monty/monty.h	/^        constexpr Method (Base const& meth) : _meth (meth) {}$/;"	f	struct:monty::Method
Method	lib/monty/monty.h	/^    struct Method : StaticObj {$/;"	s	namespace:monty
Module	lib/monty/monty.h	/^        constexpr Module (Value nm, Object const& lu =builtins)$/;"	f	struct:monty::Module
Module	lib/monty/monty.h	/^    struct Module : Dict {$/;"	s	namespace:monty
NOMINMAX	lib/doctest/doctest.h	/^#define NOMINMAX$/;"	d
NOMINMAX	tests/embed/src/doctestx.h	/^#define NOMINMAX$/;"	d
NUM	lib/monty/parser.h	/^            IHEX, SKIP, END, STR, ESC, STRX, STRU, NUM, WORD, ARGS };$/;"	m	struct:Parser	typeref:enum:Parser::
NVIC	lib/arch-stm32/prelude.h	/^constexpr auto NVIC          = 0xE000E100;  \/\/ NVIC$/;"	v
NVIC	lib/hall-stm32/hall.h	/^        constexpr Io32  <0xE000E100> NVIC;$/;"	m	namespace:hall::dev
NVIC	lib/mcu/prelude.h	/^constexpr auto NVIC          = 0xE000E100;  \/\/ NVIC$/;"	v
NVIC_STIR	lib/arch-stm32/prelude.h	/^constexpr auto NVIC_STIR     = 0xE000EF00;  \/\/ NVIC$/;"	v
NVIC_STIR	lib/hall-stm32/hall.h	/^        constexpr Io32  <0xE000EF00> NVIC_STIR;$/;"	m	namespace:hall::dev
NVIC_STIR	lib/mcu/prelude.h	/^constexpr auto NVIC_STIR     = 0xE000EF00;  \/\/ NVIC$/;"	v
NameError	lib/monty/monty.h	/^        NameError,           \/\/ Exception$/;"	m	class:monty::E
Nil	lib/monty/monty.h	/^        enum Tag { Nil, Int, Str, Obj };$/;"	e	enum:monty::Value::Tag
None	lib/doctest/doctest.h	/^        None = 0,$/;"	e	enum:doctest::Color::Enum
None	lib/monty/monty.h	/^    struct None : StaticObj {$/;"	s	namespace:monty
None	tests/embed/src/doctestx.h	/^        None = 0,$/;"	e	enum:doctest::Color::Enum
NotImplementedError	lib/monty/monty.h	/^        NotImplementedError, \/\/ RuntimeError$/;"	m	class:monty::E
OBJS	tests/buffers/Makefile	/^OBJS = $(patsubst %.cpp,%.o,$(notdir $(SRCS)))$/;"	m
OBJS	tests/gpio/Makefile	/^OBJS = $(patsubst %.cpp,%.o,$(notdir $(SRCS)))$/;"	m
OBJS	tests/native/Makefile	/^OBJS = $(patsubst %.cpp,%.o,$(notdir $(SRCS)))$/;"	m
OBJS	tests/tdd/Makefile	/^OBJS = $(patsubst %.cpp,%.o,$(notdir $(SRCS)))$/;"	m
ODR	lib/hall-stm32/hall.h	/^        enum { IDR=0x08+OFF, ODR=0x0C+OFF, BSRR=0x10+OFF };$/;"	e	enum:hall::Pin::__anon1
ODR	lib/mcu/mcu.h	/^                ODR=0x14, BSRR=0x18, AFRL=0x20, AFRH=0x24, BRR=0x28 };$/;"	e	enum:mcu::Pin::__anon27
ODR	lib/mcu/mcu.h	/^        enum { CRL=0x00, CRH=0x04, IDR=0x08, ODR=0x0C, BSRR=0x10, BRR=0x14 };$/;"	e	enum:mcu::Pin::__anon26
OFF	lib/hall-stm32/hall.h	/^        constexpr static auto OFF = FAMILY == STM::F1 ? 0x0 : 0x8;$/;"	m	struct:hall::Pin
OFF	src/codegen.py	/^def OFF(block, *args):$/;"	f
ON	src/codegen.py	/^def ON(block, *args):$/;"	f
OP	src/codegen.py	/^def OP(block, typ='', multi=0):$/;"	f
OPAMP	lib/arch-stm32/prelude.h	/^constexpr auto OPAMP         = 0x40007800;  \/\/ OPAMP$/;"	v
OPAMP	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40007800> OPAMP;$/;"	m	namespace:hall::dev
OPAMP	lib/mcu/prelude.h	/^constexpr auto OPAMP         = 0x40007800;  \/\/ OPAMP$/;"	v
OPCODES	src/codegen.py	/^def OPCODES(block, fname):$/;"	f
OP_EMIT	src/codegen.py	/^def OP_EMIT(block, sel=0):$/;"	f
OP_INIT	src/codegen.py	/^def OP_INIT(block):$/;"	f
OSError	lib/monty/monty.h	/^        OSError,             \/\/ Exception$/;"	m	class:monty::E
OSPEEDR	lib/mcu/mcu.h	/^        enum { MODER=0x00, TYPER=0x04, OSPEEDR=0x08, PUPDR=0x0C, IDR=0x10,$/;"	e	enum:mcu::Pin::__anon27
OS_SZ	lib/monty/gc.cpp	/^constexpr auto OS_SZ  = sizeof (ObjSlot);$/;"	v
Obj	lib/monty/monty.h	/^        auto operator= (Obj const&) -> Obj& =delete;$/;"	m	struct:monty::Obj
Obj	lib/monty/monty.h	/^        auto operator= (Obj&&) -> Obj& =delete;$/;"	m	struct:monty::Obj
Obj	lib/monty/monty.h	/^        enum Tag { Nil, Int, Str, Obj };$/;"	e	enum:monty::Value::Tag
Obj	lib/monty/monty.h	/^    struct Obj {$/;"	s	namespace:monty
Obj	lib/monty/parser.h	/^    enum State : uint8_t { Ini, Cmd, Hex, Obj, Err,$/;"	m	struct:Parser	typeref:enum:Parser::
ObjSlot	lib/monty/gc.cpp	/^struct ObjSlot {$/;"	s	file:
Object	lib/monty/monty.h	/^        auto asObj () const -> Object&; \/\/ create int\/str object if needed$/;"	m	struct:monty::Value
Object	lib/monty/monty.h	/^    struct Object : Obj {$/;"	s	namespace:monty
OrderedDict	src/xmltodict.py	/^from collections import OrderedDict$/;"	i
PARAMS	src/codegen.py	/^def PARAMS(block, *args, **kwargs):$/;"	f
PERIPH	src/codegen.py	/^def PERIPH(block, *args):$/;"	f
PERSIST_SIZE	lib/arch-stm32/arch.cpp	/^    static constexpr auto PERSIST_SIZE = 2048;$/;"	m	struct:HexSerial	file:
PTR_SZ	lib/monty/gc.cpp	/^constexpr auto PTR_SZ = sizeof (void*);$/;"	v
PUPDR	lib/mcu/mcu.h	/^        enum { MODER=0x00, TYPER=0x04, OSPEEDR=0x08, PUPDR=0x0C, IDR=0x10,$/;"	e	enum:mcu::Pin::__anon27
PVD_PVM	lib/arch-stm32/prelude.h	/^    PVD_PVM               =   1,  \/\/ EXTI$/;"	m	struct:IrqVec
PVD_PVM	lib/mcu/prelude.h	/^    PVD_PVM               =   1,  \/\/ EXTI$/;"	m	struct:IrqVec
PWR	lib/arch-stm32/prelude.h	/^constexpr auto PWR           = 0x40007000;  \/\/ PWR$/;"	v
PWR	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40007000> PWR;$/;"	m	namespace:hall::dev
PWR	lib/mcu/prelude.h	/^constexpr auto PWR           = 0x40007000;  \/\/ PWR$/;"	v
Parser	lib/monty/parser.h	/^struct Parser {$/;"	s
ParsingInterrupted	src/xmltodict.py	/^class ParsingInterrupted(Exception):$/;"	c
Pin	lib/arch-stm32/jee-stm32.h	/^        constexpr Pin () : _port (0xFF), _pin (0xFF) {}$/;"	f	struct:jeeh::Pin
Pin	lib/arch-stm32/jee-stm32.h	/^        constexpr Pin (char port, int pin) : _port (port-'A'), _pin (pin) {}$/;"	f	struct:jeeh::Pin
Pin	lib/arch-stm32/jee-stm32.h	/^    struct Pin {$/;"	s	namespace:jeeh
Pin	lib/hall-stm32/hall.h	/^        constexpr Pin () : port (15), pin (0) {}$/;"	f	struct:hall::Pin
Pin	lib/hall-stm32/hall.h	/^    struct Pin {$/;"	s	namespace:hall
Pin	lib/mcu/mcu.h	/^        constexpr Pin () : _port (15), _pin (0) {}$/;"	f	struct:mcu::Pin
Pin	lib/mcu/mcu.h	/^    struct Pin {$/;"	s	namespace:mcu
Pin	tests/gpio/gpio.cpp	/^        constexpr Pin () : port (15), pin (0) {}$/;"	f	struct:gpio::Pin
Pin	tests/gpio/gpio.cpp	/^    struct Pin {$/;"	s	namespace:gpio	file:
Pins	lib/arch-stm32/mod-machine.cpp	/^struct Pins : Object {$/;"	s	file:
Point	lib/graphics/twodee.h	/^    struct Point { int16_t x, y; };$/;"	s	namespace:twodee
PopExceptJump	lib/pyvm/pyvm.cpp	/^    PopExceptJump          = 0x4A,$/;"	e	enum:uint8_t	file:
PopJumpIfFalse	lib/pyvm/pyvm.cpp	/^    PopJumpIfFalse         = 0x44,$/;"	e	enum:uint8_t	file:
PopJumpIfTrue	lib/pyvm/pyvm.cpp	/^    PopJumpIfTrue          = 0x43,$/;"	e	enum:uint8_t	file:
PopTop	lib/pyvm/pyvm.cpp	/^    PopTop                 = 0x59,$/;"	e	enum:uint8_t	file:
Printer	lib/mcu/printer.h	/^    Printer (void* arg, void (*fun) (void*, uint8_t const*, int))$/;"	f	struct:Printer
Printer	lib/mcu/printer.h	/^struct Printer {$/;"	s
Proxy	lib/monty/monty.h	/^        struct Proxy { Dict& d; Value k;$/;"	s	struct:monty::Dict
Proxy	lib/monty/monty.h	/^        struct Proxy { Set& s; Value v;$/;"	s	struct:monty::Set
PyVM	lib/pyvm/pyvm.cpp	/^    PyVM (Callable const& clb) {$/;"	f	struct:PyVM
PyVM	lib/pyvm/pyvm.cpp	/^struct PyVM : Context {$/;"	s	file:
Q	lib/monty/monty.h	/^        constexpr Q (uint16_t id, char const* =nullptr) : _id (id) {}$/;"	f	struct:monty::Q
Q	lib/monty/monty.h	/^    struct Q {$/;"	s	namespace:monty
QID_RAM_BASE	lib/monty/data.cpp	/^constexpr int QID_RAM_BASE = 32*1024; \/\/ TODO arbitrary choice, currently$/;"	v
QSTR	src/codegen.py	/^def QSTR(block, off=0):$/;"	f
QSTR_EMIT	src/codegen.py	/^def QSTR_EMIT(block):$/;"	f
QUADSPI	lib/arch-stm32/prelude.h	/^    QUADSPI               =  71,  \/\/ QUADSPI$/;"	m	struct:IrqVec
QUADSPI	lib/arch-stm32/prelude.h	/^constexpr auto QUADSPI       = 0xA0001000;  \/\/ QUADSPI$/;"	v
QUADSPI	lib/hall-stm32/hall.h	/^        constexpr Io32  <0xA0001000> QUADSPI;$/;"	m	namespace:hall::dev
QUADSPI	lib/mcu/prelude.h	/^    QUADSPI               =  71,  \/\/ QUADSPI$/;"	m	struct:IrqVec
QUADSPI	lib/mcu/prelude.h	/^constexpr auto QUADSPI       = 0xA0001000;  \/\/ QUADSPI$/;"	v
Queue	lib/boss/boss.h	/^    struct Queue {$/;"	s	namespace:boss::pool
Queue	tests/buffers/main.cpp	/^    struct Queue {$/;"	s	namespace:buf	file:
RCC	lib/arch-stm32/prelude.h	/^    RCC                   =   5,  \/\/ RCC$/;"	m	struct:IrqVec
RCC	lib/arch-stm32/prelude.h	/^constexpr auto RCC           = 0x40021000;  \/\/ RCC$/;"	v
RCC	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40021000> RCC;$/;"	m	namespace:hall::dev
RCC	lib/mcu/prelude.h	/^    RCC                   =   5,  \/\/ RCC$/;"	m	struct:IrqVec
RCC	lib/mcu/prelude.h	/^constexpr auto RCC           = 0x40021000;  \/\/ RCC$/;"	v
RCCALSTART	lib/arch-stm32/jee-rf69.h	/^            RCCALSTART        = 0x80,$/;"	e	enum:jeeh::RF69::__anon25
RCC_AHB1ENR	lib/arch-stm32/prelude.h	/^constexpr auto RCC_AHB1ENR = RCC + 0x48;$/;"	v
RCC_AHB1ENR	lib/mcu/prelude.h	/^constexpr auto RCC_AHB1ENR = RCC + 0x48;$/;"	v
RCC_APB1ENR	lib/arch-stm32/prelude.h	/^constexpr auto RCC_APB1ENR = RCC + 0x58;$/;"	v
RCC_APB1ENR	lib/mcu/prelude.h	/^constexpr auto RCC_APB1ENR = RCC + 0x58;$/;"	v
RDR	lib/arch-stm32/uart-l0.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon16
RDR	lib/arch-stm32/uart-l4.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon18
RDR	lib/hall-stm32/stm32l4-uart.cpp	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon3	file:
RDR	lib/mcu/uart-stm32f4f7.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon31
RDR	lib/mcu/uart-stm32f4f7.h	/^    enum { SR=0x00,RDR=0x04,TDR=0x04,BRR=0x08,CR1=0x0C,CR3=0x14 };$/;"	e	enum:Uart::__anon30
RDR	lib/mcu/uart-stm32l4.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon28
REGISTER_EXCEPTION_TRANSLATOR	lib/doctest/doctest.h	/^#define REGISTER_EXCEPTION_TRANSLATOR(/;"	d
REGISTER_EXCEPTION_TRANSLATOR	tests/embed/src/doctestx.h	/^#define REGISTER_EXCEPTION_TRANSLATOR(/;"	d
REGISTER_LISTENER	lib/doctest/doctest.h	/^#define REGISTER_LISTENER(/;"	d
REGISTER_LISTENER	tests/embed/src/doctestx.h	/^#define REGISTER_LISTENER(/;"	d
REGISTER_REPORTER	lib/doctest/doctest.h	/^#define REGISTER_REPORTER(/;"	d
REGISTER_REPORTER	tests/embed/src/doctestx.h	/^#define REGISTER_REPORTER(/;"	d
REG_AESKEYMSB	lib/arch-stm32/jee-rf69.h	/^            REG_AESKEYMSB     = 0x3E,$/;"	e	enum:jeeh::RF69::__anon25
REG_AFCLSB	lib/arch-stm32/jee-rf69.h	/^            REG_AFCLSB        = 0x20,$/;"	e	enum:jeeh::RF69::__anon25
REG_AFCMSB	lib/arch-stm32/jee-rf69.h	/^            REG_AFCMSB        = 0x1F,$/;"	e	enum:jeeh::RF69::__anon25
REG_BCASTADDR	lib/arch-stm32/jee-rf69.h	/^            REG_BCASTADDR     = 0x3A,$/;"	e	enum:jeeh::RF69::__anon25
REG_FEILSB	lib/arch-stm32/jee-rf69.h	/^            REG_FEILSB        = 0x22,$/;"	e	enum:jeeh::RF69::__anon25
REG_FEIMSB	lib/arch-stm32/jee-rf69.h	/^            REG_FEIMSB        = 0x21,$/;"	e	enum:jeeh::RF69::__anon25
REG_FIFO	lib/arch-stm32/jee-rf69.h	/^            REG_FIFO          = 0x00,$/;"	e	enum:jeeh::RF69::__anon25
REG_FIFOTHRESH	lib/arch-stm32/jee-rf69.h	/^            REG_FIFOTHRESH    = 0x3C,$/;"	e	enum:jeeh::RF69::__anon25
REG_FRFMSB	lib/arch-stm32/jee-rf69.h	/^            REG_FRFMSB        = 0x07,$/;"	e	enum:jeeh::RF69::__anon25
REG_IRQFLAGS1	lib/arch-stm32/jee-rf69.h	/^            REG_IRQFLAGS1     = 0x27,$/;"	e	enum:jeeh::RF69::__anon25
REG_IRQFLAGS2	lib/arch-stm32/jee-rf69.h	/^            REG_IRQFLAGS2     = 0x28,$/;"	e	enum:jeeh::RF69::__anon25
REG_LNAVALUE	lib/arch-stm32/jee-rf69.h	/^            REG_LNAVALUE      = 0x18,$/;"	e	enum:jeeh::RF69::__anon25
REG_NODEADDR	lib/arch-stm32/jee-rf69.h	/^            REG_NODEADDR      = 0x39,$/;"	e	enum:jeeh::RF69::__anon25
REG_OPMODE	lib/arch-stm32/jee-rf69.h	/^            REG_OPMODE        = 0x01,$/;"	e	enum:jeeh::RF69::__anon25
REG_PALEVEL	lib/arch-stm32/jee-rf69.h	/^            REG_PALEVEL       = 0x11,$/;"	e	enum:jeeh::RF69::__anon25
REG_PKTCONFIG2	lib/arch-stm32/jee-rf69.h	/^            REG_PKTCONFIG2    = 0x3D,$/;"	e	enum:jeeh::RF69::__anon25
REG_RSSIVALUE	lib/arch-stm32/jee-rf69.h	/^            REG_RSSIVALUE     = 0x24,$/;"	e	enum:jeeh::RF69::__anon25
REG_SYNCVALUE1	lib/arch-stm32/jee-rf69.h	/^            REG_SYNCVALUE1    = 0x2F,$/;"	e	enum:jeeh::RF69::__anon25
REG_SYNCVALUE2	lib/arch-stm32/jee-rf69.h	/^            REG_SYNCVALUE2    = 0x30,$/;"	e	enum:jeeh::RF69::__anon25
REQUIRE	lib/doctest/doctest.h	/^#define REQUIRE(/;"	d
REQUIRE	tests/embed/src/doctestx.h	/^#define REQUIRE(/;"	d
REQUIRE_EQ	lib/doctest/doctest.h	/^#define REQUIRE_EQ(/;"	d
REQUIRE_EQ	tests/embed/src/doctestx.h	/^#define REQUIRE_EQ(/;"	d
REQUIRE_FALSE	lib/doctest/doctest.h	/^#define REQUIRE_FALSE(/;"	d
REQUIRE_FALSE	tests/embed/src/doctestx.h	/^#define REQUIRE_FALSE(/;"	d
REQUIRE_FALSE_MESSAGE	lib/doctest/doctest.h	/^#define REQUIRE_FALSE_MESSAGE(/;"	d
REQUIRE_FALSE_MESSAGE	tests/embed/src/doctestx.h	/^#define REQUIRE_FALSE_MESSAGE(/;"	d
REQUIRE_GE	lib/doctest/doctest.h	/^#define REQUIRE_GE(/;"	d
REQUIRE_GE	tests/embed/src/doctestx.h	/^#define REQUIRE_GE(/;"	d
REQUIRE_GT	lib/doctest/doctest.h	/^#define REQUIRE_GT(/;"	d
REQUIRE_GT	tests/embed/src/doctestx.h	/^#define REQUIRE_GT(/;"	d
REQUIRE_LE	lib/doctest/doctest.h	/^#define REQUIRE_LE(/;"	d
REQUIRE_LE	tests/embed/src/doctestx.h	/^#define REQUIRE_LE(/;"	d
REQUIRE_LT	lib/doctest/doctest.h	/^#define REQUIRE_LT(/;"	d
REQUIRE_LT	tests/embed/src/doctestx.h	/^#define REQUIRE_LT(/;"	d
REQUIRE_MESSAGE	lib/doctest/doctest.h	/^#define REQUIRE_MESSAGE(/;"	d
REQUIRE_MESSAGE	tests/embed/src/doctestx.h	/^#define REQUIRE_MESSAGE(/;"	d
REQUIRE_NE	lib/doctest/doctest.h	/^#define REQUIRE_NE(/;"	d
REQUIRE_NE	tests/embed/src/doctestx.h	/^#define REQUIRE_NE(/;"	d
REQUIRE_NOTHROW	lib/doctest/doctest.h	/^#define REQUIRE_NOTHROW(/;"	d
REQUIRE_NOTHROW	tests/embed/src/doctestx.h	/^#define REQUIRE_NOTHROW(/;"	d
REQUIRE_NOTHROW_MESSAGE	lib/doctest/doctest.h	/^#define REQUIRE_NOTHROW_MESSAGE(/;"	d
REQUIRE_NOTHROW_MESSAGE	tests/embed/src/doctestx.h	/^#define REQUIRE_NOTHROW_MESSAGE(/;"	d
REQUIRE_THROWS	lib/doctest/doctest.h	/^#define REQUIRE_THROWS(/;"	d
REQUIRE_THROWS	tests/embed/src/doctestx.h	/^#define REQUIRE_THROWS(/;"	d
REQUIRE_THROWS_AS	lib/doctest/doctest.h	/^#define REQUIRE_THROWS_AS(/;"	d
REQUIRE_THROWS_AS	tests/embed/src/doctestx.h	/^#define REQUIRE_THROWS_AS(/;"	d
REQUIRE_THROWS_AS_MESSAGE	lib/doctest/doctest.h	/^#define REQUIRE_THROWS_AS_MESSAGE(/;"	d
REQUIRE_THROWS_AS_MESSAGE	tests/embed/src/doctestx.h	/^#define REQUIRE_THROWS_AS_MESSAGE(/;"	d
REQUIRE_THROWS_MESSAGE	lib/doctest/doctest.h	/^#define REQUIRE_THROWS_MESSAGE(/;"	d
REQUIRE_THROWS_MESSAGE	tests/embed/src/doctestx.h	/^#define REQUIRE_THROWS_MESSAGE(/;"	d
REQUIRE_THROWS_WITH	lib/doctest/doctest.h	/^#define REQUIRE_THROWS_WITH(/;"	d
REQUIRE_THROWS_WITH	tests/embed/src/doctestx.h	/^#define REQUIRE_THROWS_WITH(/;"	d
REQUIRE_THROWS_WITH_AS	lib/doctest/doctest.h	/^#define REQUIRE_THROWS_WITH_AS(/;"	d
REQUIRE_THROWS_WITH_AS	tests/embed/src/doctestx.h	/^#define REQUIRE_THROWS_WITH_AS(/;"	d
REQUIRE_THROWS_WITH_AS_MESSAGE	lib/doctest/doctest.h	/^#define REQUIRE_THROWS_WITH_AS_MESSAGE(/;"	d
REQUIRE_THROWS_WITH_AS_MESSAGE	tests/embed/src/doctestx.h	/^#define REQUIRE_THROWS_WITH_AS_MESSAGE(/;"	d
REQUIRE_THROWS_WITH_MESSAGE	lib/doctest/doctest.h	/^#define REQUIRE_THROWS_WITH_MESSAGE(/;"	d
REQUIRE_THROWS_WITH_MESSAGE	tests/embed/src/doctestx.h	/^#define REQUIRE_THROWS_WITH_MESSAGE(/;"	d
REQUIRE_UNARY	lib/doctest/doctest.h	/^#define REQUIRE_UNARY(/;"	d
REQUIRE_UNARY	tests/embed/src/doctestx.h	/^#define REQUIRE_UNARY(/;"	d
REQUIRE_UNARY_FALSE	lib/doctest/doctest.h	/^#define REQUIRE_UNARY_FALSE(/;"	d
REQUIRE_UNARY_FALSE	tests/embed/src/doctestx.h	/^#define REQUIRE_UNARY_FALSE(/;"	d
RF69	lib/arch-stm32/jee-rf69.h	/^        RF69 () {}$/;"	f	struct:jeeh::RF69
RF69	lib/arch-stm32/jee-rf69.h	/^        RF69 (SPI bus) : spi (bus) {}$/;"	f	struct:jeeh::RF69
RF69	lib/arch-stm32/jee-rf69.h	/^    struct RF69 {$/;"	s	namespace:jeeh
RF69	lib/arch-stm32/mod-machine.cpp	/^struct RF69 : Object, jeeh::RF69<jeeh::SpiGpio> {$/;"	s	file:
RNG	lib/arch-stm32/prelude.h	/^    RNG                   =  80,  \/\/ RNG$/;"	m	struct:IrqVec
RNG	lib/arch-stm32/prelude.h	/^constexpr auto RNG           = 0x50060800;  \/\/ RNG$/;"	v
RNG	lib/hall-stm32/hall.h	/^        constexpr Io32  <0x50060800> RNG;$/;"	m	namespace:hall::dev
RNG	lib/mcu/prelude.h	/^    RNG                   =  80,  \/\/ RNG$/;"	m	struct:IrqVec
RNG	lib/mcu/prelude.h	/^constexpr auto RNG           = 0x50060800;  \/\/ RNG$/;"	v
RTC	lib/arch-stm32/prelude.h	/^constexpr auto RTC           = 0x40002800;  \/\/ RTC$/;"	v
RTC	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40002800> RTC;$/;"	m	namespace:hall::dev
RTC	lib/mcu/prelude.h	/^constexpr auto RTC           = 0x40002800;  \/\/ RTC$/;"	v
RTC_ALARM	lib/arch-stm32/prelude.h	/^    RTC_ALARM             =  41,  \/\/ RTC$/;"	m	struct:IrqVec
RTC_ALARM	lib/mcu/prelude.h	/^    RTC_ALARM             =  41,  \/\/ RTC$/;"	m	struct:IrqVec
RTC_TAMP_STAMP	lib/arch-stm32/prelude.h	/^    RTC_TAMP_STAMP        =   2,  \/\/ RTC$/;"	m	struct:IrqVec
RTC_TAMP_STAMP	lib/mcu/prelude.h	/^    RTC_TAMP_STAMP        =   2,  \/\/ RTC$/;"	m	struct:IrqVec
RTC_WKUP	lib/arch-stm32/prelude.h	/^    RTC_WKUP              =   3,  \/\/ RTC$/;"	m	struct:IrqVec
RTC_WKUP	lib/mcu/prelude.h	/^    RTC_WKUP              =   3,  \/\/ RTC$/;"	m	struct:IrqVec
RXSIZE	lib/hall-stm32/stm32l4-uart.cpp	/^    constexpr static auto RXSIZE = sizeof (pool::Buf);$/;"	m	struct:Uart	file:
RaiseFrom	lib/pyvm/pyvm.cpp	/^    RaiseFrom              = 0x66,$/;"	e	enum:uint8_t	file:
RaiseLast	lib/pyvm/pyvm.cpp	/^    RaiseLast              = 0x64,$/;"	e	enum:uint8_t	file:
RaiseObj	lib/pyvm/pyvm.cpp	/^    RaiseObj               = 0x65,$/;"	e	enum:uint8_t	file:
Range	lib/monty/monty.h	/^        Range (int from, int to, int by) : _from (from), _to (to), _by (by) {}$/;"	f	struct:monty::Range
Range	lib/monty/monty.h	/^        auto asRange (int sz) const -> Range;$/;"	m	struct:monty::Slice
Range	lib/monty/monty.h	/^    struct Range : Object {$/;"	s	namespace:monty
RawIter	lib/monty/monty.h	/^        RawIter (Value obj, Value pos ={})$/;"	f	struct:monty::RawIter
RawIter	lib/monty/monty.h	/^        inline auto begin () const -> RawIter;$/;"	m	struct:monty::Value
RawIter	lib/monty/monty.h	/^        inline auto end () const -> RawIter;$/;"	m	struct:monty::Value
RawIter	lib/monty/monty.h	/^    struct RawIter {$/;"	s	namespace:monty
Rect	lib/graphics/twodee.h	/^        Rect (Point p, unsigned w, unsigned h)$/;"	f	struct:twodee::Rect
Rect	lib/graphics/twodee.h	/^        Rect (Point p1, Point p2)$/;"	f	struct:twodee::Rect
Rect	lib/graphics/twodee.h	/^        Rect (int x, int y, unsigned w, unsigned h)$/;"	f	struct:twodee::Rect
Rect	lib/graphics/twodee.h	/^    struct Rect : Point {$/;"	s	namespace:twodee
Red	lib/doctest/doctest.h	/^        Red,$/;"	e	enum:doctest::Color::Enum
Red	tests/embed/src/doctestx.h	/^        Red,$/;"	e	enum:doctest::Color::Enum
ReturnValue	lib/pyvm/pyvm.cpp	/^    ReturnValue            = 0x63,$/;"	e	enum:uint8_t	file:
RotThree	lib/pyvm/pyvm.cpp	/^    RotThree               = 0x5B,$/;"	e	enum:uint8_t	file:
RotTwo	lib/pyvm/pyvm.cpp	/^    RotTwo                 = 0x5A,$/;"	e	enum:uint8_t	file:
Run	lib/graphics/twodee.h	/^        struct Run { uint8_t off, on; };$/;"	s	struct:twodee::Glyph
RuntimeError	lib/monty/monty.h	/^        RuntimeError,        \/\/ Exception$/;"	m	class:monty::E
S	tests/tdd/main.cpp	/^    S () { printf("S%d ()\\n", id); }$/;"	f	struct:S
S	tests/tdd/main.cpp	/^    S (S const& s) { printf("S%d (const& S%d)\\n", id, s.id); }$/;"	f	struct:S
S	tests/tdd/main.cpp	/^    S (S&& s) { printf("S%d(&& S%d)\\n", id, s.id); }$/;"	f	struct:S
S	tests/tdd/main.cpp	/^struct S {$/;"	s	file:
SAI1	lib/arch-stm32/prelude.h	/^    SAI1                  =  74,  \/\/ SAI$/;"	m	struct:IrqVec
SAI1	lib/arch-stm32/prelude.h	/^constexpr auto SAI1          = 0x40015400;  \/\/ SAI$/;"	v
SAI1	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40015400> SAI1;$/;"	m	namespace:hall::dev
SAI1	lib/mcu/prelude.h	/^    SAI1                  =  74,  \/\/ SAI$/;"	m	struct:IrqVec
SAI1	lib/mcu/prelude.h	/^constexpr auto SAI1          = 0x40015400;  \/\/ SAI$/;"	v
SCB	lib/arch-stm32/prelude.h	/^constexpr auto SCB           = 0xE000ED00;  \/\/ SCB$/;"	v
SCB	lib/hall-stm32/hall.h	/^        constexpr Io32  <0xE000ED00> SCB;$/;"	m	namespace:hall::dev
SCB	lib/mcu/prelude.h	/^constexpr auto SCB           = 0xE000ED00;  \/\/ SCB$/;"	v
SCB_ACTRL	lib/arch-stm32/prelude.h	/^constexpr auto SCB_ACTRL     = 0xE000E008;  \/\/ SCB$/;"	v
SCB_ACTRL	lib/hall-stm32/hall.h	/^        constexpr Io32  <0xE000E008> SCB_ACTRL;$/;"	m	namespace:hall::dev
SCB_ACTRL	lib/mcu/prelude.h	/^constexpr auto SCB_ACTRL     = 0xE000E008;  \/\/ SCB$/;"	v
SCENARIO	lib/doctest/doctest.h	/^#define SCENARIO(/;"	d
SCENARIO	tests/embed/src/doctestx.h	/^#define SCENARIO(/;"	d
SCENARIO_CLASS	lib/doctest/doctest.h	/^#define SCENARIO_CLASS(/;"	d
SCENARIO_CLASS	tests/embed/src/doctestx.h	/^#define SCENARIO_CLASS(/;"	d
SCENARIO_TEMPLATE	lib/doctest/doctest.h	/^#define SCENARIO_TEMPLATE(/;"	d
SCENARIO_TEMPLATE	tests/embed/src/doctestx.h	/^#define SCENARIO_TEMPLATE(/;"	d
SCENARIO_TEMPLATE_DEFINE	lib/doctest/doctest.h	/^#define SCENARIO_TEMPLATE_DEFINE(/;"	d
SCENARIO_TEMPLATE_DEFINE	tests/embed/src/doctestx.h	/^#define SCENARIO_TEMPLATE_DEFINE(/;"	d
SCR	lib/arch-stm32/uart-f4.h	/^    enum { LISR=0x00,LIFCR=0x08,SCR=0x10,SNDTR=0x14,SPAR=0x18,SM0AR=0x1C };$/;"	e	enum:Uart::__anon21
SCR	lib/mcu/uart-stm32f4f7.h	/^    enum { LISR=0x00,LIFCR=0x08,SCR=0x10,SNDTR=0x14,SPAR=0x18,SM0AR=0x1C };$/;"	e	enum:Uart::__anon32
SDMMC	lib/arch-stm32/prelude.h	/^constexpr auto SDMMC         = 0x40012800;  \/\/ SDIO$/;"	v
SDMMC	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40012800> SDMMC;$/;"	m	namespace:hall::dev
SDMMC	lib/mcu/prelude.h	/^constexpr auto SDMMC         = 0x40012800;  \/\/ SDIO$/;"	v
SDMMC1	lib/arch-stm32/prelude.h	/^    SDMMC1                =  49,  \/\/ SDIO$/;"	m	struct:IrqVec
SDMMC1	lib/mcu/prelude.h	/^    SDMMC1                =  49,  \/\/ SDIO$/;"	m	struct:IrqVec
SET0	tests/gpio/gpio.cpp	/^        enum { LEV0=0x34, SET0=0x1C, CLR0=0x28 };$/;"	e	enum:gpio::Pin::__anon37	file:
SFINAE_OP	lib/doctest/doctest.h	/^#define SFINAE_OP(/;"	d
SFINAE_OP	tests/embed/src/doctestx.h	/^#define SFINAE_OP(/;"	d
SHOW_INSTR_PTR	lib/pyvm/pyvm.cpp	/^#define SHOW_INSTR_PTR /;"	d	file:
SIZE	tests/buffers/main.cpp	/^        constexpr static auto SIZE = 512;$/;"	m	struct:buf::Buf	file:
SKIP	lib/monty/parser.h	/^            IHEX, SKIP, END, STR, ESC, STRX, STRU, NUM, WORD, ARGS };$/;"	m	struct:Parser	typeref:enum:Parser::
SM0AR	lib/arch-stm32/uart-f4.h	/^    enum { LISR=0x00,LIFCR=0x08,SCR=0x10,SNDTR=0x14,SPAR=0x18,SM0AR=0x1C };$/;"	e	enum:Uart::__anon21
SM0AR	lib/mcu/uart-stm32f4f7.h	/^    enum { LISR=0x00,LIFCR=0x08,SCR=0x10,SNDTR=0x14,SPAR=0x18,SM0AR=0x1C };$/;"	e	enum:Uart::__anon32
SNDTR	lib/arch-stm32/uart-f4.h	/^    enum { LISR=0x00,LIFCR=0x08,SCR=0x10,SNDTR=0x14,SPAR=0x18,SM0AR=0x1C };$/;"	e	enum:Uart::__anon21
SNDTR	lib/mcu/uart-stm32f4f7.h	/^    enum { LISR=0x00,LIFCR=0x08,SCR=0x10,SNDTR=0x14,SPAR=0x18,SM0AR=0x1C };$/;"	e	enum:Uart::__anon32
SPAR	lib/arch-stm32/uart-f4.h	/^    enum { LISR=0x00,LIFCR=0x08,SCR=0x10,SNDTR=0x14,SPAR=0x18,SM0AR=0x1C };$/;"	e	enum:Uart::__anon21
SPAR	lib/mcu/uart-stm32f4f7.h	/^    enum { LISR=0x00,LIFCR=0x08,SCR=0x10,SNDTR=0x14,SPAR=0x18,SM0AR=0x1C };$/;"	e	enum:Uart::__anon32
SPI1	lib/arch-stm32/prelude.h	/^    SPI1                  =  35,  \/\/ SPI$/;"	m	struct:IrqVec
SPI1	lib/arch-stm32/prelude.h	/^constexpr auto SPI1          = 0x40013000;  \/\/ SPI$/;"	v
SPI1	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40013000> SPI1;$/;"	m	namespace:hall::dev
SPI1	lib/mcu/prelude.h	/^    SPI1                  =  35,  \/\/ SPI$/;"	m	struct:IrqVec
SPI1	lib/mcu/prelude.h	/^constexpr auto SPI1          = 0x40013000;  \/\/ SPI$/;"	v
SPI2	lib/arch-stm32/prelude.h	/^    SPI2                  =  36,  \/\/ SPI$/;"	m	struct:IrqVec
SPI2	lib/arch-stm32/prelude.h	/^constexpr auto SPI2          = 0x40003800;  \/\/ SPI$/;"	v
SPI2	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40003800> SPI2;$/;"	m	namespace:hall::dev
SPI2	lib/mcu/prelude.h	/^    SPI2                  =  36,  \/\/ SPI$/;"	m	struct:IrqVec
SPI2	lib/mcu/prelude.h	/^constexpr auto SPI2          = 0x40003800;  \/\/ SPI$/;"	v
SPI3	lib/arch-stm32/prelude.h	/^    SPI3                  =  51,  \/\/ SPI$/;"	m	struct:IrqVec
SPI3	lib/arch-stm32/prelude.h	/^constexpr auto SPI3          = 0x40003C00;  \/\/ SPI$/;"	v
SPI3	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40003C00> SPI3;$/;"	m	namespace:hall::dev
SPI3	lib/mcu/prelude.h	/^    SPI3                  =  51,  \/\/ SPI$/;"	m	struct:IrqVec
SPI3	lib/mcu/prelude.h	/^constexpr auto SPI3          = 0x40003C00;  \/\/ SPI$/;"	v
SPREAD	lib/monty/monty.h	/^        static constexpr auto SPREAD = 1<<16; \/\/ if "*arg" or "**kw" present$/;"	m	struct:monty::ArgVec
SR	lib/arch-stm32/uart-f1.h	/^    enum { SR=0x00,DR=0x04,BRR=0x08,CR1=0x0C,CR3=0x14 };$/;"	e	enum:Uart::__anon12
SR	lib/arch-stm32/uart-f4.h	/^    enum { SR=0x00,DR=0x04,BRR=0x08,CR1=0x0C,CR3=0x14 };$/;"	e	enum:Uart::__anon20
SR	lib/arch-stm32/uart-l0.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon16
SR	lib/arch-stm32/uart-l4.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon18
SR	lib/hall-stm32/stm32l4-uart.cpp	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon3	file:
SR	lib/mcu/uart-stm32f4f7.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon31
SR	lib/mcu/uart-stm32f4f7.h	/^    enum { SR=0x00,RDR=0x04,TDR=0x04,BRR=0x08,CR1=0x0C,CR3=0x14 };$/;"	e	enum:Uart::__anon30
SR	lib/mcu/uart-stm32l4.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon28
SRCS	src/Makefile	/^SRCS = $(wildcard *.cpp) $(foreach D,$(DIRS),$(wildcard $(LIBS)\/$D\/*.cpp))$/;"	m
SRCS	tests/buffers/Makefile	/^SRCS = $(wildcard *.cpp) $(foreach D,$(DIRS),$(wildcard $(LIBS)\/$D\/*.cpp))$/;"	m
SRCS	tests/gpio/Makefile	/^SRCS = $(wildcard *.cpp) $(foreach D,$(DIRS),$(wildcard $(LIBS)\/$D\/*.cpp))$/;"	m
SRCS	tests/native/Makefile	/^SRCS = $(wildcard *.cpp) $(foreach D,$(DIRS),$(wildcard $(LIBS)\/$D\/*.cpp))$/;"	m
SRCS	tests/tdd/Makefile	/^SRCS = $(wildcard *.cpp) $(foreach D,$(DIRS),$(wildcard $(LIBS)\/$D\/*.cpp))$/;"	m
START_TX	lib/arch-stm32/jee-rf69.h	/^            START_TX          = 0xC2,$/;"	e	enum:jeeh::RF69::__anon25
STDOUT_FILENO	lib/doctest/doctest.h	/^#define STDOUT_FILENO /;"	d
STDOUT_FILENO	tests/embed/src/doctestx.h	/^#define STDOUT_FILENO /;"	d
STK	lib/arch-stm32/prelude.h	/^constexpr auto STK           = 0xE000E010;  \/\/ STK$/;"	v
STK	lib/hall-stm32/hall.h	/^        constexpr Io32  <0xE000E010> STK;$/;"	m	namespace:hall::dev
STK	lib/mcu/prelude.h	/^constexpr auto STK           = 0xE000E010;  \/\/ STK$/;"	v
STM	lib/hall-stm32/hall.h	/^    enum struct STM { F1, F3, F4, F7, G0, H7, L0, L4 };$/;"	s	namespace:hall
STM_F4	lib/mcu/mcu.h	/^    enum ARM_Family { STM_F4, STM_F7, STM_L0, STM_L4 };$/;"	e	enum:mcu::ARM_Family
STM_F7	lib/mcu/mcu.h	/^    enum ARM_Family { STM_F4, STM_F7, STM_L0, STM_L4 };$/;"	e	enum:mcu::ARM_Family
STM_L0	lib/mcu/mcu.h	/^    enum ARM_Family { STM_F4, STM_F7, STM_L0, STM_L4 };$/;"	e	enum:mcu::ARM_Family
STM_L4	lib/mcu/mcu.h	/^    enum ARM_Family { STM_F4, STM_F7, STM_L0, STM_L4 };$/;"	e	enum:mcu::ARM_Family
STOP_TX	lib/arch-stm32/jee-rf69.h	/^            STOP_TX           = 0x42,$/;"	e	enum:jeeh::RF69::__anon25
STR	lib/monty/parser.h	/^            IHEX, SKIP, END, STR, ESC, STRX, STRU, NUM, WORD, ARGS };$/;"	m	struct:Parser	typeref:enum:Parser::
STRU	lib/monty/parser.h	/^            IHEX, SKIP, END, STR, ESC, STRX, STRU, NUM, WORD, ARGS };$/;"	m	struct:Parser	typeref:enum:Parser::
STRX	lib/monty/parser.h	/^            IHEX, SKIP, END, STR, ESC, STRX, STRU, NUM, WORD, ARGS };$/;"	m	struct:Parser	typeref:enum:Parser::
SUBCASE	lib/doctest/doctest.h	/^#define SUBCASE(/;"	d
SUBCASE	tests/embed/src/doctestx.h	/^#define SUBCASE(/;"	d
SWPMI1	lib/arch-stm32/prelude.h	/^    SWPMI1                =  76,  \/\/ SWPMI$/;"	m	struct:IrqVec
SWPMI1	lib/arch-stm32/prelude.h	/^constexpr auto SWPMI1        = 0x40008800;  \/\/ SWPMI$/;"	v
SWPMI1	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40008800> SWPMI1;$/;"	m	namespace:hall::dev
SWPMI1	lib/mcu/prelude.h	/^    SWPMI1                =  76,  \/\/ SWPMI$/;"	m	struct:IrqVec
SWPMI1	lib/mcu/prelude.h	/^constexpr auto SWPMI1        = 0x40008800;  \/\/ SWPMI$/;"	v
SYSCFG	lib/arch-stm32/prelude.h	/^constexpr auto SYSCFG        = 0x40010000;  \/\/ SYSCFG$/;"	v
SYSCFG	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40010000> SYSCFG;$/;"	m	namespace:hall::dev
SYSCFG	lib/mcu/prelude.h	/^constexpr auto SYSCFG        = 0x40010000;  \/\/ SYSCFG$/;"	v
Serial	lib/mcu/mcu.h	/^        Serial (int num, char const* pins =nullptr) : T (num) {$/;"	f	struct:mcu::Serial
Serial	lib/mcu/mcu.h	/^    struct Serial : Stream, private T {$/;"	s	namespace:mcu
Set	lib/monty/monty.h	/^    struct Set : List {$/;"	s	namespace:monty
SetupExcept	lib/pyvm/pyvm.cpp	/^    SetupExcept            = 0x48,$/;"	e	enum:uint8_t	file:
SetupFinally	lib/pyvm/pyvm.cpp	/^    SetupFinally           = 0x49,$/;"	e	enum:uint8_t	file:
SetupWith	lib/pyvm/pyvm.cpp	/^    SetupWith              = 0x47,$/;"	e	enum:uint8_t	file:
SizeFix	lib/monty/builtin.cpp	/^    SizeFix (Exception& exc) : _exc (exc), _orig (exc._fill) {$/;"	f	struct:SizeFix
SizeFix	lib/monty/builtin.cpp	/^struct SizeFix {$/;"	s	file:
Slice	lib/monty/monty.h	/^        Slice (Value off, Value num, Value step)$/;"	f	struct:monty::Slice
Slice	lib/monty/monty.h	/^    struct Slice : Object {$/;"	s	namespace:monty
Slot	tests/native/memTest.cpp	/^    struct Slot {$/;"	s	namespace:mem::vec	file:
Spi	lib/arch-stm32/mod-machine.cpp	/^struct Spi : Object, jeeh::SpiGpio {$/;"	s	file:
SpiFlash	lib/mcu/mcu.h	/^    struct SpiFlash : private SpiGpio {$/;"	s	namespace:mcu
SpiGpio	lib/arch-stm32/jee-stm32.h	/^        constexpr SpiGpio () {}$/;"	f	struct:jeeh::SpiGpio
SpiGpio	lib/arch-stm32/jee-stm32.h	/^        constexpr SpiGpio (Pin mo, Pin mi, Pin ck, Pin ss, int cp =0)$/;"	f	struct:jeeh::SpiGpio
SpiGpio	lib/arch-stm32/jee-stm32.h	/^    struct SpiGpio {$/;"	s	namespace:jeeh
SpiGpio	lib/mcu/mcu.h	/^    struct SpiGpio {$/;"	s	namespace:mcu
Stacker	lib/monty/stack.cpp	/^struct Stacker : boss::Device {$/;"	s	file:
Stacklet	lib/monty/monty.h	/^    struct Stacklet : List {$/;"	s	namespace:monty
StaticObj	lib/monty/monty.h	/^    struct StaticObj : Object {$/;"	s	namespace:monty
StopIteration	lib/monty/monty.h	/^        StopIteration,       \/\/ Exception$/;"	m	class:monty::E
StoreAttr	lib/pyvm/pyvm.cpp	/^    StoreAttr              = 0x18,$/;"	e	enum:uint8_t	file:
StoreComp	lib/pyvm/pyvm.cpp	/^    StoreComp              = 0x2F,$/;"	e	enum:uint8_t	file:
StoreDeref	lib/pyvm/pyvm.cpp	/^    StoreDeref             = 0x27,$/;"	e	enum:uint8_t	file:
StoreFastMulti	lib/pyvm/pyvm.cpp	/^    StoreFastMulti         = 0xC0,$/;"	e	enum:uint8_t	file:
StoreFastN	lib/pyvm/pyvm.cpp	/^    StoreFastN             = 0x26,$/;"	e	enum:uint8_t	file:
StoreGlobal	lib/pyvm/pyvm.cpp	/^    StoreGlobal            = 0x17,$/;"	e	enum:uint8_t	file:
StoreMap	lib/pyvm/pyvm.cpp	/^    StoreMap               = 0x62,$/;"	e	enum:uint8_t	file:
StoreName	lib/pyvm/pyvm.cpp	/^    StoreName              = 0x16,$/;"	e	enum:uint8_t	file:
StoreSubscr	lib/pyvm/pyvm.cpp	/^    StoreSubscr            = 0x56,$/;"	e	enum:uint8_t	file:
Str	lib/monty/monty.h	/^        enum Tag { Nil, Int, Str, Obj };$/;"	e	enum:monty::Value::Tag
Str	lib/monty/monty.h	/^    struct Str : Bytes {$/;"	s	namespace:monty
Str	lib/monty/type.cpp	/^Str::Str (char const* s, int n)$/;"	f	class:Str
Stream	lib/mcu/mcu.h	/^    struct Stream {$/;"	s	namespace:mcu
String	lib/doctest/doctest.h	/^class DOCTEST_INTERFACE String$/;"	c	namespace:doctest
String	tests/embed/src/doctestx.h	/^class DOCTEST_INTERFACE String$/;"	c	namespace:doctest
StringIO	src/xmltodict.py	/^        from StringIO import StringIO$/;"	i
StringIO	src/xmltodict.py	/^        from io import StringIO$/;"	i
StringIO	src/xmltodict.py	/^    from cStringIO import StringIO$/;"	i
SubcaseSignature	lib/doctest/doctest.h	/^struct DOCTEST_INTERFACE SubcaseSignature$/;"	s	namespace:doctest
SubcaseSignature	tests/embed/src/doctestx.h	/^struct DOCTEST_INTERFACE SubcaseSignature$/;"	s	namespace:doctest
Super	lib/monty/monty.h	/^        Super (Value sclass, Value sinst) : _sclass (sclass), _sinst (sinst) {}$/;"	f	struct:monty::Super
Super	lib/monty/monty.h	/^    struct Super : Object {$/;"	s	namespace:monty
SysTick_Handler	lib/hall-stm32/hall.cpp	/^    extern "C" void SysTick_Handler () {$/;"	f
SysTick_Handler	tests/smoke/src/main2.cpp	/^extern "C" void SysTick_Handler(void) {}$/;"	f
SysTick_Handler	tests/smoke/src/main3.cpp	/^extern "C" void SysTick_Handler(void) {}$/;"	f
TAG	src/codegen.py	/^def TAG(block, *args):$/;"	f
TDR	lib/arch-stm32/uart-l0.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon16
TDR	lib/arch-stm32/uart-l4.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon18
TDR	lib/hall-stm32/stm32l4-uart.cpp	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon3	file:
TDR	lib/mcu/uart-stm32f4f7.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon31
TDR	lib/mcu/uart-stm32f4f7.h	/^    enum { SR=0x00,RDR=0x04,TDR=0x04,BRR=0x08,CR1=0x0C,CR3=0x14 };$/;"	e	enum:Uart::__anon30
TDR	lib/mcu/uart-stm32l4.h	/^    enum { CR1=0x00,CR3=0x08,BRR=0x0C,SR=0x1C,CR=0x20,RDR=0x24,TDR=0x28 };$/;"	e	enum:Uart::__anon28
TEST_ASSERT_EQUAL_INT64	tests/unit/array/main.cpp	/^#define TEST_ASSERT_EQUAL_INT64(/;"	d	file:
TEST_ASSERT_EQUAL_INT64	tests/unit/array/main.cpp	/^#undef TEST_ASSERT_EQUAL_INT64$/;"	d	file:
TEST_ASSERT_EQUAL_INT64	tests/unit/data/main.cpp	/^#define TEST_ASSERT_EQUAL_INT64(/;"	d	file:
TEST_ASSERT_EQUAL_INT64	tests/unit/data/main.cpp	/^#undef TEST_ASSERT_EQUAL_INT64$/;"	d	file:
TEST_CASE	lib/doctest/doctest.h	/^#define TEST_CASE(/;"	d
TEST_CASE	tests/embed/src/doctestx.h	/^#define TEST_CASE(/;"	d
TEST_CASE_CLASS	lib/doctest/doctest.h	/^#define TEST_CASE_CLASS(/;"	d
TEST_CASE_CLASS	tests/embed/src/doctestx.h	/^#define TEST_CASE_CLASS(/;"	d
TEST_CASE_FIXTURE	lib/doctest/doctest.h	/^#define TEST_CASE_FIXTURE(/;"	d
TEST_CASE_FIXTURE	tests/embed/src/doctestx.h	/^#define TEST_CASE_FIXTURE(/;"	d
TEST_CASE_TEMPLATE	lib/doctest/doctest.h	/^#define TEST_CASE_TEMPLATE(/;"	d
TEST_CASE_TEMPLATE	tests/embed/src/doctestx.h	/^#define TEST_CASE_TEMPLATE(/;"	d
TEST_CASE_TEMPLATE_APPLY	lib/doctest/doctest.h	/^#define TEST_CASE_TEMPLATE_APPLY(/;"	d
TEST_CASE_TEMPLATE_APPLY	tests/embed/src/doctestx.h	/^#define TEST_CASE_TEMPLATE_APPLY(/;"	d
TEST_CASE_TEMPLATE_DEFINE	lib/doctest/doctest.h	/^#define TEST_CASE_TEMPLATE_DEFINE(/;"	d
TEST_CASE_TEMPLATE_DEFINE	tests/embed/src/doctestx.h	/^#define TEST_CASE_TEMPLATE_DEFINE(/;"	d
TEST_CASE_TEMPLATE_INSTANTIATE	lib/doctest/doctest.h	/^#define TEST_CASE_TEMPLATE_INSTANTIATE(/;"	d
TEST_CASE_TEMPLATE_INSTANTIATE	tests/embed/src/doctestx.h	/^#define TEST_CASE_TEMPLATE_INSTANTIATE(/;"	d
TEST_CASE_TEMPLATE_INVOKE	lib/doctest/doctest.h	/^#define TEST_CASE_TEMPLATE_INVOKE(/;"	d
TEST_CASE_TEMPLATE_INVOKE	tests/embed/src/doctestx.h	/^#define TEST_CASE_TEMPLATE_INVOKE(/;"	d
TEST_SUITE	lib/doctest/doctest.h	/^#define TEST_SUITE(/;"	d
TEST_SUITE	tests/embed/src/doctestx.h	/^#define TEST_SUITE(/;"	d
TEST_SUITE_BEGIN	lib/doctest/doctest.h	/^#define TEST_SUITE_BEGIN(/;"	d
TEST_SUITE_BEGIN	tests/embed/src/doctestx.h	/^#define TEST_SUITE_BEGIN(/;"	d
TEST_SUITE_END	lib/doctest/doctest.h	/^#define TEST_SUITE_END /;"	d
TEST_SUITE_END	tests/embed/src/doctestx.h	/^#define TEST_SUITE_END /;"	d
THEN	lib/doctest/doctest.h	/^#define THEN(/;"	d
THEN	tests/embed/src/doctestx.h	/^#define THEN(/;"	d
TIM1	lib/arch-stm32/prelude.h	/^constexpr auto TIM1          = 0x40012C00;  \/\/ TIM$/;"	v
TIM1	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40012C00> TIM1;$/;"	m	namespace:hall::dev
TIM1	lib/mcu/prelude.h	/^constexpr auto TIM1          = 0x40012C00;  \/\/ TIM$/;"	v
TIM15	lib/arch-stm32/prelude.h	/^constexpr auto TIM15         = 0x40014000;  \/\/ TIM$/;"	v
TIM15	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40014000> TIM15;$/;"	m	namespace:hall::dev
TIM15	lib/mcu/prelude.h	/^constexpr auto TIM15         = 0x40014000;  \/\/ TIM$/;"	v
TIM16	lib/arch-stm32/prelude.h	/^constexpr auto TIM16         = 0x40014400;  \/\/ TIM$/;"	v
TIM16	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40014400> TIM16;$/;"	m	namespace:hall::dev
TIM16	lib/mcu/prelude.h	/^constexpr auto TIM16         = 0x40014400;  \/\/ TIM$/;"	v
TIM1_BRK_TIM15	lib/arch-stm32/prelude.h	/^    TIM1_BRK_TIM15        =  24,  \/\/ TIM$/;"	m	struct:IrqVec
TIM1_BRK_TIM15	lib/mcu/prelude.h	/^    TIM1_BRK_TIM15        =  24,  \/\/ TIM$/;"	m	struct:IrqVec
TIM1_CC	lib/arch-stm32/prelude.h	/^    TIM1_CC               =  27,  \/\/ TIM$/;"	m	struct:IrqVec
TIM1_CC	lib/mcu/prelude.h	/^    TIM1_CC               =  27,  \/\/ TIM$/;"	m	struct:IrqVec
TIM1_TRG_COM	lib/arch-stm32/prelude.h	/^    TIM1_TRG_COM          =  26,  \/\/ TIM$/;"	m	struct:IrqVec
TIM1_TRG_COM	lib/mcu/prelude.h	/^    TIM1_TRG_COM          =  26,  \/\/ TIM$/;"	m	struct:IrqVec
TIM1_UP_TIM16	lib/arch-stm32/prelude.h	/^    TIM1_UP_TIM16         =  25,  \/\/ TIM$/;"	m	struct:IrqVec
TIM1_UP_TIM16	lib/mcu/prelude.h	/^    TIM1_UP_TIM16         =  25,  \/\/ TIM$/;"	m	struct:IrqVec
TIM2	lib/arch-stm32/prelude.h	/^    TIM2                  =  28,  \/\/ TIM$/;"	m	struct:IrqVec
TIM2	lib/arch-stm32/prelude.h	/^constexpr auto TIM2          = 0x40000000;  \/\/ TIM$/;"	v
TIM2	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40000000> TIM2;$/;"	m	namespace:hall::dev
TIM2	lib/mcu/prelude.h	/^    TIM2                  =  28,  \/\/ TIM$/;"	m	struct:IrqVec
TIM2	lib/mcu/prelude.h	/^constexpr auto TIM2          = 0x40000000;  \/\/ TIM$/;"	v
TIM3	lib/arch-stm32/prelude.h	/^    TIM3                  =  29,  \/\/ TIM$/;"	m	struct:IrqVec
TIM3	lib/arch-stm32/prelude.h	/^constexpr auto TIM3          = 0x40000400;  \/\/ TIM$/;"	v
TIM3	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40000400> TIM3;$/;"	m	namespace:hall::dev
TIM3	lib/mcu/prelude.h	/^    TIM3                  =  29,  \/\/ TIM$/;"	m	struct:IrqVec
TIM3	lib/mcu/prelude.h	/^constexpr auto TIM3          = 0x40000400;  \/\/ TIM$/;"	v
TIM6	lib/arch-stm32/prelude.h	/^constexpr auto TIM6          = 0x40001000;  \/\/ TIM$/;"	v
TIM6	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40001000> TIM6;$/;"	m	namespace:hall::dev
TIM6	lib/mcu/prelude.h	/^constexpr auto TIM6          = 0x40001000;  \/\/ TIM$/;"	v
TIM6_DACUNDER	lib/arch-stm32/prelude.h	/^    TIM6_DACUNDER         =  54,  \/\/ TIM$/;"	m	struct:IrqVec
TIM6_DACUNDER	lib/mcu/prelude.h	/^    TIM6_DACUNDER         =  54,  \/\/ TIM$/;"	m	struct:IrqVec
TIM7	lib/arch-stm32/prelude.h	/^    TIM7                  =  55,  \/\/ TIM$/;"	m	struct:IrqVec
TIM7	lib/arch-stm32/prelude.h	/^constexpr auto TIM7          = 0x40001400;  \/\/ TIM$/;"	v
TIM7	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40001400> TIM7;$/;"	m	namespace:hall::dev
TIM7	lib/mcu/prelude.h	/^    TIM7                  =  55,  \/\/ TIM$/;"	m	struct:IrqVec
TIM7	lib/mcu/prelude.h	/^constexpr auto TIM7          = 0x40001400;  \/\/ TIM$/;"	v
TO_LVALUE	lib/doctest/doctest.h	/^#define TO_LVALUE(/;"	d
TO_LVALUE	tests/embed/src/doctestx.h	/^#define TO_LVALUE(/;"	d
TR	lib/hall-stm32/stm32l4.cpp	/^        enum { TR=0x00,DR=0x04,CR=0x08,ISR=0x0C,WPR=0x24,BKPR=0x50 };$/;"	e	enum:hall::rtc::__anon5	file:
TSC	lib/arch-stm32/prelude.h	/^    TSC                   =  77,  \/\/ TSC$/;"	m	struct:IrqVec
TSC	lib/arch-stm32/prelude.h	/^constexpr auto TSC           = 0x40024000;  \/\/ TSC$/;"	v
TSC	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40024000> TSC;$/;"	m	namespace:hall::dev
TSC	lib/mcu/prelude.h	/^    TSC                   =  77,  \/\/ TSC$/;"	m	struct:IrqVec
TSC	lib/mcu/prelude.h	/^constexpr auto TSC           = 0x40024000;  \/\/ TSC$/;"	v
TYPE	src/codegen.py	/^def TYPE(block, tag, *_):$/;"	f
TYPER	lib/mcu/mcu.h	/^        enum { MODER=0x00, TYPER=0x04, OSPEEDR=0x08, PUPDR=0x0C, IDR=0x10,$/;"	e	enum:mcu::Pin::__anon27
TYPE_BUILTIN	src/codegen.py	/^def TYPE_BUILTIN(block):$/;"	f
TYPE_INFO	src/codegen.py	/^def TYPE_INFO(block):$/;"	f
TYPE_TO_STRING	lib/doctest/doctest.h	/^#define TYPE_TO_STRING(/;"	d
TYPE_TO_STRING	tests/embed/src/doctestx.h	/^#define TYPE_TO_STRING(/;"	d
Tag	lib/monty/monty.h	/^        enum Tag { Nil, Int, Str, Obj };$/;"	g	struct:monty::Value
TestBuffer	lib/monty/type.cpp	/^    TestBuffer () { bufEnd = buf; }$/;"	f	struct:TestBuffer
TestBuffer	lib/monty/type.cpp	/^struct TestBuffer : Buffer {$/;"	s	file:
TestBuffer	tests/unit/repr/main.cpp	/^    TestBuffer () { bufEnd = buf; }$/;"	f	struct:TestBuffer
TestBuffer	tests/unit/repr/main.cpp	/^struct TestBuffer : Buffer {$/;"	s	file:
TestCase	lib/doctest/doctest.h	/^    struct DOCTEST_INTERFACE TestCase;$/;"	m	namespace:doctest::detail	typeref:struct:doctest::detail::DOCTEST_INTERFACE
TestCase	tests/embed/src/doctestx.h	/^    struct DOCTEST_INTERFACE TestCase;$/;"	m	namespace:doctest::detail	typeref:struct:doctest::detail::DOCTEST_INTERFACE
TestCaseData	lib/doctest/doctest.h	/^struct DOCTEST_INTERFACE TestCaseData$/;"	s	namespace:doctest
TestCaseData	tests/embed/src/doctestx.h	/^struct DOCTEST_INTERFACE TestCaseData$/;"	s	namespace:doctest
TestVec	lib/monty/gc.cpp	/^struct TestVec : Vec {$/;"	s	file:
TestVec	tests/unit/mem/main.cpp	/^struct TestVec : Vec {$/;"	s	file:
Tft	lib/graphics/mod-graphics.cpp	/^struct Tft {$/;"	s	file:
Ticker	lib/arch-stm32/arch.h	/^        Ticker () { installIrq(-1); } \/\/ SysTick$/;"	f	struct:arch::Ticker
Ticker	lib/arch-stm32/arch.h	/^    struct Ticker : Device {$/;"	s	namespace:arch
Ticker	lib/hall-stm32/hall.cpp	/^    struct Ticker : Device {$/;"	s	file:
Tuple	lib/monty/monty.h	/^    struct Tuple : Object, Vector {$/;"	s	namespace:monty
Tuple	lib/monty/type.cpp	/^Tuple::Tuple (ArgVec const& args) {$/;"	f	class:Tuple
Tuple	lib/monty/type.cpp	/^Tuple::Tuple (Value seq) {$/;"	f	class:Tuple
TwoDee	lib/graphics/twodee.h	/^    struct TwoDee : G {$/;"	s	namespace:twodee
Type	lib/monty/monty.h	/^        constexpr Type (Value s, Lookup const* a =nullptr, Factory f =noFactory)$/;"	f	struct:monty::Type
Type	lib/monty/monty.h	/^    struct Type : Dict {$/;"	s	namespace:monty
TypeError	lib/monty/monty.h	/^        TypeError,           \/\/ Exception$/;"	m	class:monty::E
U8G2_FONT_SECTION	lib/graphics/mod-graphics.cpp	/^#define U8G2_FONT_SECTION(/;"	d	file:
UART1	lib/arch-stm32/prelude.h	/^    UART1                 =  37,  \/\/ USART$/;"	m	struct:IrqVec
UART1	lib/arch-stm32/prelude.h	/^constexpr auto UART1         = 0x40013800;  \/\/ USART$/;"	v
UART1	lib/mcu/prelude.h	/^    UART1                 =  37,  \/\/ USART$/;"	m	struct:IrqVec
UART1	lib/mcu/prelude.h	/^constexpr auto UART1         = 0x40013800;  \/\/ USART$/;"	v
UART2	lib/arch-stm32/prelude.h	/^    UART2                 =  38,  \/\/ USART$/;"	m	struct:IrqVec
UART2	lib/arch-stm32/prelude.h	/^constexpr auto UART2         = 0x40004400;  \/\/ USART$/;"	v
UART2	lib/mcu/prelude.h	/^    UART2                 =  38,  \/\/ USART$/;"	m	struct:IrqVec
UART2	lib/mcu/prelude.h	/^constexpr auto UART2         = 0x40004400;  \/\/ USART$/;"	v
UART3	lib/arch-stm32/prelude.h	/^    UART3                 =  39,  \/\/ USART$/;"	m	struct:IrqVec
UART3	lib/arch-stm32/prelude.h	/^constexpr auto UART3         = 0x40004800;  \/\/ USART$/;"	v
UART3	lib/mcu/prelude.h	/^    UART3                 =  39,  \/\/ USART$/;"	m	struct:IrqVec
UART3	lib/mcu/prelude.h	/^constexpr auto UART3         = 0x40004800;  \/\/ USART$/;"	v
UART4	lib/arch-stm32/prelude.h	/^    UART4                 =  52,  \/\/ USART$/;"	m	struct:IrqVec
UART4	lib/arch-stm32/prelude.h	/^constexpr auto UART4         = 0x40004C00;  \/\/ USART$/;"	v
UART4	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40004C00> UART4;$/;"	m	namespace:hall::dev
UART4	lib/mcu/prelude.h	/^    UART4                 =  52,  \/\/ USART$/;"	m	struct:IrqVec
UART4	lib/mcu/prelude.h	/^constexpr auto UART4         = 0x40004C00;  \/\/ USART$/;"	v
USART1	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40013800> USART1;$/;"	m	namespace:hall::dev
USART2	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40004400> USART2;$/;"	m	namespace:hall::dev
USART3	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40004800> USART3;$/;"	m	namespace:hall::dev
USB	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40006800> USB;$/;"	m	namespace:hall::dev
USB_FS	lib/arch-stm32/prelude.h	/^    USB_FS                =  67,  \/\/ USART$/;"	m	struct:IrqVec
USB_FS	lib/arch-stm32/prelude.h	/^constexpr auto USB_FS        = 0x40006800;  \/\/ USART$/;"	v
USB_FS	lib/mcu/prelude.h	/^    USB_FS                =  67,  \/\/ USART$/;"	m	struct:IrqVec
USB_FS	lib/mcu/prelude.h	/^constexpr auto USB_FS        = 0x40006800;  \/\/ USART$/;"	v
USB_SRAM	lib/arch-stm32/prelude.h	/^constexpr auto USB_SRAM      = 0x40006C00;  \/\/ USB$/;"	v
USB_SRAM	lib/mcu/prelude.h	/^constexpr auto USB_SRAM      = 0x40006C00;  \/\/ USB$/;"	v
Uart	lib/arch-stm32/uart-f1.h	/^    Uart (int n) : dev (findDev(uartInfo, n)) { if (dev.num != n) dev.num = 0; }$/;"	f	struct:Uart
Uart	lib/arch-stm32/uart-f1.h	/^struct Uart : Device {$/;"	s
Uart	lib/arch-stm32/uart-f4.h	/^    Uart (int n) : dev (findDev(uartInfo, n)) { if (dev.num != n) dev.num = 0; }$/;"	f	struct:Uart
Uart	lib/arch-stm32/uart-f4.h	/^struct Uart : Device {$/;"	s
Uart	lib/arch-stm32/uart-l0.h	/^    Uart (int n) : dev (findDev(uartInfo, n)) { if (dev.num != n) dev.num = 0; }$/;"	f	struct:Uart
Uart	lib/arch-stm32/uart-l0.h	/^struct Uart : Device {$/;"	s
Uart	lib/arch-stm32/uart-l4.h	/^    Uart (int n) : dev (findDev(uartInfo, n)) { if (dev.num != n) dev.num = 0; }$/;"	f	struct:Uart
Uart	lib/arch-stm32/uart-l4.h	/^struct Uart : Device {$/;"	s
Uart	lib/hall-stm32/stm32l4-uart.cpp	/^    Uart (UartInfo const& d) : dev (d) {}$/;"	f	struct:Uart
Uart	lib/hall-stm32/stm32l4-uart.cpp	/^struct Uart : Device {$/;"	s	file:
Uart	lib/mcu/uart-stm32f4f7.h	/^    Uart (int n) : dev (findDev(uartInfo, n)) { if (dev.num != n) dev.num = 0; }$/;"	f	struct:Uart
Uart	lib/mcu/uart-stm32f4f7.h	/^struct Uart : Device {$/;"	s
Uart	lib/mcu/uart-stm32l4.h	/^    Uart (int n) : dev (findDev(uartInfo, n)) { if (dev.num != n) dev.num = 0; }$/;"	f	struct:Uart
Uart	lib/mcu/uart-stm32l4.h	/^struct Uart : Device {$/;"	s
UartInfo	lib/hall-stm32/stm32l4-uart.cpp	/^struct UartInfo {$/;"	s	file:
UnaryOpMulti	lib/pyvm/pyvm.cpp	/^    UnaryOpMulti           = 0xD0,$/;"	e	enum:uint8_t	file:
UnicodeError	lib/monty/monty.h	/^        UnicodeError,        \/\/ ValueError$/;"	m	class:monty::E
UnpackEx	lib/pyvm/pyvm.cpp	/^    UnpackEx               = 0x31,$/;"	e	enum:uint8_t	file:
UnpackSequence	lib/pyvm/pyvm.cpp	/^    UnpackSequence         = 0x30,$/;"	e	enum:uint8_t	file:
UnwindJump	lib/pyvm/pyvm.cpp	/^    UnwindJump             = 0x40,$/;"	e	enum:uint8_t	file:
UsageFault_Handler	lib/arch-stm32/arch.cpp	/^extern "C" void UsageFault_Handler () { panic("usage fault"); };$/;"	f
V	lib/monty/gc.cpp	/^static void V (Obj const& o, char const* s) {$/;"	f	file:
VERBOSE_GC	lib/monty/gc.cpp	/^#define VERBOSE_GC /;"	d	file:
VERBOSE_LOAD	lib/pyvm/loader.h	/^#define VERBOSE_LOAD /;"	d
VERSION	lib/monty/monty.h	/^    constexpr auto VERSION = "<stripped>";$/;"	m	namespace:monty
VERSION	src/codegen.py	/^def VERSION(block):$/;"	f
VPATH	src/Makefile	/^VPATH = $(patsubst %,$(LIBS)\/%,$(DIRS))$/;"	m
VPATH	tests/buffers/Makefile	/^VPATH = $(patsubst %,$(LIBS)\/%,$(DIRS))$/;"	m
VPATH	tests/gpio/Makefile	/^VPATH = $(patsubst %,$(LIBS)\/%,$(DIRS))$/;"	m
VPATH	tests/native/Makefile	/^VPATH = $(patsubst %,$(LIBS)\/%,$(DIRS))$/;"	m
VPATH	tests/tdd/Makefile	/^VPATH = $(patsubst %,$(LIBS)\/%,$(DIRS))$/;"	m
VREFBUF	lib/arch-stm32/prelude.h	/^constexpr auto VREFBUF       = 0x40010030;  \/\/ VREF$/;"	v
VREFBUF	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40010030> VREFBUF;$/;"	m	namespace:hall::dev
VREFBUF	lib/mcu/prelude.h	/^constexpr auto VREFBUF       = 0x40010030;  \/\/ VREF$/;"	v
VSZ	tests/native/memTest.cpp	/^    constexpr auto VSZ  = sizeof (Slot);$/;"	m	namespace:mem::vec	file:
VS_SZ	lib/monty/gc.cpp	/^constexpr auto VS_SZ  = sizeof (VecSlot);$/;"	v
Value	lib/extend/typ-array.cpp	/^    virtual auto get (ByteVec&, uint32_t) const -> Value  = 0;$/;"	m	struct:Accessor	file:
Value	lib/monty/data.cpp	/^Value::Value (E exc, char const* arg1, Value arg2) {$/;"	f	class:Value
Value	lib/monty/data.cpp	/^Value::Value (char const* arg) : _v ((uintptr_t) arg * 4 + 2) {$/;"	f	class:Value
Value	lib/monty/monty.h	/^            auto operator= (Value v) -> Value;$/;"	m	struct:monty::Dict::Proxy
Value	lib/monty/monty.h	/^            virtual auto objCall (Object&, ArgVec const&) const -> Value = 0;$/;"	m	struct:monty::Method::Base
Value	lib/monty/monty.h	/^        auto append (Value v) -> Value;$/;"	m	struct:monty::List
Value	lib/monty/monty.h	/^        auto at (Value key) const -> Value;$/;"	m	struct:monty::Dict
Value	lib/monty/monty.h	/^        auto binOp (BinOp op, Value rhs) const -> Value;$/;"	m	struct:monty::Value
Value	lib/monty/monty.h	/^        auto items () -> Value;$/;"	m	struct:monty::Dict
Value	lib/monty/monty.h	/^        auto keys () -> Value;$/;"	m	struct:monty::Dict
Value	lib/monty/monty.h	/^        auto operator[] (Q) const -> Value;$/;"	m	struct:monty::Lookup
Value	lib/monty/monty.h	/^        auto parse (ArgVec const&) const -> Value;$/;"	m	struct:monty::Function
Value	lib/monty/monty.h	/^        auto parse (char const*, ...) const -> Value; \/\/ defined in type.cpp$/;"	m	struct:monty::ArgVec
Value	lib/monty/monty.h	/^        auto pop (int idx) -> Value;$/;"	m	struct:monty::List
Value	lib/monty/monty.h	/^        auto set () -> Value;$/;"	m	struct:monty::Event
Value	lib/monty/monty.h	/^        auto sliceGetter (Value k) const -> Value;$/;"	m	struct:monty::Object
Value	lib/monty/monty.h	/^        auto sliceSetter (Value k, Value v) -> Value;$/;"	m	struct:monty::Object
Value	lib/monty/monty.h	/^        auto stepper () -> Value;$/;"	m	struct:monty::RawIter
Value	lib/monty/monty.h	/^        auto suspend (Vector& =Event::triggers, int ms =60000) -> Value;$/;"	m	struct:monty::Stacklet
Value	lib/monty/monty.h	/^        auto trace () -> Value;$/;"	m	struct:monty::Exception
Value	lib/monty/monty.h	/^        auto unOp (UnOp op) const -> Value;$/;"	m	struct:monty::Value
Value	lib/monty/monty.h	/^        auto values () -> Value;$/;"	m	struct:monty::Dict
Value	lib/monty/monty.h	/^        auto wait (int ms =60000) -> Value;$/;"	m	struct:monty::Event
Value	lib/monty/monty.h	/^        constexpr Value () : _v (0) {}$/;"	f	struct:monty::Value
Value	lib/monty/monty.h	/^        constexpr Value (Object const& arg) : _p (&arg) {}$/;"	f	struct:monty::Value
Value	lib/monty/monty.h	/^        constexpr Value (Object const* arg) : _p (arg) {}$/;"	f	struct:monty::Value
Value	lib/monty/monty.h	/^        constexpr Value (Q const& arg) : _v (arg._id * 4 + 2) {}$/;"	f	struct:monty::Value
Value	lib/monty/monty.h	/^        constexpr Value (int arg) : _v (arg * 2 + 1) {}$/;"	f	struct:monty::Value
Value	lib/monty/monty.h	/^        static auto asBool (bool f) -> Value;$/;"	m	struct:monty::Value
Value	lib/monty/monty.h	/^        static auto conv (char const* s) -> Value;$/;"	m	struct:monty::Int
Value	lib/monty/monty.h	/^        static auto create (ArgVec const&, Type const*) -> Value;$/;"	m	struct:monty::Inst
Value	lib/monty/monty.h	/^        static auto create (E, ArgVec const&) -> Value; \/\/ diff API$/;"	m	struct:monty::Exception
Value	lib/monty/monty.h	/^        static auto make (int64_t i) -> Value;$/;"	m	struct:monty::Int
Value	lib/monty/monty.h	/^        static auto noFactory (ArgVec const&, Type const*) -> Value;$/;"	m	struct:monty::Type
Value	lib/monty/monty.h	/^        virtual auto attr  (Value, Value&) const -> Value;$/;"	m	struct:monty::Object
Value	lib/monty/monty.h	/^        virtual auto binop (BinOp, Value) const -> Value;$/;"	m	struct:monty::Object
Value	lib/monty/monty.h	/^        virtual auto call  (ArgVec const&) const -> Value;$/;"	m	struct:monty::Object
Value	lib/monty/monty.h	/^        virtual auto copy  (Range const&) const -> Value;$/;"	m	struct:monty::Object
Value	lib/monty/monty.h	/^        virtual auto getAt (Value) const -> Value;$/;"	m	struct:monty::Object
Value	lib/monty/monty.h	/^        virtual auto iter  () const -> Value;$/;"	m	struct:monty::Object
Value	lib/monty/monty.h	/^        virtual auto next  () -> Value;$/;"	m	struct:monty::Object
Value	lib/monty/monty.h	/^        virtual auto setAt (Value, Value) -> Value;$/;"	m	struct:monty::Object
Value	lib/monty/monty.h	/^        virtual auto store (Range const&, Object const&) -> Value;$/;"	m	struct:monty::Object
Value	lib/monty/monty.h	/^        virtual auto unop  (UnOp) const -> Value;$/;"	m	struct:monty::Object
Value	lib/monty/monty.h	/^    struct Value {$/;"	s	namespace:monty
ValueError	lib/monty/monty.h	/^        ValueError,          \/\/ Exception$/;"	m	class:monty::E
VaryVec	lib/monty/monty.h	/^        constexpr VaryVec (void const* ptr =nullptr, uint32_t num =0)$/;"	f	struct:monty::VaryVec
VaryVec	lib/monty/monty.h	/^    struct VaryVec : private ByteVec {$/;"	s	namespace:monty
Vec	lib/monty/monty.h	/^        auto operator= (Vec const&) -> Vec& =delete;$/;"	m	struct:monty::Vec
Vec	lib/monty/monty.h	/^        auto operator= (Vec&&) -> Vec& =delete;$/;"	m	struct:monty::Vec
Vec	lib/monty/monty.h	/^        constexpr Vec (void const* data, uint32_t capa =0)$/;"	f	struct:monty::Vec
Vec	lib/monty/monty.h	/^    struct Vec {$/;"	s	namespace:monty
Vec	tests/native/memTest.cpp	/^        auto operator= (Vec const&) -> Vec& =delete;$/;"	m	struct:mem::Vec	file:
Vec	tests/native/memTest.cpp	/^        auto operator= (Vec&&) -> Vec& =delete;$/;"	m	struct:mem::Vec	file:
Vec	tests/native/memTest.cpp	/^    struct Vec {$/;"	s	namespace:mem	file:
VecOf	lib/monty/monty.h	/^        constexpr VecOf (T const (&ary)[N])$/;"	f	struct:monty::VecOf
VecOf	lib/monty/monty.h	/^        constexpr VecOf (T const* ptr, uint32_t num)$/;"	f	struct:monty::VecOf
VecOf	lib/monty/monty.h	/^    struct VecOf : private Vec {$/;"	s	namespace:monty
VecSlot	lib/monty/gc.cpp	/^struct VecSlot {$/;"	s	file:
WARN	lib/doctest/doctest.h	/^#define WARN(/;"	d
WARN	tests/embed/src/doctestx.h	/^#define WARN(/;"	d
WARN_EQ	lib/doctest/doctest.h	/^#define WARN_EQ(/;"	d
WARN_EQ	tests/embed/src/doctestx.h	/^#define WARN_EQ(/;"	d
WARN_FALSE	lib/doctest/doctest.h	/^#define WARN_FALSE(/;"	d
WARN_FALSE	tests/embed/src/doctestx.h	/^#define WARN_FALSE(/;"	d
WARN_FALSE_MESSAGE	lib/doctest/doctest.h	/^#define WARN_FALSE_MESSAGE(/;"	d
WARN_FALSE_MESSAGE	tests/embed/src/doctestx.h	/^#define WARN_FALSE_MESSAGE(/;"	d
WARN_GE	lib/doctest/doctest.h	/^#define WARN_GE(/;"	d
WARN_GE	tests/embed/src/doctestx.h	/^#define WARN_GE(/;"	d
WARN_GT	lib/doctest/doctest.h	/^#define WARN_GT(/;"	d
WARN_GT	tests/embed/src/doctestx.h	/^#define WARN_GT(/;"	d
WARN_LE	lib/doctest/doctest.h	/^#define WARN_LE(/;"	d
WARN_LE	tests/embed/src/doctestx.h	/^#define WARN_LE(/;"	d
WARN_LT	lib/doctest/doctest.h	/^#define WARN_LT(/;"	d
WARN_LT	tests/embed/src/doctestx.h	/^#define WARN_LT(/;"	d
WARN_MESSAGE	lib/doctest/doctest.h	/^#define WARN_MESSAGE(/;"	d
WARN_MESSAGE	tests/embed/src/doctestx.h	/^#define WARN_MESSAGE(/;"	d
WARN_NE	lib/doctest/doctest.h	/^#define WARN_NE(/;"	d
WARN_NE	tests/embed/src/doctestx.h	/^#define WARN_NE(/;"	d
WARN_NOTHROW	lib/doctest/doctest.h	/^#define WARN_NOTHROW(/;"	d
WARN_NOTHROW	tests/embed/src/doctestx.h	/^#define WARN_NOTHROW(/;"	d
WARN_NOTHROW_MESSAGE	lib/doctest/doctest.h	/^#define WARN_NOTHROW_MESSAGE(/;"	d
WARN_NOTHROW_MESSAGE	tests/embed/src/doctestx.h	/^#define WARN_NOTHROW_MESSAGE(/;"	d
WARN_THROWS	lib/doctest/doctest.h	/^#define WARN_THROWS(/;"	d
WARN_THROWS	tests/embed/src/doctestx.h	/^#define WARN_THROWS(/;"	d
WARN_THROWS_AS	lib/doctest/doctest.h	/^#define WARN_THROWS_AS(/;"	d
WARN_THROWS_AS	tests/embed/src/doctestx.h	/^#define WARN_THROWS_AS(/;"	d
WARN_THROWS_AS_MESSAGE	lib/doctest/doctest.h	/^#define WARN_THROWS_AS_MESSAGE(/;"	d
WARN_THROWS_AS_MESSAGE	tests/embed/src/doctestx.h	/^#define WARN_THROWS_AS_MESSAGE(/;"	d
WARN_THROWS_MESSAGE	lib/doctest/doctest.h	/^#define WARN_THROWS_MESSAGE(/;"	d
WARN_THROWS_MESSAGE	tests/embed/src/doctestx.h	/^#define WARN_THROWS_MESSAGE(/;"	d
WARN_THROWS_WITH	lib/doctest/doctest.h	/^#define WARN_THROWS_WITH(/;"	d
WARN_THROWS_WITH	tests/embed/src/doctestx.h	/^#define WARN_THROWS_WITH(/;"	d
WARN_THROWS_WITH_AS	lib/doctest/doctest.h	/^#define WARN_THROWS_WITH_AS(/;"	d
WARN_THROWS_WITH_AS	tests/embed/src/doctestx.h	/^#define WARN_THROWS_WITH_AS(/;"	d
WARN_THROWS_WITH_AS_MESSAGE	lib/doctest/doctest.h	/^#define WARN_THROWS_WITH_AS_MESSAGE(/;"	d
WARN_THROWS_WITH_AS_MESSAGE	tests/embed/src/doctestx.h	/^#define WARN_THROWS_WITH_AS_MESSAGE(/;"	d
WARN_THROWS_WITH_MESSAGE	lib/doctest/doctest.h	/^#define WARN_THROWS_WITH_MESSAGE(/;"	d
WARN_THROWS_WITH_MESSAGE	tests/embed/src/doctestx.h	/^#define WARN_THROWS_WITH_MESSAGE(/;"	d
WARN_UNARY	lib/doctest/doctest.h	/^#define WARN_UNARY(/;"	d
WARN_UNARY	tests/embed/src/doctestx.h	/^#define WARN_UNARY(/;"	d
WARN_UNARY_FALSE	lib/doctest/doctest.h	/^#define WARN_UNARY_FALSE(/;"	d
WARN_UNARY_FALSE	tests/embed/src/doctestx.h	/^#define WARN_UNARY_FALSE(/;"	d
WHEN	lib/doctest/doctest.h	/^#define WHEN(/;"	d
WHEN	tests/embed/src/doctestx.h	/^#define WHEN(/;"	d
WIN32_LEAN_AND_MEAN	lib/doctest/doctest.h	/^#define WIN32_LEAN_AND_MEAN$/;"	d
WIN32_LEAN_AND_MEAN	tests/embed/src/doctestx.h	/^#define WIN32_LEAN_AND_MEAN$/;"	d
WORD	lib/monty/parser.h	/^            IHEX, SKIP, END, STR, ESC, STRX, STRU, NUM, WORD, ARGS };$/;"	m	struct:Parser	typeref:enum:Parser::
WPR	lib/hall-stm32/stm32l4.cpp	/^        enum { TR=0x00,DR=0x04,CR=0x08,ISR=0x0C,WPR=0x24,BKPR=0x50 };$/;"	e	enum:hall::rtc::__anon5	file:
WRAP	src/codegen.py	/^def WRAP(block, typ, *methods):$/;"	f
WRAPPERS	src/codegen.py	/^def WRAPPERS(block, typ=None):$/;"	f
WWDG	lib/arch-stm32/prelude.h	/^    WWDG                  =   0,  \/\/ WWDG$/;"	m	struct:IrqVec
WWDG	lib/arch-stm32/prelude.h	/^constexpr auto WWDG          = 0x40002C00;  \/\/ WWDG$/;"	v
WWDG	lib/hall-stm32/hall.h	/^        constexpr Io32b <0x40002C00> WWDG;$/;"	m	namespace:hall::dev
WWDG	lib/mcu/prelude.h	/^    WWDG                  =   0,  \/\/ WWDG$/;"	m	struct:IrqVec
WWDG	lib/mcu/prelude.h	/^constexpr auto WWDG          = 0x40002C00;  \/\/ WWDG$/;"	v
White	lib/doctest/doctest.h	/^        White,$/;"	e	enum:doctest::Color::Enum
White	tests/embed/src/doctestx.h	/^        White,$/;"	e	enum:doctest::Color::Enum
WithCleanup	lib/pyvm/pyvm.cpp	/^    WithCleanup            = 0x5C,$/;"	e	enum:uint8_t	file:
Wrap	lib/monty/monty.h	/^            constexpr Wrap (M m) : _m (m) {}$/;"	f	struct:monty::Method::Wrap
Wrap	lib/monty/monty.h	/^        struct Wrap : Base {$/;"	s	struct:monty::Method
XMLGenerator	src/xmltodict.py	/^from xml.sax.saxutils import XMLGenerator$/;"	i
Yellow	lib/doctest/doctest.h	/^        Yellow,$/;"	e	enum:doctest::Color::Enum
Yellow	tests/embed/src/doctestx.h	/^        Yellow,$/;"	e	enum:doctest::Color::Enum
Yield	lib/arch-stm32/jee-rf69.h	/^#define Yield(/;"	d
YieldFrom	lib/pyvm/pyvm.cpp	/^    YieldFrom              = 0x68,$/;"	e	enum:uint8_t	file:
YieldValue	lib/pyvm/pyvm.cpp	/^    YieldValue             = 0x67,$/;"	e	enum:uint8_t	file:
ZeroDivisionError	lib/monty/monty.h	/^        ZeroDivisionError,   \/\/ ArithmeticError$/;"	m	class:monty::E
_DictSAXHandler	src/xmltodict.py	/^class _DictSAXHandler(object):$/;"	c
__assert	lib/arch-stm32/arch.cpp	/^extern "C" void __assert (char const* f, int l, char const* e) {$/;"	f
__assert_func	lib/arch-stm32/arch.cpp	/^extern "C" void __assert_func (char const* f, int l, char const* n, char const* e) {$/;"	f
__author__	src/xmltodict.py	/^__author__ = 'Martin Blech'$/;"	v
__enter__	tests/py/with.py	/^    def __enter__(self, *args):$/;"	m	class:A	file:
__exit__	tests/py/with.py	/^    def __exit__(self, *args):$/;"	m	class:A	file:
__getattribute__	src/codegen.py	/^    def __getattribute__(self,name):$/;"	m	class:Flags	file:
__init__	src/xmltodict.py	/^    def __init__(self,$/;"	m	class:_DictSAXHandler
__init__	tests/py/derived.py	/^    def __init__(self,x):$/;"	m	class:A
__init__	tests/py/derived.py	/^    def __init__(self,x):$/;"	m	class:B
__init__	tests/py/features.py	/^        def __init__(self, c):$/;"	m	class:.A
__init__	tests/py/features.py	/^    def __init__(self):$/;"	m	class:A
__init__	tests/py/with.py	/^    def __init__(self):$/;"	m	class:A
__license__	src/xmltodict.py	/^__license__ = 'MIT'$/;"	v
__version__	src/xmltodict.py	/^__version__ = '0.12.0'$/;"	v
_attrs_to_dict	src/xmltodict.py	/^    def _attrs_to_dict(self, attrs):$/;"	m	class:_DictSAXHandler
_base	lib/pyvm/pyvm.cpp	/^    uint16_t _base = 0;$/;"	m	struct:PyVM	file:
_basestring	src/xmltodict.py	/^    _basestring = basestring$/;"	v
_basestring	src/xmltodict.py	/^    _basestring = str$/;"	v
_bc	lib/pyvm/pyvm.cpp	/^    Bytecode const& _bc;$/;"	m	struct:Callable	file:
_build_name	src/xmltodict.py	/^    def _build_name(self, full_name):$/;"	m	class:_DictSAXHandler
_by	lib/monty/monty.h	/^        int32_t _from, _to, _by;$/;"	m	struct:monty::Range
_callee	lib/pyvm/pyvm.cpp	/^    Callable const* _callee = nullptr;$/;"	m	struct:PyVM	file:
_caller	lib/monty/monty.h	/^        Context* _caller =nullptr;$/;"	m	struct:monty::Context
_capa	lib/monty/monty.h	/^        uint32_t _capa = 0;       \/\/ capacity in bytes$/;"	m	struct:monty::Vec
_chain	lib/monty/monty.h	/^        Lookup const* _chain;$/;"	m	struct:monty::Lookup
_code	lib/monty/monty.h	/^        E _code;$/;"	m	struct:monty::Exception
_cpol	lib/arch-stm32/jee-stm32.h	/^        uint8_t _cpol =0;$/;"	m	struct:jeeh::SpiGpio
_cpol	lib/mcu/mcu.h	/^        uint8_t _cpol =0;$/;"	m	struct:mcu::SpiGpio
_data	lib/monty/monty.h	/^        uint8_t* _data = nullptr; \/\/ pointer to vector when capa > 0$/;"	m	struct:monty::Vec
_deadline	lib/monty/monty.h	/^        uint16_t _deadline;$/;"	m	struct:monty::Event
_desc	lib/monty/monty.h	/^        char const* _desc =nullptr;$/;"	m	struct:monty::Function
_dict	lib/monty/type.cpp	/^    Dict const& _dict;$/;"	m	struct:DictView	file:
_emit	src/xmltodict.py	/^def _emit(key, value, content_handler,$/;"	f
_exc	lib/monty/builtin.cpp	/^    Exception& _exc;$/;"	m	struct:SizeFix	file:
_factory	lib/monty/monty.h	/^        Factory _factory;$/;"	m	struct:monty::Type
_fill	lib/monty/monty.h	/^        uint32_t _fill = 0;$/;"	m	struct:monty::VecOf
_from	lib/monty/monty.h	/^        int32_t _from, _to, _by;$/;"	m	struct:monty::Range
_func	lib/monty/monty.h	/^        Prim _func;$/;"	m	struct:monty::Function
_func	lib/pyvm/pyvm.cpp	/^    Object const& _func;$/;"	m	struct:Closure	file:
_i64	lib/monty/monty.h	/^        int64_t _i64 __attribute__((packed));$/;"	m	struct:monty::Int
_id	lib/boss/boss.h	/^        uint8_t _id;$/;"	m	struct:boss::boss::Device
_id	lib/mcu/mcu.h	/^        uint8_t _id;$/;"	m	struct:mcu::Device
_id	lib/monty/monty.h	/^        int8_t _id = -1;$/;"	m	struct:monty::Event
_id	lib/monty/monty.h	/^        uint16_t _id;$/;"	m	struct:monty::Q
_ip	lib/pyvm/pyvm.cpp	/^    uint8_t const* _ip = nullptr;$/;"	m	struct:PyVM	file:
_ipOff	lib/pyvm/pyvm.cpp	/^    uint16_t _ipOff = 0;$/;"	m	struct:PyVM	file:
_kw	lib/pyvm/pyvm.cpp	/^    Dict* _kw;$/;"	m	struct:Callable	file:
_m	lib/monty/monty.h	/^            M _m;$/;"	m	struct:monty::Method::Wrap
_meth	lib/monty/monty.h	/^        Base const& _meth;$/;"	m	struct:monty::Method
_meth	lib/pyvm/pyvm.cpp	/^    Object const& _meth;$/;"	m	struct:BoundMeth	file:
_miso	lib/arch-stm32/jee-stm32.h	/^        Pin _mosi, _miso, _sclk, _nsel;$/;"	m	struct:jeeh::SpiGpio
_miso	lib/mcu/mcu.h	/^        Pin _mosi, _miso, _sclk, _nsel;$/;"	m	struct:mcu::SpiGpio
_mo	lib/pyvm/pyvm.cpp	/^    Module& _mo;$/;"	m	struct:Callable	file:
_mosi	lib/arch-stm32/jee-stm32.h	/^        Pin _mosi, _miso, _sclk, _nsel;$/;"	m	struct:jeeh::SpiGpio
_mosi	lib/mcu/mcu.h	/^        Pin _mosi, _miso, _sclk, _nsel;$/;"	m	struct:mcu::SpiGpio
_name	lib/monty/monty.h	/^        Value _name;$/;"	m	struct:monty::Module
_name	lib/monty/monty.h	/^        Value _name;$/;"	m	struct:monty::Type
_nsel	lib/arch-stm32/jee-stm32.h	/^        Pin _mosi, _miso, _sclk, _nsel;$/;"	m	struct:jeeh::SpiGpio
_nsel	lib/mcu/mcu.h	/^        Pin _mosi, _miso, _sclk, _nsel;$/;"	m	struct:mcu::SpiGpio
_num	lib/monty/monty.h	/^        Value _off, _num, _step;$/;"	m	struct:monty::Slice
_num	lib/monty/monty.h	/^        int _num;$/;"	m	struct:monty::ArgVec
_o	lib/monty/monty.h	/^            Object* _o;$/;"	m	union:monty::Value::__anon9
_obj	lib/monty/monty.h	/^        Value _obj, _pos, _val;$/;"	m	struct:monty::RawIter
_off	lib/monty/monty.h	/^        Value _off, _num, _step;$/;"	m	struct:monty::Slice
_off	lib/monty/monty.h	/^        int _off;$/;"	m	struct:monty::ArgVec
_orig	lib/monty/builtin.cpp	/^    uint32_t _orig;$/;"	m	struct:SizeFix	file:
_p	lib/monty/monty.h	/^            void const* _p;$/;"	m	union:monty::Value::__anon9
_pin	lib/arch-stm32/jee-stm32.h	/^        uint8_t _port, _pin;$/;"	m	struct:jeeh::Pin
_pin	lib/mcu/mcu.h	/^        uint8_t _port :4, _pin :4;$/;"	m	struct:mcu::Pin
_port	lib/arch-stm32/jee-stm32.h	/^        uint8_t _port, _pin;$/;"	m	struct:jeeh::Pin
_port	lib/mcu/mcu.h	/^        uint8_t _port :4, _pin :4;$/;"	m	struct:mcu::Pin
_pos	lib/monty/monty.h	/^        Value _obj, _pos, _val;$/;"	m	struct:monty::RawIter
_pos	lib/pyvm/pyvm.cpp	/^    Tuple* _pos;$/;"	m	struct:Callable	file:
_process_namespace	src/xmltodict.py	/^def _process_namespace(name, namespaces, ns_sep=':', attr_prefix='@'):$/;"	f
_queue	lib/monty/monty.h	/^        Vector _queue;$/;"	m	struct:monty::Event
_rate	lib/mcu/mcu.h	/^        uint16_t _rate;$/;"	m	struct:mcu::I2cGpio
_scl	lib/mcu/mcu.h	/^        Pin _sda, _scl;$/;"	m	struct:mcu::I2cGpio
_sclass	lib/monty/monty.h	/^        Value _sclass;$/;"	m	struct:monty::Super
_sclk	lib/arch-stm32/jee-stm32.h	/^        Pin _mosi, _miso, _sclk, _nsel;$/;"	m	struct:jeeh::SpiGpio
_sclk	lib/mcu/mcu.h	/^        Pin _mosi, _miso, _sclk, _nsel;$/;"	m	struct:mcu::SpiGpio
_sda	lib/mcu/mcu.h	/^        Pin _sda, _scl;$/;"	m	struct:mcu::I2cGpio
_self	lib/pyvm/pyvm.cpp	/^    Value _self;$/;"	m	struct:BoundMeth	file:
_should_force_list	src/xmltodict.py	/^    def _should_force_list(self, key, value):$/;"	m	class:_DictSAXHandler
_signal	lib/pyvm/pyvm.cpp	/^    Value _signal;$/;"	m	struct:PyVM	file:
_sinst	lib/monty/monty.h	/^        Value _sinst;$/;"	m	struct:monty::Super
_sp	lib/pyvm/pyvm.cpp	/^    Value* _sp = nullptr;$/;"	m	struct:PyVM	file:
_spOff	lib/pyvm/pyvm.cpp	/^    uint16_t _spOff = 0;$/;"	m	struct:PyVM	file:
_step	lib/monty/monty.h	/^        Value _off, _num, _step;$/;"	m	struct:monty::Slice
_to	lib/monty/monty.h	/^        int32_t _from, _to, _by;$/;"	m	struct:monty::Range
_transfer	lib/monty/monty.h	/^        Value _transfer; \/\/ set to deadline while suspended$/;"	m	struct:monty::Context
_unicode	src/xmltodict.py	/^    _unicode = str$/;"	v
_unicode	src/xmltodict.py	/^    _unicode = unicode$/;"	v
_v	lib/monty/monty.h	/^            uintptr_t _v;$/;"	m	union:monty::Value::__anon9
_val	lib/monty/monty.h	/^        Value _obj, _pos, _val;$/;"	m	struct:monty::RawIter
_val	lib/pyvm/pyvm.cpp	/^    Value _val;$/;"	m	struct:Cell	file:
_value	lib/monty/monty.h	/^        bool _value = false;$/;"	m	struct:monty::Event
_vec	lib/monty/monty.h	/^        Vector const& _vec;$/;"	m	struct:monty::ArgVec
_vtype	lib/monty/type.cpp	/^    int _vtype;$/;"	m	struct:DictView	file:
a	tests/py/bound.py	/^a = A()$/;"	v
a	tests/py/bytes.py	/^a = 'abc'$/;"	v
a	tests/py/closure.py	/^    def a():$/;"	f	function:one
a	tests/py/closure.py	/^a = one(11)$/;"	v
a	tests/py/derived.py	/^a = A(123)$/;"	v
a	tests/py/dict.py	/^a = {1:2,3:4,5:6}$/;"	v
a	tests/py/except.py	/^a = A()$/;"	v
a	tests/py/except.py	/^a = {}$/;"	v
a	tests/py/features.py	/^    a = "1"$/;"	v
a	tests/py/features.py	/^    a = "2"$/;"	v
a	tests/py/features.py	/^    a = 4 \/\/ zero$/;"	v
a	tests/py/features.py	/^a = 24$/;"	v
a	tests/py/features.py	/^a = A()$/;"	v
a	tests/py/features.py	/^a = [20, 21, 22, 23, 24]$/;"	v
a	tests/py/features.py	/^a = []$/;"	v
a	tests/py/gcoll.py	/^a = []$/;"	v
a	tests/py/int64.py	/^    a = a % z$/;"	v
a	tests/py/int64.py	/^    a = a \/ z$/;"	v
a	tests/py/int64.py	/^a = 1000000 * 2000000$/;"	v
a	tests/py/ints.py	/^    a = 1 % 0$/;"	v
a	tests/py/iter.py	/^a = iter(range(5))$/;"	v
a	tests/py/other/x_yfrom.py	/^def a():$/;"	f
a	tests/py/slice.py	/^a = array('i', 5);$/;"	v
a	tests/py/unop.py	/^a = -1073741823$/;"	v
a	tests/py/unop.py	/^a = 1$/;"	v
a	tests/py/varyvec.py	/^a = array('V', 3)$/;"	v
abort	lib/arch-stm32/arch.cpp	/^extern "C" void abort () {$/;"	f
abort	lib/mcu/mcu.cpp	/^extern "C" void abort () { ensure(0); }$/;"	f
abort_after	lib/doctest/doctest.h	/^    int abort_after;           \/\/ stop tests after this many failed assertions$/;"	m	struct:doctest::ContextOptions
abort_after	tests/embed/src/doctestx.h	/^    int abort_after;           \/\/ stop tests after this many failed assertions$/;"	m	struct:doctest::ContextOptions
accessor_B	lib/extend/typ-array.cpp	/^static AccessAs<uint8_t>    const accessor_B;$/;"	v	file:
accessor_H	lib/extend/typ-array.cpp	/^static AccessAs<uint16_t>   const accessor_H;$/;"	v	file:
accessor_L	lib/extend/typ-array.cpp	/^static AccessAs<uint32_t,1> const accessor_L;$/;"	v	file:
accessor_N	lib/extend/typ-array.cpp	/^static AccessAsBits<2>      const accessor_N;$/;"	v	file:
accessor_P	lib/extend/typ-array.cpp	/^static AccessAsBits<0>      const accessor_P;$/;"	v	file:
accessor_T	lib/extend/typ-array.cpp	/^static AccessAsBits<1>      const accessor_T;$/;"	v	file:
accessor_V	lib/extend/typ-array.cpp	/^static AccessAsVaryStr      const accessor_V;$/;"	v	file:
accessor_b	lib/extend/typ-array.cpp	/^static AccessAs<int8_t>     const accessor_b;$/;"	v	file:
accessor_d	lib/extend/typ-array.cpp	/^static AccessAs<double>     const accessor_d;$/;"	v	file:
accessor_f	lib/extend/typ-array.cpp	/^static AccessAs<float>      const accessor_f;$/;"	v	file:
accessor_h	lib/extend/typ-array.cpp	/^static AccessAs<int16_t>    const accessor_h;$/;"	v	file:
accessor_l	lib/extend/typ-array.cpp	/^static AccessAs<int32_t,1>  const accessor_l;$/;"	v	file:
accessor_q	lib/extend/typ-array.cpp	/^static AccessAs<int64_t,1>  const accessor_q;$/;"	v	file:
accessor_v	lib/extend/typ-array.cpp	/^static AccessAsVaryBytes    const accessor_v;$/;"	v	file:
accessors	lib/extend/typ-array.cpp	/^static Accessor const* accessors [] = {$/;"	v	file:
add	lib/mrfs/mrfs.cpp	/^static void add (int ac, char const** av) {$/;"	f	file:
addByte	lib/monty/parser.h	/^    void addByte (uint8_t b, bool extend =true) {$/;"	f
addToDb	src/altpins.py	/^    def addToDb(dev, pin):$/;"	f	function:extract
addTrace	lib/monty/builtin.cpp	/^void Exception::addTrace (uint32_t off, Value bc) {$/;"	f	class:Exception
addr	lib/hall-stm32/hall.h	/^        constexpr static auto addr = ADDR;$/;"	m	struct:hall::IoBase
addr	lib/mcu/mcu.h	/^            uint32_t volatile& addr;$/;"	m	struct:mcu::IOWord::IOBit
addr	lib/mcu/mcu.h	/^            uint32_t volatile& addr;$/;"	m	struct:mcu::IOWord::IOMask
addr	lib/mcu/mcu.h	/^        uint32_t volatile& addr;$/;"	m	struct:mcu::IOWord
addr	src/mrfs.py	/^        addr = off + upload$/;"	v
addr	tests/gpio/gpio.cpp	/^            constexpr static auto addr = ADDR;$/;"	m	struct:gpio::IoBase	file:
adj	lib/monty/monty.h	/^        auto adj (uint32_t num) { return Vec::adj(num * sizeof (T)); }$/;"	f	struct:monty::VecOf
afc	lib/arch-stm32/jee-rf69.h	/^        int16_t afc;$/;"	m	struct:jeeh::RF69
afrh	lib/arch-stm32/jee-stm32.h	/^                odr=0x14, bsrr=0x18, afrl=0x20, afrh=0x24, brr=0x28 };$/;"	e	enum:jeeh::Pin::__anon23
afrl	lib/arch-stm32/jee-stm32.h	/^                odr=0x14, bsrr=0x18, afrl=0x20, afrh=0x24, brr=0x28 };$/;"	e	enum:jeeh::Pin::__anon23
alt	lib/arch-stm32/altpins.h	/^struct AltPins { uint8_t pin, dev :4, alt :4; };$/;"	m	struct:AltPins
alt	lib/mcu/altpins.h	/^struct AltPins { uint8_t pin, dev :4, alt :4; };$/;"	m	struct:AltPins
altMISO	lib/arch-stm32/altpins.h	/^AltPins const altMISO [] = {$/;"	v
altMISO	lib/mcu/altpins.h	/^AltPins const altMISO [] = {$/;"	v
altMOSI	lib/arch-stm32/altpins.h	/^AltPins const altMOSI [] = {$/;"	v
altMOSI	lib/mcu/altpins.h	/^AltPins const altMOSI [] = {$/;"	v
altNSS	lib/arch-stm32/altpins.h	/^AltPins const altNSS [] = {$/;"	v
altNSS	lib/mcu/altpins.h	/^AltPins const altNSS [] = {$/;"	v
altRX	lib/arch-stm32/altpins.h	/^AltPins const altRX [] = {$/;"	v
altRX	lib/mcu/altpins.h	/^AltPins const altRX [] = {$/;"	v
altSCK	lib/arch-stm32/altpins.h	/^AltPins const altSCK [] = {$/;"	v
altSCK	lib/mcu/altpins.h	/^AltPins const altSCK [] = {$/;"	v
altTX	lib/arch-stm32/altpins.h	/^AltPins const altTX [] = {$/;"	v
altTX	lib/mcu/altpins.h	/^AltPins const altTX [] = {$/;"	v
altpins	lib/arch-stm32/arch.h	/^namespace altpins {$/;"	n
altpins	lib/mcu/mcu.h	/^namespace altpins {$/;"	n
anyIo32	lib/hall-stm32/hall.h	/^    constexpr Io32<0> anyIo32;$/;"	m	namespace:hall
append	lib/boss/boss.cpp	/^    void Queue::append (Id_t id) {$/;"	f	class:boss::pool::Queue
append	lib/boss/boss.h	/^        void append (void* p) { append(Buf::asId(p)); }$/;"	f	struct:boss::pool::Queue
append	lib/monty/monty.h	/^        void append (T v) { push(v, _fill); } \/\/ push to end$/;"	f	struct:monty::VecOf
append	tests/buffers/main.cpp	/^    void Queue::append (Buf b) {$/;"	f	class:buf::Queue
arch	lib/arch-native/arch.h	/^namespace arch {$/;"	n
arch	lib/arch-stm32/arch.h	/^namespace arch {$/;"	n
arch	src/codegen.py	/^            arch = ""$/;"	v
arch	src/codegen.py	/^            arch = arg[1:]$/;"	v
arch	src/codegen.py	/^    arch = ""$/;"	v
arch	src/codegen.py	/^arch  = ""          # current architecture, "" is common to all$/;"	v
archs	src/codegen.py	/^archs = {}          # list of qstr details per architecture$/;"	v
arg	lib/mcu/printer.h	/^    void* arg;$/;"	m	struct:Printer
arg	src/codegen.py	/^            arg = maybeInRoot(arg)$/;"	v
arg	src/codegen.py	/^        arg = maybeInRoot(arg)$/;"	v
args	src/mrfs.py	/^args = iter(sys.argv[1:])$/;"	v
args	src/runner.py	/^    args = iter(sys.argv[1:])$/;"	v
arrayInsDel	tests/unit/array/main.cpp	/^static void arrayInsDel () {$/;"	f	file:
arrayModes	lib/extend/typ-array.cpp	/^constexpr char arrayModes [] = "PTNbBhHiIlLqvV"$/;"	v
arrayTypeSizes	tests/unit/array/main.cpp	/^void arrayTypeSizes () {$/;"	f
asA	lib/graphics/twodee.h	/^                bbW, bbH, bbX, bbY, asA, deG, asO, deC;$/;"	m	struct:twodee::Font
asO	lib/graphics/twodee.h	/^                bbW, bbH, bbX, bbY, asA, deG, asO, deC;$/;"	m	struct:twodee::Font
assert	lib/boss/boss.h	/^#define assert(/;"	d
assertType	lib/doctest/doctest.h	/^namespace assertType {$/;"	n	namespace:doctest
assertType	tests/embed/src/doctestx.h	/^namespace assertType {$/;"	n	namespace:doctest
atAdj	lib/monty/type.cpp	/^void VaryVec::atAdj (uint32_t idx, uint32_t len) {$/;"	f	class:VaryVec
atGet	lib/monty/monty.h	/^        auto atGet (uint32_t i) const { return begin() + pos(i); }$/;"	f	struct:monty::VaryVec
atSet	lib/monty/type.cpp	/^void VaryVec::atSet (uint32_t idx, void const* ptr, uint32_t len) {$/;"	f	class:VaryVec
attrs	lib/arch-stm32/mod-machine.cpp	/^    static Lookup const attrs;$/;"	m	struct:RF69	file:
attrs	lib/arch-stm32/mod-machine.cpp	/^    static Lookup const attrs;$/;"	m	struct:Spi	file:
attrs	lib/arch-stm32/mod-machine.cpp	/^Type RF69::info (Q(0,"<rf69>"), &RF69::attrs);$/;"	m	class:RF69	file:
attrs	lib/arch-stm32/mod-machine.cpp	/^Type Spi::info (Q(0,"<spi>"), &Spi::attrs);$/;"	m	class:Spi	file:
attrs	lib/extend/typ-array.cpp	/^Lookup const Array::attrs;$/;"	m	class:Array	file:
attrs	lib/monty/data.cpp	/^Lookup const Bool::attrs;$/;"	m	class:Bool	file:
attrs	lib/monty/data.cpp	/^Lookup const Int::attrs;$/;"	m	class:Int	file:
attrs	lib/monty/data.cpp	/^Lookup const Range::attrs;$/;"	m	class:Range	file:
attrs	lib/monty/data.cpp	/^Lookup const Slice::attrs;$/;"	m	class:Slice	file:
attrs	lib/monty/monty.h	/^        static Lookup const attrs;$/;"	m	struct:monty::Exception
attrs	lib/monty/monty.h	/^        static Lookup const attrs;$/;"	m	struct:monty::Inst
attrs	lib/monty/type.cpp	/^Lookup const Bytes::attrs;$/;"	m	class:Bytes	file:
attrs	lib/monty/type.cpp	/^Lookup const Class::attrs;$/;"	m	class:Class	file:
attrs	lib/monty/type.cpp	/^Lookup const Inst::attrs;$/;"	m	class:Inst	file:
attrs	lib/monty/type.cpp	/^Lookup const Set::attrs;$/;"	m	class:Set	file:
attrs	lib/monty/type.cpp	/^Lookup const Str::attrs;$/;"	m	class:Str	file:
attrs	lib/monty/type.cpp	/^Lookup const Super::attrs;$/;"	m	class:Super	file:
attrs	lib/monty/type.cpp	/^Lookup const Tuple::attrs;$/;"	m	class:Tuple	file:
attrs	lib/monty/type.cpp	/^Lookup const Type::attrs;$/;"	m	class:Type	file:
attrs	lib/pyvm/pyvm.cpp	/^    static Lookup const attrs;$/;"	m	struct:PyVM	file:
attrs	lib/pyvm/pyvm.cpp	/^Type PyVM::info (Q(0,"<pyvm>"), &PyVM::attrs);$/;"	m	class:PyVM	file:
b	src/codegen.py	/^            b = path.basename(arg.rstrip("\/"))$/;"	v
b	tests/buffers/main.cpp	/^        Buf (Buf&& b) =default;$/;"	m	struct:buf::Buf	file:
b	tests/py/bytes.py	/^b = b'defgh'$/;"	v
b	tests/py/closure.py	/^    def b():$/;"	f	function:two
b	tests/py/closure.py	/^b = two()$/;"	v
b	tests/py/derived.py	/^b = B(456)$/;"	v
b	tests/py/features.py	/^    b = A(3)$/;"	v
b	tests/py/features.py	/^b = A()$/;"	v
b	tests/py/features.py	/^b = [a, a, a]$/;"	v
b	tests/py/int64.py	/^b = 3000000 * 4000000$/;"	v
b	tests/py/iter.py	/^b = (100+i*i for i in range(6))$/;"	v
b	tests/py/other/x_yfrom.py	/^b = a()$/;"	v
b	tests/py/repr.py	/^b = B()$/;"	v
b	tests/py/unop.py	/^b = -1073741824$/;"	v
b	tests/py/unop.py	/^b = 1000000$/;"	v
b	tests/py/varyvec.py	/^b = array('v', 3)$/;"	v
bFill	lib/graphics/twodee.h	/^        static void bFill (Point p, unsigned w, unsigned h, unsigned c =fg) {$/;"	f	struct:twodee::TwoDee
bFill	lib/graphics/twodee.h	/^        static void bFill (Point p1, Point p2) { bFill({p1, p2}); }$/;"	f	struct:twodee::TwoDee
bFill	lib/graphics/twodee.h	/^        static void bFill (Rect const& r)      { bFill(r, r.w, r.h); }$/;"	f	struct:twodee::TwoDee
bar	tests/py/features.py	/^def bar(): return 40$/;"	f
base	lib/arch-stm32/prelude.h	/^    uint32_t base;$/;"	m	struct:IrqVec::DevInfo
base	lib/arch-stm32/prelude.h	/^struct DmaInfo { uint32_t base; uint8_t streams [8]; };$/;"	m	struct:IrqVec::DmaInfo
base	lib/hall-stm32/stm32l4-uart.cpp	/^    uint32_t base;$/;"	m	struct:UartInfo	file:
base	lib/hall-stm32/stm32l4-uart.cpp	/^struct DmaInfo { uint32_t base; uint8_t streams [8]; };$/;"	m	struct:DmaInfo	file:
base	lib/mcu/prelude.h	/^    uint32_t base;$/;"	m	struct:IrqVec::DevInfo
base	lib/mcu/prelude.h	/^struct DmaInfo { uint32_t base; uint8_t streams [8]; };$/;"	m	struct:IrqVec::DmaInfo
base	lib/mrfs/mrfs.cpp	/^    Info* base;$/;"	m	namespace:mrfs	file:
base	lib/pyvm/pyvm.cpp	/^        Value base, spOff, ipOff, callee, ep, locals, result, stack [];$/;"	m	struct:PyVM::Frame	file:
base	src/codegen.py	/^                base = arg # remember first one$/;"	v
base	tests/gpio/gpio.cpp	/^uintptr_t gpio::base;$/;"	m	class:gpio	file:
bases	lib/monty/monty.h	/^        static Lookup const bases; \/\/ this maps the derivation hierarchy$/;"	m	struct:monty::Exception
baud	lib/arch-stm32/uart-f1.h	/^    void baud (uint32_t bd, uint32_t hz) const { devReg(BRR) = (hz+bd\/2)\/bd; }$/;"	f	struct:Uart
baud	lib/arch-stm32/uart-f4.h	/^    void baud (uint32_t bd, uint32_t hz) const { devReg(BRR) = (hz\/4+bd\/2)\/bd; }$/;"	f	struct:Uart
baud	lib/arch-stm32/uart-l0.h	/^    void baud (uint32_t bd, uint32_t hz) const { devReg(BRR) = (hz+bd\/2)\/bd; }$/;"	f	struct:Uart
baud	lib/arch-stm32/uart-l4.h	/^    void baud (uint32_t bd, uint32_t hz) const { devReg(BRR) = (hz+bd\/2)\/bd; }$/;"	f	struct:Uart
baud	lib/hall-stm32/stm32l4-uart.cpp	/^    void baud (uint32_t bd, uint32_t hz =systemHz()) const {$/;"	f	struct:Uart
baud	lib/mcu/uart-stm32f4f7.h	/^    void baud (uint32_t bd, uint32_t hz) const { devReg(BRR) = (hz+bd\/2)\/bd; }$/;"	f	struct:Uart
baud	lib/mcu/uart-stm32l4.h	/^    void baud (uint32_t bd, uint32_t hz) const { devReg(BRR) = (hz+bd\/2)\/bd; }$/;"	f	struct:Uart
bbH	lib/graphics/twodee.h	/^                bbW, bbH, bbX, bbY, asA, deG, asO, deC;$/;"	m	struct:twodee::Font
bbM	lib/graphics/twodee.h	/^        uint8_t nGl, bbM, m0b, m1b, bcW, bcH, bcX, bcY, bcD,$/;"	m	struct:twodee::Font
bbW	lib/graphics/twodee.h	/^                bbW, bbH, bbX, bbY, asA, deG, asO, deC;$/;"	m	struct:twodee::Font
bbX	lib/graphics/twodee.h	/^                bbW, bbH, bbX, bbY, asA, deG, asO, deC;$/;"	m	struct:twodee::Font
bbY	lib/graphics/twodee.h	/^                bbW, bbH, bbX, bbY, asA, deG, asO, deC;$/;"	m	struct:twodee::Font
bcBuf	lib/pyvm/loader.h	/^    uint8_t* bcBuf;$/;"	m	struct:Loader
bcD	lib/graphics/twodee.h	/^        uint8_t nGl, bbM, m0b, m1b, bcW, bcH, bcX, bcY, bcD,$/;"	m	struct:twodee::Font
bcH	lib/graphics/twodee.h	/^        uint8_t nGl, bbM, m0b, m1b, bcW, bcH, bcX, bcY, bcD,$/;"	m	struct:twodee::Font
bcLimit	lib/pyvm/loader.h	/^    uint8_t* bcLimit;$/;"	m	struct:Loader
bcNext	lib/pyvm/loader.h	/^    uint8_t* bcNext;$/;"	m	struct:Loader
bcW	lib/graphics/twodee.h	/^        uint8_t nGl, bbM, m0b, m1b, bcW, bcH, bcX, bcY, bcD,$/;"	m	struct:twodee::Font
bcX	lib/graphics/twodee.h	/^        uint8_t nGl, bbM, m0b, m1b, bcW, bcH, bcX, bcY, bcD,$/;"	m	struct:twodee::Font
bcY	lib/graphics/twodee.h	/^        uint8_t nGl, bbM, m0b, m1b, bcW, bcH, bcX, bcY, bcD,$/;"	m	struct:twodee::Font
begin	lib/monty/monty.h	/^        auto begin () const { return _vec.begin() + _off; }$/;"	f	struct:monty::ArgVec
begin	lib/monty/monty.h	/^        constexpr auto begin () const { return (T*) Vec::ptr(); }$/;"	f	struct:monty::VecOf
bg	lib/graphics/twodee.h	/^        static int fg, bg;$/;"	m	struct:twodee::TwoDee
bg	lib/graphics/twodee.h	/^    int TwoDee<G>::bg = 0;$/;"	m	class:twodee::TwoDee
bigIntTests	tests/unit/data/main.cpp	/^void bigIntTests () {$/;"	f
binary_name	lib/doctest/doctest.h	/^    String        binary_name; \/\/ the test binary name$/;"	m	struct:doctest::ContextOptions
binary_name	tests/embed/src/doctestx.h	/^    String        binary_name; \/\/ the test binary name$/;"	m	struct:doctest::ContextOptions
bit	lib/mcu/mcu.h	/^            uint8_t bit, width;$/;"	m	struct:mcu::IOWord::IOMask
bit	lib/mcu/mcu.h	/^            uint8_t bit;$/;"	m	struct:mcu::IOWord::IOBit
bits	lib/extend/typ-array.cpp	/^    constexpr static auto bits = 1 << L;            \/\/ 1 2 4$/;"	m	struct:AccessAsBits	file:
bits	lib/graphics/twodee.h	/^        uint16_t seen, bits;$/;"	m	struct:twodee::Glyph
blah	tests/py/polyfill.py	/^def blah(*args):$/;"	f
bn	src/runner.py	/^        bn = os.path.basename(fn)$/;"	v
bool	lib/arch-stm32/arch.cpp	/^    auto (*reader)(char const*)->bool;$/;"	m	struct:HexSerial	file:
bool	lib/arch-stm32/arch.cpp	/^    virtual auto exec (char const*) -> bool = 0;$/;"	m	struct:LineSerial	file:
bool	lib/boss/boss.h	/^        static auto dispatch () -> bool;$/;"	m	struct:boss::boss::Device
bool	lib/boss/boss.h	/^        static auto runLoop () -> bool;$/;"	m	struct:boss::boss::Fiber
bool	lib/monty/monty.h	/^            auto operator= (bool) -> bool;$/;"	m	struct:monty::Set::Proxy
bool	lib/monty/monty.h	/^        auto adj (uint32_t bytes) -> bool;$/;"	m	struct:monty::Vec
bool	lib/monty/monty.h	/^        auto check (Type const& t) const -> bool;$/;"	m	struct:monty::Value
bool	lib/monty/monty.h	/^        auto operator!= (RawIter const&) -> bool;$/;"	m	struct:monty::RawIter
bool	lib/monty/monty.h	/^        auto operator== (Value) const -> bool;$/;"	m	struct:monty::Value
bool	lib/monty/monty.h	/^        auto truthy () const -> bool;$/;"	m	struct:monty::Value
bool	lib/monty/monty.h	/^        inline auto isFalse () const -> bool;$/;"	m	struct:monty::Value
bool	lib/monty/monty.h	/^        inline auto isNone  () const -> bool;$/;"	m	struct:monty::Value
bool	lib/monty/monty.h	/^        inline auto isTrue  () const -> bool;$/;"	m	struct:monty::Value
bool	lib/monty/monty.h	/^        static auto inPool (void const* p) -> bool;$/;"	m	struct:monty::Obj
bool	lib/monty/monty.h	/^        static auto inPool (void const* p) -> bool;$/;"	m	struct:monty::Vec
bool	lib/monty/monty.h	/^        static auto runLoop () -> bool;$/;"	m	struct:monty::Context
bool	lib/monty/monty.h	/^        virtual auto run () -> bool =0;$/;"	m	struct:monty::Context
bool	lib/monty/monty.h	/^    auto gcCheck () -> bool; \/\/ true when it's time to collect the garbage$/;"	m	namespace:monty
bool	tests/native/memTest.cpp	/^        auto adj (size_t sz) -> bool;$/;"	m	struct:mem::Vec	file:
boom1	tests/py/except.py	/^def boom1():$/;"	f
boom2	tests/py/except.py	/^def boom2():$/;"	f
boss	lib/boss/boss.h	/^namespace boss {$/;"	n	class:boss
boss	lib/doctest/doctest.cpp	/^namespace boss {$/;"	n	file:
boss	lib/hall-native/hall.cpp	/^namespace boss { void debugf (const char* fmt, ...); }$/;"	n	file:
bottom	lib/boss/boss.cpp	/^uint32_t* bottom;$/;"	v
box	lib/graphics/twodee.h	/^        static void box (Point p, unsigned w, unsigned h) {$/;"	f	struct:twodee::TwoDee
box	lib/graphics/twodee.h	/^        static void box (Point p1, Point p2)  { box({p1, p2}); }$/;"	f	struct:twodee::TwoDee
box	lib/graphics/twodee.h	/^        static void box (Rect const& r)       { box(r, r.w, r.h); }$/;"	f	struct:twodee::TwoDee
brr	lib/arch-stm32/jee-stm32.h	/^                odr=0x14, bsrr=0x18, afrl=0x20, afrh=0x24, brr=0x28 };$/;"	e	enum:jeeh::Pin::__anon23
brr	lib/arch-stm32/jee-stm32.h	/^        enum { crl=0x00, crh=0x04, idr=0x08, odr=0x0C, bsrr=0x10, brr=0x14 };$/;"	e	enum:jeeh::Pin::__anon22
bsrr	lib/arch-stm32/jee-stm32.h	/^                odr=0x14, bsrr=0x18, afrl=0x20, afrh=0x24, brr=0x28 };$/;"	e	enum:jeeh::Pin::__anon23
bsrr	lib/arch-stm32/jee-stm32.h	/^        enum { crl=0x00, crh=0x04, idr=0x08, odr=0x0C, bsrr=0x10, brr=0x14 };$/;"	e	enum:jeeh::Pin::__anon22
buf	lib/arch-stm32/arch.cpp	/^    char buf [100]; \/\/ TODO avoid hard limit for input line length$/;"	m	struct:LineSerial	file:
buf	lib/doctest/doctest.h	/^        char buf[len];$/;"	m	union:doctest::String::__anon7
buf	lib/mcu/mcu.h	/^    struct Chunk { uint8_t* buf; uint32_t len; };$/;"	m	struct:mcu::Chunk
buf	lib/mcu/printer.h	/^    uint8_t buf [80];$/;"	m	struct:Printer
buf	lib/monty/gc.cpp	/^        uint8_t buf [1];$/;"	m	union:VecSlot::__anon11	file:
buf	lib/monty/parser.h	/^    uint8_t buf [37]; \/\/ len:1, addr:2, type:1, data:0..32, chk:1$/;"	v
buf	lib/monty/type.cpp	/^static char buf [250];$/;"	v	file:
buf	tests/buffers/main.cpp	/^namespace buf {$/;"	n	file:
buf	tests/embed/src/doctestx.h	/^        char buf[len];$/;"	m	union:doctest::String::__anon36
buf	tests/unit/repr/main.cpp	/^static char buf [250];$/;"	v	file:
bufEnd	lib/monty/type.cpp	/^static char* bufEnd;$/;"	v	file:
bufEnd	tests/unit/repr/main.cpp	/^static char* bufEnd;$/;"	v	file:
buffers	lib/boss/boss.cpp	/^    Buf* buffers;$/;"	m	namespace:boss::pool	file:
bufs	tests/buffers/main.cpp	/^    uint8_t* bufs;$/;"	m	namespace:buf	file:
builds	tests/smoke/tasks.py	/^def builds(c):$/;"	f
builtins	lib/monty/monty.h	/^        static Dict builtins;$/;"	m	struct:monty::Module
builtins	tests/py/dir.py	/^import builtins$/;"	i
builtinsMap	lib/monty/builtin.cpp	/^static Lookup::Item const builtinsMap [] = {$/;"	m	class:Lookup	file:
builtins_attrs	lib/monty/builtin.cpp	/^Dict Module::builtins (&builtins_attrs);$/;"	m	class:Module	file:
c	tests/py/bytes.py	/^c = 'abcdefghijklmnopqrstuvwxyz'$/;"	v
c	tests/py/closure.py	/^    def c():$/;"	f	function:three
c	tests/py/closure.py	/^c = three(777)$/;"	v
c	tests/py/derived.py	/^c = C(789)$/;"	v
c	tests/py/int64.py	/^c = 5000000 * -6000000$/;"	v
c	tests/py/iter.py	/^c = [111,222,333]$/;"	v
c	tests/py/unop.py	/^c = -1073741825$/;"	v
c	tests/py/x_cycles.py	/^from machine import cycles as c$/;"	i
c25	tests/py/features.py	/^        class c25:$/;"	c	function:.set
cFill	lib/graphics/twodee.h	/^        static void cFill (Point p, unsigned n) {$/;"	f	struct:twodee::TwoDee
c_str	lib/doctest/doctest.h	/^    char*       c_str() {$/;"	f	class:doctest::String
c_str	lib/doctest/doctest.h	/^    const char* c_str() const { return const_cast<String*>(this)->c_str(); } \/\/ NOLINT$/;"	f	class:doctest::String
c_str	tests/embed/src/doctestx.h	/^    char*       c_str() {$/;"	f	class:doctest::String
c_str	tests/embed/src/doctestx.h	/^    const char* c_str() const { return const_cast<String*>(this)->c_str(); } \/\/ NOLINT$/;"	f	class:doctest::String
callee	lib/pyvm/pyvm.cpp	/^        Value base, spOff, ipOff, callee, ep, locals, result, stack [];$/;"	m	struct:PyVM::Frame	file:
cap	lib/monty/monty.h	/^        auto cap () const { return Vec::cap() \/ sizeof (T); }$/;"	f	struct:monty::VecOf
cap	lib/monty/monty.h	/^        auto cap () const { return _capa; }$/;"	f	struct:monty::Vec
cap	tests/native/memTest.cpp	/^        auto cap () { return _capa; }$/;"	f	struct:mem::Vec
capacity	lib/doctest/doctest.h	/^        unsigned capacity;$/;"	m	struct:doctest::String::view
capacity	tests/embed/src/doctestx.h	/^        unsigned capacity;$/;"	m	struct:doctest::String::view
case_sensitive	lib/doctest/doctest.h	/^    bool case_sensitive;       \/\/ if filtering should be case sensitive$/;"	m	struct:doctest::ContextOptions
case_sensitive	tests/embed/src/doctestx.h	/^    bool case_sensitive;       \/\/ if filtering should be case sensitive$/;"	m	struct:doctest::ContextOptions
caught	lib/pyvm/pyvm.cpp	/^    void caught () {$/;"	f	struct:PyVM
cerr	lib/doctest/doctest.h	/^    std::ostream* cerr;        \/\/ stderr stream - std::cerr by default$/;"	m	struct:doctest::ContextOptions
cerr	tests/embed/src/doctestx.h	/^    std::ostream* cerr;        \/\/ stderr stream - std::cerr by default$/;"	m	struct:doctest::ContextOptions
cfg	src/device.py	/^cfg = configparser.ConfigParser(interpolation=configparser.ExtendedInterpolation())$/;"	v
cfgs	src/codegen.py	/^cfgs  = {}          # map of configuration setting from [config:...]$/;"	v
cgCounts	src/codegen.py	/^cgCounts = 0        # number of CG directives seen in this file$/;"	v
chain	lib/monty/gc.cpp	/^        ObjSlot* chain;$/;"	m	union:ObjSlot::__anon10	file:
chain	tests/buffers/main.cpp	/^    Buf* chain;$/;"	m	namespace:buf	file:
characters	src/xmltodict.py	/^    def characters(self, data):$/;"	m	class:_DictSAXHandler
check	lib/doctest/doctest.h	/^        struct check {$/;"	s	namespace:doctest::detail::has_insertion_operator_impl
check	tests/embed/src/doctestx.h	/^        struct check {$/;"	s	namespace:doctest::detail::has_insertion_operator_impl
checks	lib/monty/monty.h	/^                checks, sweeps, compacts,$/;"	m	struct:monty::GCStats::__anon8
checks	tests/native/memTest.cpp	/^            checks, sweeps, compacts,$/;"	m	struct:GCStats::__anon35	file:
chk	lib/monty/parser.h	/^    uint8_t tag, fill, chk;$/;"	v
circle	lib/graphics/twodee.h	/^        static void circle (Point p, unsigned n) {$/;"	f	struct:twodee::TwoDee
cleanup	lib/arch-native/arch.cpp	/^static void cleanup () {$/;"	f	file:
clear	lib/mcu/mcu.h	/^        inline void clear () { DWT(0x04) = 0; }$/;"	f	namespace:mcu::cycles
clear	lib/monty/monty.h	/^        void clear () { _fill = 0; adj(0); }$/;"	f	struct:monty::VecOf
clearMark	lib/monty/gc.cpp	/^    void clearMark ()              { flag &= ~1; }$/;"	f	struct:ObjSlot
clearPending	lib/mcu/mcu.h	/^        static auto clearPending () {$/;"	f	struct:mcu::Device
cls	lib/graphics/mod-graphics.cpp	/^    static void cls () { pos({0,0}); printf("\\x1B[40m\\x1B[J"); }$/;"	f	struct:Tft
cmd	lib/mcu/mcu.h	/^        void cmd (int arg) {$/;"	f	struct:mcu::SpiFlash
coa	lib/monty/monty.h	/^                coa, cob, cva, cvb, \/\/ curr  Obj\/Vec Allocs\/Bytes$/;"	m	struct:monty::GCStats::__anon8
coa	tests/native/memTest.cpp	/^            coa, cob, cva, cvb, \/\/ curr  Obj\/Vec Allocs\/Bytes$/;"	m	struct:GCStats::__anon35	file:
cob	lib/monty/monty.h	/^                coa, cob, cva, cvb, \/\/ curr  Obj\/Vec Allocs\/Bytes$/;"	m	struct:monty::GCStats::__anon8
cob	tests/native/memTest.cpp	/^            coa, cob, cva, cvb, \/\/ curr  Obj\/Vec Allocs\/Bytes$/;"	m	struct:GCStats::__anon35	file:
code	lib/pyvm/loader.h	/^    int16_t code;$/;"	m	struct:CodePrefix
comments	src/xmltodict.py	/^    def comments(self, data):$/;"	m	class:_DictSAXHandler
compact	lib/monty/gc.cpp	/^    void Vec::compact () {$/;"	f	class:monty::Vec
compact	tests/native/memTest.cpp	/^void Vec::compact () {$/;"	f	class:Vec
compactVecs	tests/unit/mem/main.cpp	/^void compactVecs () {$/;"	f
compacts	lib/monty/monty.h	/^                checks, sweeps, compacts,$/;"	m	struct:monty::GCStats::__anon8
compacts	tests/native/memTest.cpp	/^            checks, sweeps, compacts,$/;"	m	struct:GCStats::__anon35	file:
compareWithExpected	src/runner.py	/^def compareWithExpected (fn, output):$/;"	f
compileAndSend	src/runner.py	/^def compileAndSend(ser, fn):$/;"	f
compileAndSend	src/watcher.py	/^from runner import openSerialPort, compileIfOutdated, compileAndSend$/;"	i
compileIfOutdated	src/mrfs.py	/^from runner import openSerialPort, compileIfOutdated, genHex$/;"	i
compileIfOutdated	src/runner.py	/^def compileIfOutdated(fn):$/;"	f
compileIfOutdated	src/watcher.py	/^from runner import openSerialPort, compileIfOutdated, compileAndSend$/;"	i
configAlt	lib/arch-stm32/arch.h	/^        static void configAlt (AltPins const (&map) [N], int pin, int dev) {$/;"	f	struct:arch::Device
configRegs	lib/arch-stm32/jee-rf69.h	/^    static uint8_t const configRegs [] = {$/;"	m	namespace:jeeh
configparser	src/device.py	/^import configparser, os, re, sys$/;"	i
configure	lib/arch-stm32/jee-rf69.h	/^    void RF69<SPI>::configure (uint8_t const * p) const {$/;"	f	class:jeeh::RF69
console	lib/arch-stm32/arch.cpp	/^UartBufDev< PinA<2>, PinA<15>, 100 > console;$/;"	v
console	lib/arch-stm32/arch.cpp	/^UartBufDev< PinA<2>, PinA<3>, 100 > console;$/;"	v
console	lib/arch-stm32/arch.cpp	/^UartBufDev< PinA<2>, PinD<6>, 100 > console;$/;"	v
console	lib/arch-stm32/arch.cpp	/^UartBufDev< PinA<9>, PinA<10>, 100 > console;$/;"	v
console	lib/arch-stm32/arch.cpp	/^UartBufDev< PinA<9>, PinB<7>, 100 > console;$/;"	v
console	lib/arch-stm32/arch.cpp	/^UartBufDev< PinB<10>, PinB<11>, 100 > console;$/;"	v
console	lib/arch-stm32/arch.cpp	/^UartBufDev< PinC<6>, PinC<7>, 100 > console;$/;"	v
console	lib/arch-stm32/arch.cpp	/^UartBufDev< PinD<8>, PinD<9>, 100 > console;$/;"	v
constData	lib/pyvm/loader.h	/^    ByteVec constData;      \/\/ convert: all collected const data$/;"	m	struct:Loader
constOff	lib/pyvm/loader.h	/^    int16_t constOff;$/;"	m	struct:CodePrefix
count	lib/doctest/doctest.h	/^    bool count;            \/\/ if only the count of matching tests is to be retrieved$/;"	m	struct:doctest::ContextOptions
count	lib/mcu/printer.h	/^    uint16_t count;$/;"	m	struct:Printer
count	src/watcher.py	/^    count = 0$/;"	v
count	tests/embed/src/doctestx.h	/^    bool count;            \/\/ if only the count of matching tests is to be retrieved$/;"	m	struct:doctest::ContextOptions
cout	lib/doctest/doctest.h	/^    std::ostream* cout;        \/\/ stdout stream - std::cout by default$/;"	m	struct:doctest::ContextOptions
cout	tests/embed/src/doctestx.h	/^    std::ostream* cout;        \/\/ stdout stream - std::cout by default$/;"	m	struct:doctest::ContextOptions
crc	lib/mrfs/mrfs.h	/^        uint32_t crc;$/;"	m	struct:mrfs::Info
crc	src/mrfs.py	/^        crc = crc32(dat, crc)$/;"	v
crc	src/mrfs.py	/^        crc = crc32(ftr, crc)$/;"	v
crc	src/mrfs.py	/^        crc = crc32(hdr)$/;"	v
crc	src/mrfs.py	/^        crc = crc32(pad, crc)$/;"	v
crc32	src/mrfs.py	/^from binascii import crc32$/;"	i
created	lib/monty/gc.cpp	/^int created, destroyed, marked, failed;$/;"	v
created	tests/unit/mem/main.cpp	/^int created, destroyed, marked, failed;$/;"	v
crh	lib/arch-stm32/jee-stm32.h	/^        enum { crl=0x00, crh=0x04, idr=0x08, odr=0x0C, bsrr=0x10, brr=0x14 };$/;"	e	enum:jeeh::Pin::__anon22
crl	lib/arch-stm32/jee-stm32.h	/^        enum { crl=0x00, crh=0x04, idr=0x08, odr=0x0C, bsrr=0x10, brr=0x14 };$/;"	e	enum:jeeh::Pin::__anon22
ctrl	lib/arch-stm32/jee-stm32.h	/^        enum { ctrl=0x0, cyccnt=0x4, lar=0xFB0 };$/;"	e	enum:jeeh::DWT::__anon24
curr	lib/boss/boss.cpp	/^Fiber::Fid_t Fiber::curr;$/;"	m	class:Fiber	file:
current	lib/monty/monty.h	/^        static Context* current;$/;"	m	struct:monty::Context
current	lib/monty/stack.cpp	/^Context* Context::current;$/;"	m	class:Context	file:
currentTest	lib/doctest/doctest.h	/^    const detail::TestCase* currentTest = nullptr;$/;"	m	struct:doctest::ContextOptions
currentTest	tests/embed/src/doctestx.h	/^    const detail::TestCase* currentTest = nullptr;$/;"	m	struct:doctest::ContextOptions
cva	lib/monty/monty.h	/^                coa, cob, cva, cvb, \/\/ curr  Obj\/Vec Allocs\/Bytes$/;"	m	struct:monty::GCStats::__anon8
cva	tests/native/memTest.cpp	/^            coa, cob, cva, cvb, \/\/ curr  Obj\/Vec Allocs\/Bytes$/;"	m	struct:GCStats::__anon35	file:
cvb	lib/monty/monty.h	/^                coa, cob, cva, cvb, \/\/ curr  Obj\/Vec Allocs\/Bytes$/;"	m	struct:monty::GCStats::__anon8
cvb	tests/native/memTest.cpp	/^            coa, cob, cva, cvb, \/\/ curr  Obj\/Vec Allocs\/Bytes$/;"	m	struct:GCStats::__anon35	file:
cwrite	tests/py/other/uart.py	/^def cwrite(data):$/;"	f
cyccnt	lib/arch-stm32/jee-stm32.h	/^        enum { ctrl=0x0, cyccnt=0x4, lar=0xFB0 };$/;"	e	enum:jeeh::DWT::__anon24
cycles	lib/hall-stm32/hall.h	/^    namespace cycles {$/;"	n	namespace:hall
cycles	lib/mcu/mcu.h	/^    namespace cycles {$/;"	n	namespace:mcu
d	lib/monty/monty.h	/^        struct Proxy { Dict& d; Value k;$/;"	m	struct:monty::Dict::Proxy
d	src/device.py	/^        d = device['peripherals'][p]$/;"	v
d	tests/py/closure.py	/^        def d():$/;"	f	function:three.c
d	tests/py/derived.py	/^d = D()$/;"	v
d	tests/py/dict.py	/^d = a.items()$/;"	v
d	tests/py/dict.py	/^d = a.keys()$/;"	v
d	tests/py/dict.py	/^d = a.values()$/;"	v
d	tests/py/features.py	/^d = {}$/;"	v
dashed	lib/graphics/twodee.h	/^        static void dashed (Point p1, Point p2, unsigned pattern =0x55555555) {$/;"	f	struct:twodee::TwoDee
dat	src/mrfs.py	/^            dat = dat[end+24:]$/;"	v
dat	src/mrfs.py	/^        dat = fd.read()$/;"	v
data	lib/boss/boss.h	/^        uint8_t data [512]; \/\/ TODO fix this, RasPi needs >256$/;"	m	struct:boss::pool::Buf
data	lib/doctest/doctest.h	/^        view data;$/;"	m	union:doctest::String::__anon7
data	lib/graphics/twodee.h	/^        uint8_t const* data;$/;"	m	struct:twodee::Glyph
data	tests/embed/src/doctestx.h	/^        view data;$/;"	m	union:doctest::String::__anon36
dataSizes	tests/unit/data/main.cpp	/^void dataSizes () {$/;"	f
date	src/mrfs.py	/^    date = int(datetime.fromtimestamp(info.st_mtime).strftime('%y%m%d%H%M'))$/;"	v
datetime	src/mrfs.py	/^from datetime import datetime$/;"	i
db	src/altpins.py	/^    db = { x:{} for x in "TX RX MOSI MISO SCK NSS".split() }$/;"	v
dd	tests/py/closure.py	/^dd = ff(123)$/;"	v
deC	lib/graphics/twodee.h	/^                bbW, bbH, bbX, bbY, asA, deG, asO, deC;$/;"	m	struct:twodee::Font
deG	lib/graphics/twodee.h	/^                bbW, bbH, bbX, bbY, asA, deG, asO, deC;$/;"	m	struct:twodee::Font
debugf	lib/boss/boss.cpp	/^void boss::debugf (const char* fmt, ...) __attribute__ ((weak)) {$/;"	f	class:boss
debugf	lib/doctest/doctest.cpp	/^    void debugf (const char* fmt, ...) {$/;"	f	namespace:boss
debugf	lib/mcu/mcu.cpp	/^    void debugf (const char* fmt, ...) {$/;"	f	namespace:mcu
debugf	lib/pyvm/loader.h	/^#define debugf /;"	d
debugf	lib/pyvm/loader.h	/^#define debugf(/;"	d
debugf	tests/smoke/src/main9.cpp	/^void boss::debugf (const char*, ...) {}$/;"	f	class:boss
decodePrelude	lib/pyvm/loader.h	/^    void decodePrelude (uint8_t const*& dp) {$/;"	f	struct:CodePrefix
defaultOutOfMemoryHandler	lib/monty/gc.cpp	/^static void* defaultOutOfMemoryHandler () { assert(false); return nullptr; }$/;"	f	file:
deferred_false	lib/doctest/doctest.h	/^    struct deferred_false$/;"	s	namespace:doctest::detail
deferred_false	tests/embed/src/doctestx.h	/^    struct deferred_false$/;"	s	namespace:doctest::detail
deinit	lib/arch-stm32/uart-f1.h	/^    void deinit () {$/;"	f	struct:Uart
deinit	lib/arch-stm32/uart-f4.h	/^    void deinit () {$/;"	f	struct:Uart
deinit	lib/arch-stm32/uart-l0.h	/^    void deinit () {$/;"	f	struct:Uart
deinit	lib/arch-stm32/uart-l4.h	/^    void deinit () {$/;"	f	struct:Uart
deinit	lib/boss/boss.cpp	/^    void deinit () {$/;"	f	namespace:boss::pool
deinit	lib/hall-stm32/hall.cpp	/^    void deinit () {$/;"	f	class:hall
deinit	lib/hall-stm32/stm32l4-uart.cpp	/^    void deinit () {$/;"	f	struct:Uart
deinit	lib/hall-stm32/stm32l4-uart.cpp	/^    void deinit (int n) {$/;"	f	namespace:hall::uart
deinit	lib/mcu/uart-stm32f4f7.h	/^    void deinit () {$/;"	f	struct:Uart
deinit	lib/mcu/uart-stm32l4.h	/^    void deinit () {$/;"	f	struct:Uart
delay	src/runner.py	/^                    delay = 0$/;"	v
delay	src/runner.py	/^                delay = 0.04$/;"	v
delay	src/runner.py	/^                delay = 0.3$/;"	v
delay	src/runner.py	/^        delay = 2.5$/;"	v
delay	tests/py/other/x_await.py	/^def delay(n):$/;"	f
delay	tests/py/s_blinker.py	/^def delay(n):$/;"	f
delay	tests/py/serout.py	/^def delay(n):$/;"	f
delay	tests/py/tasks.py	/^def delay(n):$/;"	f
delayLoop	tests/smoke/src/main1.cpp	/^void delayLoop (int n) {$/;"	f
delayLoop	tests/smoke/src/main2.cpp	/^void delayLoop (int n) {$/;"	f
delayLoop	tests/smoke/src/main3.cpp	/^void delayLoop (int n) {$/;"	f
delayLoop	tests/smoke/src/main4.cpp	/^void delayLoop (int n) {$/;"	f
delayLoop	tests/smoke/src/main5.cpp	/^void delayLoop (int n) {$/;"	f
depth	lib/graphics/mod-graphics.cpp	/^    constexpr static auto depth = 3; \/\/ 8 colours$/;"	m	struct:Tft	file:
deregHandler	lib/monty/stack.cpp	/^void Event::deregHandler () {$/;"	f	class:Event
descs	src/codegen.py	/^descs = {"": {}}    # map of function parse descriptors per type\/module$/;"	v
destroyed	lib/monty/gc.cpp	/^int created, destroyed, marked, failed;$/;"	v
destroyed	tests/unit/mem/main.cpp	/^int created, destroyed, marked, failed;$/;"	v
detail	lib/doctest/doctest.h	/^namespace detail {$/;"	n	namespace:doctest
detail	tests/embed/src/doctestx.h	/^namespace detail {$/;"	n	namespace:doctest
detect	lib/mcu/mcu.h	/^        void detect () const {$/;"	f	struct:mcu::I2cGpio
dev	lib/arch-stm32/altpins.h	/^struct AltPins { uint8_t pin, dev :4, alt :4; };$/;"	m	struct:AltPins
dev	lib/arch-stm32/uart-f1.h	/^    DevInfo dev;$/;"	m	struct:Uart
dev	lib/arch-stm32/uart-f4.h	/^    DevInfo dev;$/;"	m	struct:Uart
dev	lib/arch-stm32/uart-l0.h	/^    DevInfo dev;$/;"	m	struct:Uart
dev	lib/arch-stm32/uart-l4.h	/^    DevInfo dev;$/;"	m	struct:Uart
dev	lib/hall-stm32/hall.h	/^    namespace dev {$/;"	n	namespace:hall
dev	lib/hall-stm32/stm32l4-uart.cpp	/^    UartInfo dev;$/;"	m	struct:Uart	file:
dev	lib/mcu/altpins.h	/^struct AltPins { uint8_t pin, dev :4, alt :4; };$/;"	m	struct:AltPins
dev	lib/mcu/uart-stm32f4f7.h	/^    DevInfo dev;$/;"	m	struct:Uart
dev	lib/mcu/uart-stm32l4.h	/^    DevInfo dev;$/;"	m	struct:Uart
devId	lib/mcu/mcu.h	/^        auto devId () {$/;"	f	struct:mcu::SpiFlash
devMap	lib/arch-stm32/arch.cpp	/^arch::Device* arch::Device::devMap [];$/;"	m	class:arch::Device	file:
devMap	lib/arch-stm32/arch.h	/^        static Device* devMap [20]; \/\/ large enough to handle all device objects$/;"	m	struct:arch::Device
devMap	lib/hall-stm32/hall.cpp	/^Device* devMap [20];  \/\/ must be large enough to hold all device objects$/;"	v
devMap	lib/mcu/mcu.cpp	/^    Device* Device::devMap [20]; \/\/ large enough to handle all device objects$/;"	m	class:mcu::Device	file:
devMap	lib/mcu/mcu.h	/^        static Device* devMap [];$/;"	m	struct:mcu::Device
devNext	lib/hall-stm32/hall.cpp	/^uint8_t devNext;$/;"	v
devReg	lib/hall-stm32/stm32l4-uart.cpp	/^    auto devReg (int off, int bit, uint8_t num =1) const {$/;"	f	struct:Uart
devReg	lib/hall-stm32/stm32l4-uart.cpp	/^    auto& devReg (int off) const {$/;"	f	struct:Uart
device	lib/arch-stm32/arch.h	/^namespace device {$/;"	n
device	lib/mcu/mcu.h	/^namespace device {$/;"	n
dictInsDel	tests/unit/array/main.cpp	/^static void dictInsDel () {$/;"	f	file:
didRecv	lib/mcu/mcu.h	/^        virtual void didRecv (uint32_t) {}$/;"	f	struct:mcu::Stream
dirs	src/codegen.py	/^dirs  = {}          # map of scanned dirnames to path, see IF$/;"	v
disable	lib/arch-stm32/jee-stm32.h	/^        void disable () const { _nsel = 1; }$/;"	f	struct:jeeh::SpiGpio
disable	lib/mcu/mcu.h	/^        void disable () const { _nsel = 1; }$/;"	f	struct:mcu::SpiGpio
dma	lib/hall-stm32/stm32l4-uart.cpp	/^    uint16_t dma :1, rxChan :4, rxStream :3, txChan :4, txStream :3;$/;"	m	struct:UartInfo	file:
dmaBase	lib/hall-stm32/stm32l4-uart.cpp	/^    auto dmaBase () const { return dmaInfo[dma].base; }$/;"	f	struct:UartInfo
dmaInfo	lib/arch-stm32/prelude.h	/^DmaInfo const dmaInfo [] = {$/;"	m	struct:IrqVec
dmaInfo	lib/hall-stm32/stm32l4-uart.cpp	/^DmaInfo const dmaInfo [] = {$/;"	v
dmaInfo	lib/mcu/prelude.h	/^DmaInfo const dmaInfo [] = {$/;"	m	struct:IrqVec
dmaRX	lib/hall-stm32/stm32l4-uart.cpp	/^    auto dmaRX (int off, int bit, uint8_t num =1) const {$/;"	f	struct:Uart
dmaRX	lib/hall-stm32/stm32l4-uart.cpp	/^    auto& dmaRX (int off) const {$/;"	f	struct:Uart
dmaReg	lib/hall-stm32/stm32l4-uart.cpp	/^    auto& dmaReg (int off) const {$/;"	f	struct:Uart
dmaTX	lib/hall-stm32/stm32l4-uart.cpp	/^    auto dmaTX (int off, int bit, uint8_t num =1) const {$/;"	f	struct:Uart
dmaTX	lib/hall-stm32/stm32l4-uart.cpp	/^    auto& dmaTX (int off) const {$/;"	f	struct:Uart
dmas	src/device.py	/^dmas = []$/;"	v
doctest	lib/doctest/doctest.h	/^namespace doctest {$/;"	n
doctest	lib/mrfs/test.py	/^import doctest, os, subprocess$/;"	i
doctest	tests/embed/src/doctestx.h	/^namespace doctest {$/;"	n
dp	lib/pyvm/loader.h	/^    uint8_t const* dp;$/;"	m	struct:Loader
drxBits	src/device.py	/^    drxBits = patch("dma_uart_rx")$/;"	v
dry	src/codegen.py	/^            dry = True$/;"	v
dry	src/codegen.py	/^dry   = False       # true if this is a dry-run, i.e. "-n" flag set$/;"	v
dtxBits	src/device.py	/^    dtxBits = patch("dma_uart_tx")$/;"	v
duff	lib/boss/boss.cpp	/^void Fiber::duff (uint32_t* dst, uint32_t const* src, uint32_t cnt) {$/;"	f	class:Fiber
dump	lib/monty/data.cpp	/^void Value::dump (char const* msg) const {$/;"	f	class:Value
dump	lib/mrfs/mrfs.cpp	/^void mrfs::dump () {$/;"	f	class:mrfs
dump	tests/buffers/main.cpp	/^    void Queue::dump (char const* msg) const {$/;"	f	class:buf::Queue
dumpAll	lib/monty/gc.cpp	/^    void Obj::dumpAll () {$/;"	f	class:monty::Obj
dumpAll	lib/monty/gc.cpp	/^    void Vec::dumpAll () {$/;"	f	class:monty::Vec
duration	lib/doctest/doctest.h	/^    bool duration;             \/\/ print the time duration of each test case$/;"	m	struct:doctest::ContextOptions
duration	tests/embed/src/doctestx.h	/^    bool duration;             \/\/ print the time duration of each test case$/;"	m	struct:doctest::ContextOptions
dwt	lib/arch-stm32/jee-stm32.h	/^        constexpr uint32_t dwt   = 0xE0001000;$/;"	m	namespace:jeeh::DWT
dx	lib/graphics/twodee.h	/^        int16_t x0 =0, y0 =0, x1, y1, err, dx, dy;$/;"	m	struct:twodee::LineIter
dy	lib/graphics/twodee.h	/^        int16_t x0 =0, y0 =0, x1, y1, err, dx, dy;$/;"	m	struct:twodee::LineIter
dy	lib/hall-stm32/hall.h	/^        struct DateTime { uint8_t yr, mo, dy, hh, mm, ss; };$/;"	m	struct:hall::rtc::DateTime
dy	lib/mcu/mcu.h	/^        struct DateTime { uint8_t yr, mo, dy, hh, mm, ss; };$/;"	m	struct:mcu::rtc::DateTime
e	src/device.py	/^            e = enaBits[n-1] if n-1 < len(enaBits) else "0"$/;"	v
e	src/device.py	/^        e = enaBits[n-1] if n-1 < len(enaBits) else "0"$/;"	v
e	src/runner.py	/^        e = compileAndSend(ser, fn)$/;"	v
e	src/watcher.py	/^            e = compileAndSend(ser, fn)$/;"	v
emit	lib/mcu/printer.h	/^    void emit (int c) {$/;"	f	struct:Printer
emit	src/altpins.py	/^def emit():$/;"	f
emptyObj	lib/monty/monty.h	/^        static Tuple const emptyObj;$/;"	m	struct:monty::Tuple
emptyObj	lib/monty/type.cpp	/^Tuple const Tuple::emptyObj;$/;"	m	class:Tuple	file:
ena	lib/arch-stm32/prelude.h	/^    uint8_t pos :4, num :4, ena;$/;"	m	struct:IrqVec::DevInfo
ena	lib/hall-stm32/stm32l4-uart.cpp	/^    uint8_t num :4, ena, irq;$/;"	m	struct:UartInfo	file:
ena	lib/mcu/prelude.h	/^    uint8_t pos :4, num :4, ena;$/;"	m	struct:IrqVec::DevInfo
enaBits	src/device.py	/^    enaBits = patch("ena_spi")$/;"	v
enaBits	src/device.py	/^    enaBits = patch("ena_uart")$/;"	v
enable	lib/arch-stm32/jee-stm32.h	/^        void enable () const { _nsel = 0; }$/;"	f	struct:jeeh::SpiGpio
enable	lib/mcu/mcu.h	/^        void enable () const { _nsel = 0; }$/;"	f	struct:mcu::SpiGpio
enableClkMaxMSI	lib/hall-stm32/stm32l4.cpp	/^    void enableClkMaxMSI () { \/\/ using internal 48 MHz MSI$/;"	f	namespace:hall
enableClkSaver	lib/hall-stm32/stm32l4.cpp	/^    void enableClkSaver (int range) { \/\/ using MSI at 100 kHz to 4 MHz$/;"	f	namespace:hall
enableClkWithPLL	lib/hall-stm32/stm32l4.cpp	/^    void enableClkWithPLL () { \/\/ using internal 16 MHz HSI$/;"	f	namespace:hall
enableSysTick	lib/arch-stm32/mod-machine.cpp	/^void enableSysTick (uint32_t divider) {$/;"	f
enable_if	lib/doctest/doctest.h	/^    struct enable_if$/;"	s	namespace:doctest::detail
enable_if	lib/doctest/doctest.h	/^    struct enable_if<true, TYPE>$/;"	s	namespace:doctest::detail
enable_if	tests/embed/src/doctestx.h	/^    struct enable_if$/;"	s	namespace:doctest::detail
enable_if	tests/embed/src/doctestx.h	/^    struct enable_if<true, TYPE>$/;"	s	namespace:doctest::detail
encrypt	lib/arch-stm32/jee-rf69.h	/^    void RF69<SPI>::encrypt (char const* key) const {$/;"	f	class:jeeh::RF69
end	lib/graphics/mod-graphics.cpp	/^    static void end ()              {}$/;"	f	struct:Tft
end	lib/monty/monty.h	/^        auto end () const { return begin() + size(); }$/;"	f	struct:monty::ArgVec
end	lib/monty/monty.h	/^        constexpr auto end () const { return begin() + _fill; }$/;"	f	struct:monty::VecOf
end	src/mrfs.py	/^            end = 8 + siz + (-siz&31)$/;"	v
endElement	src/xmltodict.py	/^    def endElement(self, full_name):$/;"	m	class:_DictSAXHandler
ensure	lib/mcu/mcu.h	/^#define ensure(/;"	d
enter	lib/pyvm/pyvm.cpp	/^    void enter (Callable const& func) {$/;"	f	struct:PyVM
eof	lib/mcu/mcu.cpp	/^    uint8_t Stream::eof;$/;"	m	class:mcu::Stream	file:
eof	lib/mcu/mcu.h	/^        static uint8_t eof;$/;"	m	struct:mcu::Stream
ep	lib/pyvm/pyvm.cpp	/^        Value base, spOff, ipOff, callee, ep, locals, result, stack [];$/;"	m	struct:PyVM::Frame	file:
erase	lib/mcu/mcu.h	/^        void erase (int offset) {$/;"	f	struct:mcu::SpiFlash
err	lib/graphics/twodee.h	/^        int16_t r, x, y, err;$/;"	m	struct:twodee::ArcIter
err	lib/graphics/twodee.h	/^        int16_t x0 =0, y0 =0, x1, y1, err, dx, dy;$/;"	m	struct:twodee::LineIter
even	tests/py/polyfill.py	/^def even(i):$/;"	f
evt	tests/py/event.py	/^evt = machine.ticker(10)$/;"	v
evt	tests/py/s_blinker.py	/^evt = machine.ticker(10)$/;"	v
evt	tests/py/s_rf69.py	/^evt = machine.ticker(10)$/;"	v
evt	tests/py/serout.py	/^evt = machine.ticker(50)$/;"	v
evt	tests/py/tasks.py	/^evt = machine.ticker(10)$/;"	v
evt	tests/py/timer.py	/^evt = machine.ticker(10)$/;"	v
excDefs	src/codegen.py	/^excDefs = []    # per id, attribute table definition$/;"	v
excFuns	src/codegen.py	/^excFuns = []    # per id, code defining an exception as callable function$/;"	v
excHier	src/codegen.py	/^excHier = []    # per id, code to emit, w\/ parent reference$/;"	v
excIds	src/codegen.py	/^excIds = {}     # map exception name -> id$/;"	v
exception	lib/monty/stack.cpp	/^void Context::exception (Value e) {$/;"	f	class:Context
exceptionMap	lib/monty/builtin.cpp	/^static Lookup::Item const exceptionMap [] = {$/;"	m	class:Lookup	file:
exit	lib/doctest/doctest.h	/^    bool exit;                 \/\/ if the program should be exited after the tests are ran\/whatever$/;"	m	struct:doctest::ContextOptions
exit	tests/embed/src/doctestx.h	/^    bool exit;                 \/\/ if the program should be exited after the tests are ran\/whatever$/;"	m	struct:doctest::ContextOptions
expMap	lib/monty/monty.h	/^        auto expMap () const {$/;"	f	struct:monty::ArgVec
expSeq	lib/monty/monty.h	/^        auto expSeq () const {$/;"	f	struct:monty::ArgVec
expat	src/xmltodict.py	/^    from defusedexpat import pyexpat as expat$/;"	i
expat	src/xmltodict.py	/^    from xml.parsers import expat$/;"	i
expire	lib/boss/boss.cpp	/^void Semaphore::expire (uint16_t now, uint16_t& limit) {$/;"	f	class:Semaphore
expire	lib/boss/boss.h	/^        virtual void expire (uint16_t, uint16_t&) {}$/;"	f	struct:boss::boss::Device
expire	lib/hall-stm32/stm32l4-uart.cpp	/^    void expire (uint16_t now, uint16_t& limit) {$/;"	f	struct:Uart
ext	src/mrfs.py	/^        ext = '.mpy'$/;"	v
extract	src/altpins.py	/^def extract(fname):$/;"	f
f	tests/py/argexp.py	/^def f(*a):$/;"	f
f	tests/py/args.py	/^def f(*a):$/;"	f
f	tests/py/array.py	/^def f(t,n=3):$/;"	f
f	tests/py/bound.py	/^    def f(self,*args):$/;"	m	class:A
f	tests/py/derived.py	/^    def f(self):$/;"	m	class:A
f	tests/py/derived.py	/^    def f(self):$/;"	m	class:C
f	tests/py/dir.py	/^def f(t):$/;"	f
f	tests/py/except.py	/^def f(t):$/;"	f
f	tests/py/features.py	/^def f():$/;"	f
f	tests/py/features.py	/^def f(i=i):$/;"	f
f	tests/py/finally.py	/^def f(throw):$/;"	f
f	tests/py/gcoll.py	/^def f():$/;"	f
f	tests/py/import.py	/^from args import f$/;"	i
f	tests/py/kwargs.py	/^def f(aa, bb=22, cc=33):$/;"	f
f	tests/py/lambda.py	/^f = lambda x: x * x$/;"	v
f	tests/py/repr.py	/^    def f(self):$/;"	m	class:B
f	tests/py/tracebk.py	/^def f(x):$/;"	f
failAt	lib/boss/boss.cpp	/^void boss::failAt (void const* pc, void const* lr) {$/;"	f	class:boss
failAt	lib/mcu/mcu.cpp	/^    void failAt (void const* pc, void const* lr) { \/\/ weak, can be redefined$/;"	f	namespace:mcu
failed	lib/monty/gc.cpp	/^int created, destroyed, marked, failed;$/;"	v
failed	tests/unit/mem/main.cpp	/^int created, destroyed, marked, failed;$/;"	v
falseObj	lib/monty/data.cpp	/^Bool const Bool::falseObj;$/;"	m	class:Bool	file:
falseObj	lib/monty/monty.h	/^        static Bool const trueObj, falseObj;$/;"	m	struct:monty::Bool
fd	src/mrfs.py	/^        fd = ofile or open(fnOut, 'wb')$/;"	v
feed	lib/monty/parser.h	/^    auto feed (uint8_t const* ptr, int len) {$/;"	f
ff	tests/py/closure.py	/^def ff(x):$/;"	f
fg	lib/graphics/twodee.h	/^        static int fg, bg;$/;"	m	struct:twodee::TwoDee
fg	lib/graphics/twodee.h	/^    int TwoDee<G>::fg = (1 << G::depth) - 1;$/;"	m	class:twodee::TwoDee
fib2	tests/py/features.py	/^def fib2(n):$/;"	f
files	src/codegen.py	/^            files = os.listdir(arg)$/;"	v
files	src/mrfs.py	/^        files = {}$/;"	v
fill	lib/arch-stm32/arch.cpp	/^    uint32_t fill = 0;$/;"	m	struct:LineSerial	file:
fill	lib/graphics/twodee.h	/^        int8_t fill;$/;"	m	struct:twodee::Glyph
fill	lib/mcu/printer.h	/^    int8_t pad, width, radix, fill, limit;$/;"	m	struct:Printer
fill	lib/monty/parser.h	/^    uint8_t tag, fill, chk;$/;"	v
find	lib/mrfs/mrfs.cpp	/^static void find (int ac, char const** av) {$/;"	f	file:
findAlt	lib/arch-stm32/altpins.h	/^constexpr auto findAlt (AltPins const (&map) [N], char const* name, int dev) {$/;"	f
findAlt	lib/mcu/altpins.h	/^constexpr auto findAlt (AltPins const (&map) [N], char const* name, int dev) {$/;"	f
findHeaders	src/tdd.py	/^def findHeaders():$/;"	f
findSerialPorts	src/runner.py	/^def findSerialPorts():$/;"	f
first	lib/doctest/doctest.h	/^    unsigned first; \/\/ the first (matching) test to be executed$/;"	m	struct:doctest::ContextOptions
first	lib/monty/monty.h	/^        auto first () const { return begin(); }$/;"	f	struct:monty::VaryVec
first	tests/embed/src/doctestx.h	/^    unsigned first; \/\/ the first (matching) test to be executed$/;"	m	struct:doctest::ContextOptions
five	tests/py/features.py	/^five = 25 \/\/ 5$/;"	v
flag	lib/monty/gc.cpp	/^        uintptr_t flag; \/\/ bit 0 set for marked objects$/;"	m	union:ObjSlot::__anon10	file:
flag	lib/pyvm/loader.h	/^    int8_t flag;    \/\/ flag bits$/;"	m	struct:CodePrefix
flags	lib/mrfs/mrfs.h	/^        uint32_t flags :8;$/;"	m	struct:mrfs::Info
flags	src/codegen.py	/^flags = Flags()     # this is cleared for each new source file$/;"	v
flush	lib/mcu/printer.h	/^    void flush () {$/;"	f	struct:Printer
fn	src/mrfs.py	/^        fn = compileIfOutdated(fn)$/;"	v
fnOut	src/mrfs.py	/^    fnOut = base + '.mrfs'$/;"	v
font	lib/graphics/twodee.h	/^        Font const& font;$/;"	m	struct:twodee::Glyph
foo	tests/py/features.py	/^def foo(): return 38$/;"	f
force_colors	lib/doctest/doctest.h	/^    bool force_colors;         \/\/ forces the use of colors even when a tty cannot be detected$/;"	m	struct:doctest::ContextOptions
force_colors	tests/embed/src/doctestx.h	/^    bool force_colors;         \/\/ forces the use of colors even when a tty cannot be detected$/;"	m	struct:doctest::ContextOptions
fpath	src/codegen.py	/^        fpath = path.join(base, arg)$/;"	v
free	tests/buffers/main.cpp	/^    Queue free;$/;"	m	namespace:buf	file:
freeBufs	lib/boss/boss.cpp	/^    Queue freeBufs;$/;"	m	namespace:boss::pool	file:
ftr	src/mrfs.py	/^        ftr = pack('16s I', os.path.basename(nam)[:15].encode(), date)$/;"	v
fun	lib/mcu/printer.h	/^    void (*fun) (void*, uint8_t const*, int);$/;"	m	struct:Printer
funs	src/codegen.py	/^funs  = {"": []}    # list of bound functions per type\/module$/;"	v
g	src/device.py	/^            g = d['group_name'].upper()$/;"	v
g	tests/py/args.py	/^def g(a,b=9):$/;"	f
g	tests/py/bound.py	/^g = a.f$/;"	v
g	tests/py/except.py	/^def g(e):$/;"	f
g	tests/py/import.py	/^from args import g$/;"	i
g	tests/py/kwargs.py	/^def g(aa, bb, cc=33, dd=44):$/;"	f
g	tests/py/lambda.py	/^g = lambda x: x + n$/;"	v
g	tests/py/tracebk.py	/^def g(x):$/;"	f
g	tests/tdd/main.cpp	/^auto& g (S&& s) { return s; }$/;"	f
gcAll	lib/monty/stack.cpp	/^void Context::gcAll () {$/;"	f	class:Context
gcReport	lib/monty/gc.cpp	/^    void gcReport () {$/;"	f	namespace:monty
gcRomOrRam	tests/unit/mem/main.cpp	/^void gcRomOrRam () {$/;"	f
gcSetup	lib/monty/gc.cpp	/^    void gcSetup (void* base, uint32_t size) {$/;"	f	namespace:monty
gcStats	lib/monty/gc.cpp	/^GCStats monty::gcStats;$/;"	m	class:monty	file:
gcStats	tests/native/memTest.cpp	/^GCStats gcStats;$/;"	v
gcTypeSizes	tests/unit/mem/main.cpp	/^void gcTypeSizes () {$/;"	f
gcheck	tests/py/features.py	/^        def gcheck():$/;"	f	function:.set
gen	tests/py/gen.py	/^def gen():$/;"	f
genHex	src/mrfs.py	/^from runner import openSerialPort, compileIfOutdated, genHex$/;"	i
genHex	src/runner.py	/^def genHex(data, off=None):$/;"	f
generate	tests/smoke/tasks.py	/^def generate(c):$/;"	f
gfx	lib/graphics/mod-graphics.cpp	/^TwoDee<Tft> gfx;$/;"	v
glyphs	lib/graphics/twodee.h	/^        uint8_t const* glyphs;$/;"	m	struct:twodee::Font
gnu_file_line	lib/doctest/doctest.h	/^    bool gnu_file_line;        \/\/ if line numbers should be surrounded with :x: and not (x):$/;"	m	struct:doctest::ContextOptions
gnu_file_line	tests/embed/src/doctestx.h	/^    bool gnu_file_line;        \/\/ if line numbers should be surrounded with :x: and not (x):$/;"	m	struct:doctest::ContextOptions
gpio	tests/gpio/gpio.cpp	/^namespace gpio {$/;"	n	file:
gpio32	lib/hall-stm32/hall.h	/^        auto gpio32 (int off, int bit, uint8_t num =1) const {$/;"	f	struct:hall::Pin
graphics_map	lib/graphics/mod-graphics.cpp	/^static Lookup::Item const graphics_map [] = {$/;"	m	class:Lookup	file:
groups	src/device.py	/^groups = {}$/;"	v
h	lib/graphics/twodee.h	/^        uint16_t w, h;$/;"	m	struct:twodee::Rect
h	src/codegen.py	/^            h = "%s.h" % b$/;"	v
h	tests/py/args.py	/^def h(a,b,p=11,q=12,r=13,s=14):$/;"	f
h	tests/py/kwargs.py	/^def h(aa, bb, *args):$/;"	f
hLine	lib/graphics/twodee.h	/^        static void hLine (Point p, unsigned w, unsigned c =fg) {$/;"	f	struct:twodee::TwoDee
hall	lib/hall-native/hall.h	/^namespace hall {$/;"	n
hall	lib/hall-stm32/hall.h	/^namespace hall {$/;"	n
hall	lib/hall-stm32/stm32l4.cpp	/^namespace hall {$/;"	n	file:
handle_item	src/xmltodict.py	/^    def handle_item(path, item):$/;"	f
has_insertion_operator_impl	lib/doctest/doctest.h	/^    namespace has_insertion_operator_impl {$/;"	n	namespace:doctest::detail
has_insertion_operator_impl	tests/embed/src/doctestx.h	/^    namespace has_insertion_operator_impl {$/;"	n	namespace:doctest::detail
hash	src/codegen.py	/^def hash(s):$/;"	f
hdr	src/mrfs.py	/^        hdr = pack('4s I', b'mty0', size)$/;"	v
hdrs	src/codegen.py	/^hdrs  = {"": []}    # list of same-name headers per architecture$/;"	v
hello	tests/py/import.py	/^import hello$/;"	i
help	lib/doctest/doctest.h	/^    bool help;             \/\/ to print the help$/;"	m	struct:doctest::ContextOptions
help	tests/embed/src/doctestx.h	/^    bool help;             \/\/ to print the help$/;"	m	struct:doctest::ContextOptions
help	tests/smoke/tasks.py	/^def help(c):$/;"	f
hexAddr	lib/monty/parser.h	/^    auto hexAddr () const { return 256*buf[1] + buf[2]; }$/;"	f
hexData	lib/monty/parser.h	/^    auto hexData () const { return buf+4; }$/;"	f
hexSize	lib/monty/parser.h	/^    auto hexSize () const { return buf[0]; }$/;"	f
hexType	lib/monty/parser.h	/^    auto hexType () const { return buf[3]; }$/;"	f
hh	lib/hall-stm32/hall.h	/^        struct DateTime { uint8_t yr, mo, dy, hh, mm, ss; };$/;"	m	struct:hall::rtc::DateTime
hh	lib/mcu/mcu.h	/^        struct DateTime { uint8_t yr, mo, dy, hh, mm, ss; };$/;"	m	struct:mcu::rtc::DateTime
hiddenTypes	src/codegen.py	/^hiddenTypes = []$/;"	v
high	tests/native/memTest.cpp	/^        struct Slot *low, *high;$/;"	m	namespace:mem::vec	typeref:struct:mem::vec::	file:
hold	lib/mcu/mcu.h	/^        void hold () const {$/;"	f	struct:mcu::I2cGpio
horLine	lib/graphics/twodee.h	/^        static void horLine (Point p, unsigned w, unsigned c) {$/;"	f	struct:twodee::TwoDee
i	tests/py/dict.py	/^i = iter(a)$/;"	v
i	tests/py/dict.py	/^i = iter(a.items())$/;"	v
i	tests/py/dict.py	/^i = iter(a.keys())$/;"	v
i	tests/py/dict.py	/^i = iter(a.values())$/;"	v
i	tests/py/event.py	/^i = 0$/;"	v
i	tests/py/features.py	/^i = 43$/;"	v
i	tests/py/features.py	/^i = 44$/;"	v
i	tests/py/unop.py	/^i = 123$/;"	v
iargs	src/runner.py	/^            iargs = next(args).split(",")$/;"	v
id	lib/boss/boss.h	/^        auto id () const { return asId(this); }$/;"	f	struct:boss::pool::Buf
id	lib/boss/boss.h	/^        auto id () const { return pool::Buf::asId(this); }$/;"	f	struct:boss::boss::Fiber
id	lib/monty/monty.h	/^        auto id () const { return _v; }$/;"	f	struct:monty::Value
id	tests/tdd/main.cpp	/^    int id = ++seq;$/;"	m	struct:S	file:
idle	lib/arch-native/arch.cpp	/^void arch::idle () {$/;"	f	class:arch
idle	lib/hall-native/hall.cpp	/^void hall::idle () {$/;"	f	class:hall
idle	lib/hall-stm32/hall.cpp	/^void hall::idle () {$/;"	f	class:hall
idle	lib/mcu/mcu.cpp	/^    void idle () { asm ("wfi"); } \/\/ weak idle handler, can be redefined$/;"	f	namespace:mcu
idr	lib/arch-stm32/jee-stm32.h	/^        enum { crl=0x00, crh=0x04, idr=0x08, odr=0x0C, bsrr=0x10, brr=0x14 };$/;"	e	enum:jeeh::Pin::__anon22
idr	lib/arch-stm32/jee-stm32.h	/^        enum { moder=0x00, typer=0x04, ospeedr=0x08, pupdr=0x0C, idr=0x10,$/;"	e	enum:jeeh::Pin::__anon23
ifType	lib/monty/monty.h	/^        auto ifType () const { return check(T::info) ? (T*) _o : nullptr; }$/;"	f	struct:monty::Value
ihex	lib/arch-stm32/arch.cpp	/^    IntelHex<32> ihex; \/\/ max 32 data bytes per hex input line$/;"	m	struct:HexSerial	file:
image	lib/mrfs/test.py	/^def image():$/;"	f
incoming	lib/arch-stm32/arch.cpp	/^    Event& incoming;$/;"	m	struct:LineSerial	file:
info	lib/arch-stm32/mod-machine.cpp	/^    static Type info;$/;"	m	struct:Pins	file:
info	lib/arch-stm32/mod-machine.cpp	/^    static Type info;$/;"	m	struct:RF69	file:
info	lib/arch-stm32/mod-machine.cpp	/^    static Type info;$/;"	m	struct:Spi	file:
info	lib/monty/monty.h	/^        static Type info;$/;"	m	struct:monty::Inst
info	lib/monty/monty.h	/^        static const Type info;$/;"	m	struct:monty::Object
info	lib/monty/type.cpp	/^    static Type info;$/;"	m	struct:DictView	file:
info	lib/pyvm/loader.h	/^    static Type info;$/;"	m	struct:Bytecode
info	lib/pyvm/pyvm.cpp	/^    static Type info;$/;"	m	struct:BoundMeth	file:
info	lib/pyvm/pyvm.cpp	/^    static Type info;$/;"	m	struct:Callable	file:
info	lib/pyvm/pyvm.cpp	/^    static Type info;$/;"	m	struct:Cell	file:
info	lib/pyvm/pyvm.cpp	/^    static Type info;$/;"	m	struct:Closure	file:
info	lib/pyvm/pyvm.cpp	/^    static Type info;$/;"	m	struct:PyVM	file:
info	src/mrfs.py	/^    info = os.stat(fn)$/;"	v
init	lib/arch-native/arch.cpp	/^void arch::init (int size) {$/;"	f	class:arch
init	lib/arch-stm32/jee-rf69.h	/^    void RF69<SPI>::init (uint8_t id, uint8_t group, int freq) {$/;"	f	class:jeeh::RF69
init	lib/arch-stm32/jee-stm32.h	/^        static void init () {$/;"	f	namespace:jeeh::DWT
init	lib/arch-stm32/jee-stm32.h	/^        void init () {$/;"	f	struct:jeeh::SpiGpio
init	lib/arch-stm32/uart-f1.h	/^    void init () {$/;"	f	struct:Uart
init	lib/arch-stm32/uart-f4.h	/^    void init () {$/;"	f	struct:Uart
init	lib/arch-stm32/uart-l0.h	/^    void init () {$/;"	f	struct:Uart
init	lib/arch-stm32/uart-l4.h	/^    void init () {$/;"	f	struct:Uart
init	lib/boss/boss.cpp	/^    void init (void* ptr, size_t len) {$/;"	f	namespace:boss::pool
init	lib/graphics/mod-graphics.cpp	/^    static void init () {}$/;"	f	struct:Tft
init	lib/hall-stm32/stm32l4-uart.cpp	/^    void init (char const* desc, uint32_t rate) {$/;"	f	struct:Uart
init	lib/hall-stm32/stm32l4-uart.cpp	/^    void init (int n, char const* desc, int baud) {$/;"	f	namespace:hall::uart
init	lib/hall-stm32/stm32l4.cpp	/^        void init () {$/;"	f	namespace:hall::rtc
init	lib/mcu/mcu.h	/^        void init (char const* defs) {$/;"	f	struct:mcu::SpiGpio
init	lib/mcu/mcu.h	/^        void init (char const* defs, uint16_t rate =20) {$/;"	f	struct:mcu::I2cGpio
init	lib/mcu/uart-stm32f4f7.h	/^    void init () {$/;"	f	struct:Uart
init	lib/mcu/uart-stm32l4.h	/^    void init () {$/;"	f	struct:Uart
init	lib/mrfs/mrfs.cpp	/^void mrfs::init (void* ptr, size_t len, size_t keep) {$/;"	f	class:mrfs
init	tests/buffers/main.cpp	/^    void init (void* ptr, size_t len) {$/;"	f	namespace:buf
init	tests/native/memTest.cpp	/^    void init (void* base, size_t size) {$/;"	f	namespace:mem::vec
initLCD	lib/graphics/mod-graphics.cpp	/^static void initLCD () {}$/;"	f	file:
initLed	tests/smoke/src/main2.cpp	/^void initLed () {$/;"	f
initLed	tests/smoke/src/main3.cpp	/^void initLed () {$/;"	f
initMem	tests/unit/mem/main.cpp	/^void initMem () {$/;"	f
initUart	tests/smoke/src/main3.cpp	/^void initUart () {$/;"	f
initUart	tests/smoke/src/main4.cpp	/^void initUart () {$/;"	f
initUart	tests/smoke/src/main5.cpp	/^void initUart () {$/;"	f
initUart	tests/smoke/src/main6.cpp	/^void initUart () {$/;"	f
inner	lib/pyvm/pyvm.cpp	/^    void inner () {$/;"	f	struct:PyVM
insert	lib/boss/boss.cpp	/^    void Queue::insert (Id_t id) {$/;"	f	class:boss::pool::Queue
insert	lib/boss/boss.h	/^        void insert (void* p) { insert(Buf::asId(p)); }$/;"	f	struct:boss::pool::Queue
insert	lib/extend/typ-array.cpp	/^void Array::insert (uint32_t idx, uint32_t num) {$/;"	f	class:Array
insert	lib/monty/monty.h	/^        void insert (uint32_t idx, uint32_t num =1) {$/;"	f	struct:monty::VecOf
insert	lib/monty/type.cpp	/^void VaryVec::insert (uint32_t idx, uint32_t num) {$/;"	f	class:VaryVec
insert	tests/buffers/main.cpp	/^    void Queue::insert (Buf b) {$/;"	f	class:buf::Queue
installIrq	lib/arch-stm32/arch.h	/^        void installIrq (uint32_t irq) {$/;"	f	struct:arch::Device
instructionTrace	lib/pyvm/pyvm.cpp	/^    void instructionTrace () {$/;"	f	struct:PyVM
int64_t	lib/monty/monty.h	/^        auto asInt () const -> int64_t;$/;"	m	struct:monty::Value
interrupt	lib/boss/boss.h	/^        virtual void interrupt () { pending |= 1<<_id; }$/;"	f	struct:boss::boss::Device
invert	lib/monty/monty.h	/^        auto invert () const { return asBool(!truthy()); }$/;"	f	struct:monty::Value
io	src/mrfs.py	/^import io, os, sys, time$/;"	i
io16	lib/mcu/mcu.h	/^    auto& io16 (int off =0) {$/;"	f	namespace:mcu
io32	lib/mcu/mcu.h	/^    auto io32 (int off =0) {$/;"	f	namespace:mcu
io8	lib/mcu/mcu.h	/^    auto& io8 (int off =0) {$/;"	f	namespace:mcu
ipDir	src/altpins.py	/^ipDir = sys.argv[1]$/;"	v
ipOff	lib/pyvm/pyvm.cpp	/^        Value base, spOff, ipOff, callee, ep, locals, result, stack [];$/;"	m	struct:PyVM::Frame	file:
irq	lib/arch-stm32/prelude.h	/^    IrqVec irq;$/;"	m	struct:IrqVec::DevInfo
irq	lib/hall-stm32/hall.h	/^    namespace irq {$/;"	n	namespace:hall
irq	lib/hall-stm32/stm32l4-uart.cpp	/^    uint8_t num :4, ena, irq;$/;"	m	struct:UartInfo	file:
irq	lib/mcu/prelude.h	/^    IrqVec irq;$/;"	m	struct:IrqVec::DevInfo
irqDispatch	lib/arch-stm32/arch.h	/^        static void irqDispatch () {$/;"	f	struct:arch::Device
irqHandler	lib/arch-stm32/uart-f1.h	/^    void irqHandler () {$/;"	f	struct:Uart
irqHandler	lib/arch-stm32/uart-l0.h	/^    void irqHandler () {$/;"	f	struct:Uart
irqHandler	lib/arch-stm32/uart-l4.h	/^    void irqHandler () {$/;"	f	struct:Uart
irqHandler	lib/hall-stm32/hall.cpp	/^extern "C" void irqHandler () {$/;"	f
irqHandler	lib/mcu/uart-stm32f4f7.h	/^    void irqHandler () {$/;"	f	struct:Uart
irqHandler	lib/mcu/uart-stm32l4.h	/^    void irqHandler () {$/;"	f	struct:Uart
irqInstall	lib/hall-stm32/hall.cpp	/^void Device::irqInstall (uint32_t irq) const {$/;"	f	class:Device
irqLimit	src/device.py	/^irqLimit = 0$/;"	v
irqMap	lib/arch-stm32/arch.h	/^        static uint8_t irqMap [16 + (uint8_t) IrqVec::limit];$/;"	m	struct:arch::Device
irqMap	lib/hall-stm32/hall.cpp	/^uint8_t irqMap [irq::limit];$/;"	v
irqMap	lib/mcu/mcu.cpp	/^    uint8_t Device::irqMap [(int) device::IrqVec::limit];$/;"	m	class:mcu::Device	file:
irqMap	lib/mcu/mcu.h	/^        static uint8_t irqMap [];$/;"	m	struct:mcu::Device
irqs	src/device.py	/^irqs = {}$/;"	v
irqvecs	src/device.py	/^irqvecs = []$/;"	v
isBool	lib/monty/monty.h	/^               auto isBool  () const { return isFalse() || isTrue(); }$/;"	f	struct:monty::Value
isCollectable	lib/monty/monty.h	/^        auto isCollectable () const { return inPool(this); }$/;"	f	struct:monty::Obj
isInt	lib/monty/monty.h	/^        auto isInt () const { return (_v&1) == Int; }$/;"	f	struct:monty::Value
isNil	lib/monty/monty.h	/^        auto isNil () const { return _v == 0; }$/;"	f	struct:monty::Value
isObj	lib/monty/monty.h	/^        auto isObj () const { return (_v&3) == 0 && _v != 0; }$/;"	f	struct:monty::Value
isOk	lib/monty/monty.h	/^        auto isOk  () const { return _v != 0; }$/;"	f	struct:monty::Value
isOnStack	lib/doctest/doctest.h	/^    bool isOnStack() const { return (buf[last] & 128) == 0; }$/;"	f	class:doctest::String
isOnStack	tests/embed/src/doctestx.h	/^    bool isOnStack() const { return (buf[last] & 128) == 0; }$/;"	f	class:doctest::String
isQid	lib/monty/monty.h	/^        auto isQid () const { return isStr() && (_v >> 18) == 0; }$/;"	f	struct:monty::Value
isStr	lib/monty/monty.h	/^        auto isStr () const { return (_v&3) == Str; }$/;"	f	struct:monty::Value
isValid	lib/mcu/mcu.h	/^        auto isValid () const { return _port < 15; }$/;"	f	struct:mcu::Pin
is_check	lib/doctest/doctest.h	/^        is_check   = 2 * is_warn,$/;"	e	enum:doctest::assertType::Enum
is_check	tests/embed/src/doctestx.h	/^        is_check   = 2 * is_warn,$/;"	e	enum:doctest::assertType::Enum
is_enum	lib/doctest/doctest.h	/^    template<class T> struct is_enum : public std::is_enum<T> {};$/;"	s	namespace:doctest::detail
is_enum	lib/doctest/doctest.h	/^    template<class T> struct is_enum { constexpr static bool value = __is_enum(T); };$/;"	s	namespace:doctest::detail
is_enum	tests/embed/src/doctestx.h	/^    template<class T> struct is_enum : public std::is_enum<T> {};$/;"	s	namespace:doctest::detail
is_enum	tests/embed/src/doctestx.h	/^    template<class T> struct is_enum { constexpr static bool value = __is_enum(T); };$/;"	s	namespace:doctest::detail
is_eq	lib/doctest/doctest.h	/^        is_eq = 2 * is_unary,$/;"	e	enum:doctest::assertType::Enum
is_eq	tests/embed/src/doctestx.h	/^        is_eq = 2 * is_unary,$/;"	e	enum:doctest::assertType::Enum
is_false	lib/doctest/doctest.h	/^        is_false = 2 * is_nothrow,$/;"	e	enum:doctest::assertType::Enum
is_false	tests/embed/src/doctestx.h	/^        is_false = 2 * is_nothrow,$/;"	e	enum:doctest::assertType::Enum
is_ge	lib/doctest/doctest.h	/^        is_ge = 2 * is_gt,$/;"	e	enum:doctest::assertType::Enum
is_ge	tests/embed/src/doctestx.h	/^        is_ge = 2 * is_gt,$/;"	e	enum:doctest::assertType::Enum
is_gt	lib/doctest/doctest.h	/^        is_gt = 2 * is_lt,$/;"	e	enum:doctest::assertType::Enum
is_gt	tests/embed/src/doctestx.h	/^        is_gt = 2 * is_lt,$/;"	e	enum:doctest::assertType::Enum
is_le	lib/doctest/doctest.h	/^        is_le = 2 * is_ge,$/;"	e	enum:doctest::assertType::Enum
is_le	tests/embed/src/doctestx.h	/^        is_le = 2 * is_ge,$/;"	e	enum:doctest::assertType::Enum
is_lt	lib/doctest/doctest.h	/^        is_lt = 2 * is_ne,$/;"	e	enum:doctest::assertType::Enum
is_lt	tests/embed/src/doctestx.h	/^        is_lt = 2 * is_ne,$/;"	e	enum:doctest::assertType::Enum
is_lvalue_reference	lib/doctest/doctest.h	/^    template<class T> struct is_lvalue_reference { const static bool value=false; };$/;"	s	namespace:doctest::detail
is_lvalue_reference	lib/doctest/doctest.h	/^    template<class T> struct is_lvalue_reference<T&> { const static bool value=true; };$/;"	s	namespace:doctest::detail
is_lvalue_reference	tests/embed/src/doctestx.h	/^    template<class T> struct is_lvalue_reference { const static bool value=false; };$/;"	s	namespace:doctest::detail
is_lvalue_reference	tests/embed/src/doctestx.h	/^    template<class T> struct is_lvalue_reference<T&> { const static bool value=true; };$/;"	s	namespace:doctest::detail
is_ne	lib/doctest/doctest.h	/^        is_ne = 2 * is_eq,$/;"	e	enum:doctest::assertType::Enum
is_ne	tests/embed/src/doctestx.h	/^        is_ne = 2 * is_eq,$/;"	e	enum:doctest::assertType::Enum
is_normal	lib/doctest/doctest.h	/^        is_normal      = 2 * is_require,$/;"	e	enum:doctest::assertType::Enum
is_normal	tests/embed/src/doctestx.h	/^        is_normal      = 2 * is_require,$/;"	e	enum:doctest::assertType::Enum
is_nothrow	lib/doctest/doctest.h	/^        is_nothrow     = 2 * is_throws_with,$/;"	e	enum:doctest::assertType::Enum
is_nothrow	tests/embed/src/doctestx.h	/^        is_nothrow     = 2 * is_throws_with,$/;"	e	enum:doctest::assertType::Enum
is_require	lib/doctest/doctest.h	/^        is_require = 2 * is_check,$/;"	e	enum:doctest::assertType::Enum
is_require	tests/embed/src/doctestx.h	/^        is_require = 2 * is_check,$/;"	e	enum:doctest::assertType::Enum
is_throws	lib/doctest/doctest.h	/^        is_throws      = 2 * is_normal,$/;"	e	enum:doctest::assertType::Enum
is_throws	tests/embed/src/doctestx.h	/^        is_throws      = 2 * is_normal,$/;"	e	enum:doctest::assertType::Enum
is_throws_as	lib/doctest/doctest.h	/^        is_throws_as   = 2 * is_throws,$/;"	e	enum:doctest::assertType::Enum
is_throws_as	tests/embed/src/doctestx.h	/^        is_throws_as   = 2 * is_throws,$/;"	e	enum:doctest::assertType::Enum
is_throws_with	lib/doctest/doctest.h	/^        is_throws_with = 2 * is_throws_as,$/;"	e	enum:doctest::assertType::Enum
is_throws_with	tests/embed/src/doctestx.h	/^        is_throws_with = 2 * is_throws_as,$/;"	e	enum:doctest::assertType::Enum
is_unary	lib/doctest/doctest.h	/^        is_unary = 2 * is_false, \/\/ not checked anywhere - used just to distinguish the types$/;"	e	enum:doctest::assertType::Enum
is_unary	tests/embed/src/doctestx.h	/^        is_unary = 2 * is_false, \/\/ not checked anywhere - used just to distinguish the types$/;"	e	enum:doctest::assertType::Enum
is_warn	lib/doctest/doctest.h	/^        is_warn    = 1,$/;"	e	enum:doctest::assertType::Enum
is_warn	tests/embed/src/doctestx.h	/^        is_warn    = 1,$/;"	e	enum:doctest::assertType::Enum
isgenerator	src/xmltodict.py	/^from inspect import isgenerator$/;"	i
item_depth	src/xmltodict.py	/^    item_depth = int(item_depth)$/;"	v
j	tests/py/features.py	/^j = 0$/;"	v
j	tests/py/unop.py	/^j = 0$/;"	v
jeeh	lib/arch-stm32/jee-rf69.h	/^namespace jeeh {$/;"	n
jeeh	lib/arch-stm32/jee-stm32.h	/^namespace jeeh {$/;"	n
k	lib/monty/monty.h	/^        struct Item { Q k; Value v; };$/;"	m	struct:monty::Lookup::Item
k	lib/monty/monty.h	/^        struct Proxy { Dict& d; Value k;$/;"	m	struct:monty::Dict::Proxy
k	tests/py/features.py	/^k = 29$/;"	v
k	tests/py/kwargs.py	/^def k(a,b,*,c=33,d=44):$/;"	f
k	tests/py/unop.py	/^k = -234$/;"	v
kputs	lib/arch-stm32/arch.cpp	/^void kputs (char const* msg) {$/;"	f
kwKey	lib/monty/monty.h	/^        auto kwKey (int i) const { return begin()[size()+2*i]; }$/;"	f	struct:monty::ArgVec
kwNum	lib/monty/monty.h	/^        auto kwNum () const { return (uint8_t) (_num >> 8); }$/;"	f	struct:monty::ArgVec
kwVal	lib/monty/monty.h	/^        auto kwVal (int i) const { return begin()[size()+2*i+1]; }$/;"	f	struct:monty::ArgVec
l	tests/py/argexp.py	/^def l(a,b):$/;"	f
l	tests/py/kwargs.py	/^def l(a,b,**kw):$/;"	f
l	tests/py/mem.py	/^        l = [i,1,2,3,4,5]$/;"	v
l	tests/py/slice.py	/^l = [1,2,3,4,5,6]$/;"	v
l	tests/py/slice.py	/^l = [1,2,3,4,5]$/;"	v
l	tests/py/unop.py	/^l = 10000000000$/;"	v
lar	lib/arch-stm32/jee-stm32.h	/^        enum { ctrl=0x0, cyccnt=0x4, lar=0xFB0 };$/;"	e	enum:jeeh::DWT::__anon24
last	lib/arch-native/mod-machine.cpp	/^uint32_t start, last;$/;"	v
last	lib/arch-stm32/arch.cpp	/^    uint32_t offset = 0, last = 0;$/;"	v
last	lib/arch-stm32/mod-machine.cpp	/^static uint32_t start, last;$/;"	v	file:
last	lib/doctest/doctest.h	/^    static const unsigned last = len - 1; \/\/!OCLINT avoid private static members$/;"	m	class:doctest::String
last	lib/doctest/doctest.h	/^    unsigned last;  \/\/ the last (matching) test to be executed$/;"	m	struct:doctest::ContextOptions
last	lib/mrfs/mrfs.cpp	/^    Info* last;$/;"	m	namespace:mrfs	file:
last	tests/embed/src/doctestx.h	/^    static const unsigned last = len - 1; \/\/!OCLINT avoid private static members$/;"	m	class:doctest::String
last	tests/embed/src/doctestx.h	/^    unsigned last;  \/\/ the last (matching) test to be executed$/;"	m	struct:doctest::ContextOptions
leave	lib/pyvm/pyvm.cpp	/^    void leave () {$/;"	f	struct:PyVM
leds	tests/smoke/src/main9.cpp	/^Pin leds [7];$/;"	v
len	lib/doctest/doctest.h	/^    static const unsigned len  = 24;      \/\/!OCLINT avoid private static members$/;"	m	class:doctest::String
len	lib/mcu/mcu.h	/^    struct Chunk { uint8_t* buf; uint32_t len; };$/;"	m	struct:mcu::Chunk
len	tests/embed/src/doctestx.h	/^    static const unsigned len  = 24;      \/\/!OCLINT avoid private static members$/;"	m	class:doctest::String
lim	lib/graphics/mod-graphics.cpp	/^    static void lim (Rect const& r) {}$/;"	f	struct:Tft
limit	lib/arch-stm32/prelude.h	/^    limit = 85$/;"	m	struct:IrqVec
limit	lib/hall-stm32/hall.h	/^        constexpr auto limit = 85;$/;"	m	namespace:hall::irq
limit	lib/mcu/prelude.h	/^    limit = 85$/;"	m	struct:IrqVec
limit	lib/mcu/printer.h	/^    int8_t pad, width, radix, fill, limit;$/;"	m	struct:Printer
limit	lib/monty/gc.cpp	/^static uintptr_t* limit;    \/\/ limit of memory pool, aligned to OS_SZ-PTR_SZ$/;"	v	file:
limit	lib/monty/monty.h	/^        auto limit () const { return begin() + pos(_fill); }$/;"	f	struct:monty::VaryVec
line	lib/graphics/twodee.h	/^        static void line (Point p1, Point p2) {$/;"	f	struct:twodee::TwoDee
line	src/mrfs.py	/^        line = ser.readline()$/;"	v
line	src/runner.py	/^                line = "binary: " + line[:-1].hex() + "\\n" # not utf8$/;"	v
line	src/runner.py	/^                line = line.decode()$/;"	v
line	src/runner.py	/^                line = ser.readline()$/;"	v
listInsDel	tests/unit/array/main.cpp	/^static void listInsDel () {$/;"	f	file:
list_ports	src/runner.py	/^    import serial.tools.list_ports$/;"	i
list_reporters	lib/doctest/doctest.h	/^    bool list_reporters;   \/\/ lists all registered reporters$/;"	m	struct:doctest::ContextOptions
list_reporters	tests/embed/src/doctestx.h	/^    bool list_reporters;   \/\/ lists all registered reporters$/;"	m	struct:doctest::ContextOptions
list_test_cases	lib/doctest/doctest.h	/^    bool list_test_cases;  \/\/ to list all tests matching the filters$/;"	m	struct:doctest::ContextOptions
list_test_cases	tests/embed/src/doctestx.h	/^    bool list_test_cases;  \/\/ to list all tests matching the filters$/;"	m	struct:doctest::ContextOptions
list_test_suites	lib/doctest/doctest.h	/^    bool list_test_suites; \/\/ to list all suites matching the filters$/;"	m	struct:doctest::ContextOptions
list_test_suites	tests/embed/src/doctestx.h	/^    bool list_test_suites; \/\/ to list all suites matching the filters$/;"	m	struct:doctest::ContextOptions
lna	lib/arch-stm32/jee-rf69.h	/^        uint8_t lna;$/;"	m	struct:jeeh::RF69
load	lib/pyvm/loader.h	/^    Callable* load (uint8_t const* data, Value nm) {$/;"	f	struct:Loader
loadOps	lib/pyvm/loader.h	/^    void loadOps () {$/;"	f	struct:Loader
loadQstr	lib/pyvm/loader.h	/^    int loadQstr () {$/;"	f	struct:Loader
loadRaw	lib/pyvm/loader.h	/^    Bytecode const& loadRaw () {$/;"	f	struct:Loader
loaded	lib/monty/monty.h	/^        static Dict loaded;$/;"	m	struct:monty::Module
locals	lib/pyvm/pyvm.cpp	/^        Value base, spOff, ipOff, callee, ep, locals, result, stack [];$/;"	m	struct:PyVM::Frame	file:
loop	tests/py/s_rf69.py	/^async def loop():$/;"	f
loop	tests/py/timer.py	/^async def loop():$/;"	f
loopCheck	lib/pyvm/pyvm.cpp	/^    static void loopCheck (int arg) {$/;"	f	struct:PyVM
low	tests/native/memTest.cpp	/^        struct Slot *low, *high;$/;"	m	namespace:mem::vec	typeref:struct:mem::vec::Slot	file:
m	tests/py/argexp.py	/^def m(**k):$/;"	f
m	tests/py/closure.py	/^m = 987$/;"	v
m	tests/py/dir.py	/^    def m(): pass$/;"	m	class:A
m	tests/py/gen.py	/^m = gen()$/;"	v
m	tests/py/kwargs.py	/^def m(a,b,*c,d,**kw):$/;"	f
m0b	lib/graphics/twodee.h	/^        uint8_t nGl, bbM, m0b, m1b, bcW, bcH, bcX, bcY, bcD,$/;"	m	struct:twodee::Font
m1b	lib/graphics/twodee.h	/^        uint8_t nGl, bbM, m0b, m1b, bcW, bcH, bcX, bcY, bcD,$/;"	m	struct:twodee::Font
m_at	lib/doctest/doctest.h	/^    assertType::Enum    m_at;$/;"	m	struct:doctest::AssertData
m_at	tests/embed/src/doctestx.h	/^    assertType::Enum    m_at;$/;"	m	struct:doctest::AssertData
m_decomp	lib/doctest/doctest.h	/^    String m_decomp;$/;"	m	struct:doctest::AssertData
m_decomp	tests/embed/src/doctestx.h	/^    String m_decomp;$/;"	m	struct:doctest::AssertData
m_description	lib/doctest/doctest.h	/^    const char* m_description;$/;"	m	struct:doctest::TestCaseData
m_description	tests/embed/src/doctestx.h	/^    const char* m_description;$/;"	m	struct:doctest::TestCaseData
m_exception	lib/doctest/doctest.h	/^    String m_exception;$/;"	m	struct:doctest::AssertData
m_exception	tests/embed/src/doctestx.h	/^    String m_exception;$/;"	m	struct:doctest::AssertData
m_exception_string	lib/doctest/doctest.h	/^    const char* m_exception_string;$/;"	m	struct:doctest::AssertData
m_exception_string	tests/embed/src/doctestx.h	/^    const char* m_exception_string;$/;"	m	struct:doctest::AssertData
m_exception_type	lib/doctest/doctest.h	/^    const char* m_exception_type;$/;"	m	struct:doctest::AssertData
m_exception_type	tests/embed/src/doctestx.h	/^    const char* m_exception_type;$/;"	m	struct:doctest::AssertData
m_expected_failures	lib/doctest/doctest.h	/^    int         m_expected_failures;$/;"	m	struct:doctest::TestCaseData
m_expected_failures	tests/embed/src/doctestx.h	/^    int         m_expected_failures;$/;"	m	struct:doctest::TestCaseData
m_expr	lib/doctest/doctest.h	/^    const char*         m_expr;$/;"	m	struct:doctest::AssertData
m_expr	tests/embed/src/doctestx.h	/^    const char*         m_expr;$/;"	m	struct:doctest::AssertData
m_failed	lib/doctest/doctest.h	/^    bool                m_failed;$/;"	m	struct:doctest::AssertData
m_failed	tests/embed/src/doctestx.h	/^    bool                m_failed;$/;"	m	struct:doctest::AssertData
m_file	lib/doctest/doctest.h	/^    String      m_file;       \/\/ the file in which the test was registered (using String - see #350)$/;"	m	struct:doctest::TestCaseData
m_file	lib/doctest/doctest.h	/^    const char*         m_file;$/;"	m	struct:doctest::AssertData
m_file	lib/doctest/doctest.h	/^    const char*      m_file;$/;"	m	struct:doctest::MessageData
m_file	lib/doctest/doctest.h	/^    const char* m_file;$/;"	m	struct:doctest::SubcaseSignature
m_file	tests/embed/src/doctestx.h	/^    String      m_file;       \/\/ the file in which the test was registered (using String - see #350)$/;"	m	struct:doctest::TestCaseData
m_file	tests/embed/src/doctestx.h	/^    const char*         m_file;$/;"	m	struct:doctest::AssertData
m_file	tests/embed/src/doctestx.h	/^    const char*      m_file;$/;"	m	struct:doctest::MessageData
m_file	tests/embed/src/doctestx.h	/^    const char* m_file;$/;"	m	struct:doctest::SubcaseSignature
m_line	lib/doctest/doctest.h	/^    int                 m_line;$/;"	m	struct:doctest::AssertData
m_line	lib/doctest/doctest.h	/^    int              m_line;$/;"	m	struct:doctest::MessageData
m_line	lib/doctest/doctest.h	/^    int         m_line;$/;"	m	struct:doctest::SubcaseSignature
m_line	lib/doctest/doctest.h	/^    unsigned    m_line;       \/\/ the line where the test was registered$/;"	m	struct:doctest::TestCaseData
m_line	tests/embed/src/doctestx.h	/^    int                 m_line;$/;"	m	struct:doctest::AssertData
m_line	tests/embed/src/doctestx.h	/^    int              m_line;$/;"	m	struct:doctest::MessageData
m_line	tests/embed/src/doctestx.h	/^    int         m_line;$/;"	m	struct:doctest::SubcaseSignature
m_line	tests/embed/src/doctestx.h	/^    unsigned    m_line;       \/\/ the line where the test was registered$/;"	m	struct:doctest::TestCaseData
m_may_fail	lib/doctest/doctest.h	/^    bool        m_may_fail;$/;"	m	struct:doctest::TestCaseData
m_may_fail	tests/embed/src/doctestx.h	/^    bool        m_may_fail;$/;"	m	struct:doctest::TestCaseData
m_name	lib/doctest/doctest.h	/^    String      m_name;$/;"	m	struct:doctest::SubcaseSignature
m_name	lib/doctest/doctest.h	/^    const char* m_name;       \/\/ name of the test case$/;"	m	struct:doctest::TestCaseData
m_name	tests/embed/src/doctestx.h	/^    String      m_name;$/;"	m	struct:doctest::SubcaseSignature
m_name	tests/embed/src/doctestx.h	/^    const char* m_name;       \/\/ name of the test case$/;"	m	struct:doctest::TestCaseData
m_no_breaks	lib/doctest/doctest.h	/^    bool        m_no_breaks;$/;"	m	struct:doctest::TestCaseData
m_no_breaks	tests/embed/src/doctestx.h	/^    bool        m_no_breaks;$/;"	m	struct:doctest::TestCaseData
m_no_output	lib/doctest/doctest.h	/^    bool        m_no_output;$/;"	m	struct:doctest::TestCaseData
m_no_output	tests/embed/src/doctestx.h	/^    bool        m_no_output;$/;"	m	struct:doctest::TestCaseData
m_severity	lib/doctest/doctest.h	/^    assertType::Enum m_severity;$/;"	m	struct:doctest::MessageData
m_severity	tests/embed/src/doctestx.h	/^    assertType::Enum m_severity;$/;"	m	struct:doctest::MessageData
m_should_fail	lib/doctest/doctest.h	/^    bool        m_should_fail;$/;"	m	struct:doctest::TestCaseData
m_should_fail	tests/embed/src/doctestx.h	/^    bool        m_should_fail;$/;"	m	struct:doctest::TestCaseData
m_skip	lib/doctest/doctest.h	/^    bool        m_skip;$/;"	m	struct:doctest::TestCaseData
m_skip	tests/embed/src/doctestx.h	/^    bool        m_skip;$/;"	m	struct:doctest::TestCaseData
m_string	lib/doctest/doctest.h	/^    String           m_string;$/;"	m	struct:doctest::MessageData
m_string	tests/embed/src/doctestx.h	/^    String           m_string;$/;"	m	struct:doctest::MessageData
m_test_case	lib/doctest/doctest.h	/^    const TestCaseData* m_test_case;$/;"	m	struct:doctest::AssertData
m_test_case	tests/embed/src/doctestx.h	/^    const TestCaseData* m_test_case;$/;"	m	struct:doctest::AssertData
m_test_suite	lib/doctest/doctest.h	/^    const char* m_test_suite; \/\/ the test suite in which the test was added$/;"	m	struct:doctest::TestCaseData
m_test_suite	tests/embed/src/doctestx.h	/^    const char* m_test_suite; \/\/ the test suite in which the test was added$/;"	m	struct:doctest::TestCaseData
m_threw	lib/doctest/doctest.h	/^    bool   m_threw;$/;"	m	struct:doctest::AssertData
m_threw	tests/embed/src/doctestx.h	/^    bool   m_threw;$/;"	m	struct:doctest::AssertData
m_threw_as	lib/doctest/doctest.h	/^    bool        m_threw_as;$/;"	m	struct:doctest::AssertData
m_threw_as	tests/embed/src/doctestx.h	/^    bool        m_threw_as;$/;"	m	struct:doctest::AssertData
m_timeout	lib/doctest/doctest.h	/^    double      m_timeout;$/;"	m	struct:doctest::TestCaseData
m_timeout	tests/embed/src/doctestx.h	/^    double      m_timeout;$/;"	m	struct:doctest::TestCaseData
machine	tests/py/event.py	/^import machine$/;"	i
machine	tests/py/features.py	/^import sys, machine$/;"	i
machine	tests/py/gcoll.py	/^import sys, machine$/;"	i
machine	tests/py/other/x_await.py	/^import sys, machine$/;"	i
machine	tests/py/parse.py	/^import machine$/;"	i
machine	tests/py/s_blinker.py	/^import sys, machine$/;"	i
machine	tests/py/s_rf69.py	/^import sys, machine$/;"	i
machine	tests/py/s_spi.py	/^import machine$/;"	i
machine	tests/py/serout.py	/^import sys, machine$/;"	i
machine	tests/py/tasks.py	/^import sys, machine$/;"	i
machine	tests/py/timer.py	/^import sys, machine$/;"	i
machine_map	lib/arch-native/mod-machine.cpp	/^static Lookup::Item const machine_map [] = {$/;"	m	class:Lookup	file:
machine_map	lib/arch-stm32/mod-machine.cpp	/^static Lookup::Item const machine_map [] = {$/;"	m	class:Lookup	file:
magic	lib/mrfs/mrfs.h	/^        uint32_t magic;$/;"	m	struct:mrfs::Info
main	lib/mrfs/mrfs.cpp	/^int main (int argc, char const* argv[]) {$/;"	f
main	src/tdd.py	/^def main():$/;"	f
main	tests/buffers/main.cpp	/^int main (int argc, char const** argv) {$/;"	f
main	tests/native/main.cpp	/^int main(int argc, char** argv) {$/;"	f
main	tests/py/other/x_await.py	/^async def main():$/;"	f
main	tests/smoke/src/main0.cpp	/^int main () {$/;"	f
main	tests/smoke/src/main1.cpp	/^int main () {$/;"	f
main	tests/smoke/src/main2.cpp	/^int main () {$/;"	f
main	tests/smoke/src/main3.cpp	/^int main () {$/;"	f
main	tests/smoke/src/main4.cpp	/^int main () {$/;"	f
main	tests/smoke/src/main5.cpp	/^int main () {$/;"	f
main	tests/smoke/src/main6.cpp	/^int main () {$/;"	f
main	tests/smoke/src/main7.cpp	/^int main () {$/;"	f
main	tests/smoke/src/main8.cpp	/^int main () {$/;"	f
main	tests/smoke/src/main9.cpp	/^int main () {$/;"	f
main	tests/tdd/main.cpp	/^int main () {$/;"	f
main	tests/unit/array/main.cpp	/^int main () {$/;"	f
main	tests/unit/data/main.cpp	/^int main () {$/;"	f
main	tests/unit/mem/main.cpp	/^int main () {$/;"	f
main	tests/unit/repr/main.cpp	/^int main () {$/;"	f
mark	lib/monty/gc.cpp	/^    void mark (Obj const& obj) {$/;"	f	namespace:monty
mark	lib/monty/monty.h	/^    inline void mark (Obj const* p) { if (p != nullptr) mark(*p); }$/;"	f	namespace:monty
markObj	tests/unit/mem/main.cpp	/^void markObj () {$/;"	f
markThrough	tests/unit/mem/main.cpp	/^void markThrough () {$/;"	f
markVec	lib/monty/type.cpp	/^void monty::markVec (Vector const& vec) {$/;"	f	class:monty
marked	lib/monty/gc.cpp	/^int created, destroyed, marked, failed;$/;"	v
marked	tests/unit/mem/main.cpp	/^int created, destroyed, marked, failed;$/;"	v
marker	lib/monty/builtin.cpp	/^void Exception::marker () const {$/;"	f	class:Exception
marker	lib/monty/monty.h	/^        virtual void marker () const {} \/\/ called to mark all ref'd objects$/;"	f	struct:monty::Obj
marker	lib/monty/monty.h	/^    void Value::marker () const { if (isObj()) mark(obj()); }$/;"	f	class:monty::Value
marker	lib/monty/stack.cpp	/^void Context::marker () const {$/;"	f	class:Context
marker	lib/monty/type.cpp	/^void Dict::marker () const {$/;"	f	class:Dict
marker	lib/pyvm/pyvm.cpp	/^void Callable::marker () const {$/;"	f	class:Callable
marshal	src/xmltodict.py	/^    import marshal$/;"	i
mask	lib/extend/typ-array.cpp	/^    constexpr static auto mask = (1 << bits) - 1;   \/\/ 1 3 15$/;"	m	struct:AccessAsBits	file:
mask	lib/mcu/mcu.h	/^        auto mask (int b, uint8_t w) {$/;"	f	struct:mcu::IOWord
maybeInRoot	src/codegen.py	/^def maybeInRoot(f):$/;"	f
mcu	lib/mcu/mcu.cpp	/^namespace mcu {$/;"	n	file:
mcu	lib/mcu/mcu.h	/^namespace mcu {$/;"	n
mem	tests/native/memTest.cpp	/^namespace mem {$/;"	n	file:
memAvail	tests/unit/array/main.cpp	/^uint32_t memAvail;$/;"	v
memAvail	tests/unit/data/main.cpp	/^uint32_t memAvail;$/;"	v
memAvail	tests/unit/mem/main.cpp	/^uint32_t memAvail;$/;"	v
memAvail	tests/unit/repr/main.cpp	/^uint32_t memAvail;$/;"	v
mergeFreeObjs	lib/monty/gc.cpp	/^static void mergeFreeObjs (ObjSlot& slot) {$/;"	f	file:
mergeMulti	tests/unit/mem/main.cpp	/^void mergeMulti () {$/;"	f
mergeNext	tests/unit/mem/main.cpp	/^void mergeNext () {$/;"	f
mergePrevious	tests/unit/mem/main.cpp	/^void mergePrevious () {$/;"	f
meths	src/codegen.py	/^meths = {"": []}    # list of bound methods per type\/module$/;"	v
min	lib/graphics/twodee.h	/^    auto min (int a, int b)      { return a < b ? a : b; }$/;"	f	namespace:twodee
mm	lib/hall-stm32/hall.h	/^        struct DateTime { uint8_t yr, mo, dy, hh, mm, ss; };$/;"	m	struct:hall::rtc::DateTime
mm	lib/mcu/mcu.h	/^        struct DateTime { uint8_t yr, mo, dy, hh, mm, ss; };$/;"	m	struct:mcu::rtc::DateTime
mo	lib/hall-stm32/hall.h	/^        struct DateTime { uint8_t yr, mo, dy, hh, mm, ss; };$/;"	m	struct:hall::rtc::DateTime
mo	lib/mcu/mcu.h	/^        struct DateTime { uint8_t yr, mo, dy, hh, mm, ss; };$/;"	m	struct:mcu::rtc::DateTime
moa	lib/monty/monty.h	/^                moa, mob, mva, mvb; \/\/ max   Obj\/Vec Allocs\/Bytes$/;"	m	struct:monty::GCStats::__anon8
moa	tests/native/memTest.cpp	/^            moa, mob, mva, mvb; \/\/ max   Obj\/Vec Allocs\/Bytes$/;"	m	struct:GCStats::__anon35	file:
mob	lib/monty/monty.h	/^                moa, mob, mva, mvb; \/\/ max   Obj\/Vec Allocs\/Bytes$/;"	m	struct:monty::GCStats::__anon8
mob	tests/native/memTest.cpp	/^            moa, mob, mva, mvb; \/\/ max   Obj\/Vec Allocs\/Bytes$/;"	m	struct:GCStats::__anon35	file:
mod_attrs	lib/monty/qstr.cpp	/^Dict Module::loaded (&mod_attrs);$/;"	m	class:Module	file:
mod_map	lib/monty/qstr.cpp	/^static Lookup::Item const mod_map [] = {$/;"	m	class:Lookup	file:
mode	lib/arch-stm32/jee-rf69.h	/^        uint8_t mode;$/;"	m	struct:jeeh::RF69
mode	lib/arch-stm32/jee-stm32.h	/^        void mode (int mval, int \/*ignored*\/ =0) const {$/;"	f	struct:jeeh::Pin
mode	lib/arch-stm32/jee-stm32.h	/^        void mode (int mval, int alt =0) const {$/;"	f	struct:jeeh::Pin
mode	lib/graphics/mod-graphics.cpp	/^    constexpr static char mode = 'H'; \/\/ this driver uses horizontal mode$/;"	m	struct:Tft	file:
moder	lib/arch-stm32/jee-stm32.h	/^        enum { moder=0x00, typer=0x04, ospeedr=0x08, pupdr=0x0C, idr=0x10,$/;"	e	enum:jeeh::Pin::__anon23
mods	src/codegen.py	/^mods  = {"": []}    # list of extension module names per architecture$/;"	v
monty	lib/extend/typ-array.h	/^namespace monty {$/;"	n
monty	lib/monty/gc.cpp	/^namespace monty {$/;"	n	file:
monty	lib/monty/monty.h	/^namespace monty {$/;"	n
monty	lib/monty/qstr.h	/^namespace monty {$/;"	n
move	lib/monty/monty.h	/^        void move (uint32_t pos, uint32_t num, int off) {$/;"	f	struct:monty::VecOf
mpy	src/watcher.py	/^                mpy = compileIfOutdated(fn)$/;"	v
mrfs	lib/mrfs/mrfs.cpp	/^namespace mrfs {$/;"	n	file:
mrfs	lib/mrfs/mrfs.h	/^namespace mrfs {$/;"	n
mrfs	lib/mrfs/test.py	/^def mrfs(*args):$/;"	f
mrfsBase	lib/arch-stm32/arch.cpp	/^const auto mrfsBase = (mrfs::Info*) 0x08010000;$/;"	v
mrfsSize	lib/arch-stm32/arch.cpp	/^const auto mrfsSize = 32*1024;$/;"	v
ms	lib/arch-native/mod-machine.cpp	/^int ms, tickerId;$/;"	v
ms	lib/arch-stm32/mod-machine.cpp	/^static int ms, tickerId;$/;"	v	file:
msWait	lib/boss/boss.h	/^        static void msWait (uint16_t ms) { suspend(timers, ms); }$/;"	f	struct:boss::boss::Fiber
msg	src/codegen.py	/^        msg = "stripped" if strip else "rewritten"$/;"	v
mva	lib/monty/monty.h	/^                moa, mob, mva, mvb; \/\/ max   Obj\/Vec Allocs\/Bytes$/;"	m	struct:monty::GCStats::__anon8
mva	tests/native/memTest.cpp	/^            moa, mob, mva, mvb; \/\/ max   Obj\/Vec Allocs\/Bytes$/;"	m	struct:GCStats::__anon35	file:
mvb	lib/monty/monty.h	/^                moa, mob, mva, mvb; \/\/ max   Obj\/Vec Allocs\/Bytes$/;"	m	struct:monty::GCStats::__anon8
mvb	tests/native/memTest.cpp	/^            moa, mob, mva, mvb; \/\/ max   Obj\/Vec Allocs\/Bytes$/;"	m	struct:GCStats::__anon35	file:
myDir	src/device.py	/^myDir = path.dirname(sys.argv[0])$/;"	v
myId	lib/arch-stm32/jee-rf69.h	/^        uint8_t myId;$/;"	m	struct:jeeh::RF69
n	src/device.py	/^        n = int(re.sub('\\D+', '', p))$/;"	v
n	src/mrfs.py	/^    n = ofile.tell()$/;"	v
n	tests/py/lambda.py	/^n = 2$/;"	v
n	tests/py/mem.py	/^n = 0$/;"	v
n1	tests/py/other/uart.py	/^n1 = uart.write(b'1234567890\\n', -1, 0, -1)$/;"	v
n2	tests/py/other/uart.py	/^n2 = uart.write(b'1234567abc\\n', -1, 7, -1)$/;"	v
n3	tests/py/other/uart.py	/^n3 = uart.write(b'123defg\\n456', 8, 3, -1)$/;"	v
nBufs	tests/buffers/main.cpp	/^    uint8_t nBufs;$/;"	m	namespace:buf	file:
nCel	lib/pyvm/loader.h	/^    int8_t nCel;    \/\/ number of closure cells$/;"	m	struct:CodePrefix
nDef	lib/pyvm/loader.h	/^    int8_t nDef;    \/\/ number of default args$/;"	m	struct:CodePrefix
nExc	lib/pyvm/loader.h	/^    int8_t nExc;    \/\/ number of exception levels$/;"	m	struct:CodePrefix
nGl	lib/graphics/twodee.h	/^        uint8_t nGl, bbM, m0b, m1b, bcW, bcH, bcX, bcY, bcD,$/;"	m	struct:twodee::Font
nInf	lib/pyvm/loader.h	/^    int16_t nInf;$/;"	m	struct:CodePrefix
nKwo	lib/pyvm/loader.h	/^    int8_t nKwo;    \/\/ number of keyword-only args$/;"	m	struct:CodePrefix
nPos	lib/pyvm/loader.h	/^    int8_t nPos;    \/\/ number of positional args$/;"	m	struct:CodePrefix
nam	src/mrfs.py	/^            nam = base$/;"	v
nam	src/mrfs.py	/^            nam = dat[end:end+16].split(b'\\0', 1)[0].decode()$/;"	v
nam	src/mrfs.py	/^        nam = fn$/;"	v
name	lib/mrfs/mrfs.h	/^        char name [15], zero;$/;"	m	struct:mrfs::Info
newObj	tests/unit/mem/main.cpp	/^void newObj () {$/;"	f
newVec	tests/unit/mem/main.cpp	/^void newVec () {$/;"	f
next	lib/graphics/twodee.h	/^        auto next () {$/;"	f	struct:twodee::ArcIter
next	lib/graphics/twodee.h	/^        auto next () {$/;"	f	struct:twodee::Glyph
next	lib/graphics/twodee.h	/^        auto next () {$/;"	f	struct:twodee::LineIter
next	lib/monty/gc.cpp	/^        VecSlot* next;$/;"	m	union:VecSlot::__anon11	file:
next	lib/mrfs/mrfs.cpp	/^    Info* next;$/;"	m	namespace:mrfs	file:
next	tests/native/memTest.cpp	/^        Slot* next;$/;"	m	struct:mem::vec::Slot	file:
no_breaks	lib/doctest/doctest.h	/^    bool no_breaks;            \/\/ to not break into the debugger$/;"	m	struct:doctest::ContextOptions
no_breaks	tests/embed/src/doctestx.h	/^    bool no_breaks;            \/\/ to not break into the debugger$/;"	m	struct:doctest::ContextOptions
no_colors	lib/doctest/doctest.h	/^    bool no_colors;            \/\/ if output to the console should be colorized$/;"	m	struct:doctest::ContextOptions
no_colors	tests/embed/src/doctestx.h	/^    bool no_colors;            \/\/ if output to the console should be colorized$/;"	m	struct:doctest::ContextOptions
no_debug_output	lib/doctest/doctest.h	/^    bool no_debug_output;      \/\/ no output in the debug console when a debugger is attached$/;"	m	struct:doctest::ContextOptions
no_debug_output	tests/embed/src/doctestx.h	/^    bool no_debug_output;      \/\/ no output in the debug console when a debugger is attached$/;"	m	struct:doctest::ContextOptions
no_exitcode	lib/doctest/doctest.h	/^    bool no_exitcode;          \/\/ if the framework should return 0 as the exitcode$/;"	m	struct:doctest::ContextOptions
no_exitcode	tests/embed/src/doctestx.h	/^    bool no_exitcode;          \/\/ if the framework should return 0 as the exitcode$/;"	m	struct:doctest::ContextOptions
no_line_numbers	lib/doctest/doctest.h	/^    bool no_line_numbers;      \/\/ if source code line numbers should be omitted from the output$/;"	m	struct:doctest::ContextOptions
no_line_numbers	tests/embed/src/doctestx.h	/^    bool no_line_numbers;      \/\/ if source code line numbers should be omitted from the output$/;"	m	struct:doctest::ContextOptions
no_path_in_filenames	lib/doctest/doctest.h	/^    bool no_path_in_filenames; \/\/ if the path to files should be removed from the output$/;"	m	struct:doctest::ContextOptions
no_path_in_filenames	tests/embed/src/doctestx.h	/^    bool no_path_in_filenames; \/\/ if the path to files should be removed from the output$/;"	m	struct:doctest::ContextOptions
no_run	lib/doctest/doctest.h	/^    bool no_run;               \/\/ to not run the tests at all (can be done with an "*" exclude)$/;"	m	struct:doctest::ContextOptions
no_run	tests/embed/src/doctestx.h	/^    bool no_run;               \/\/ to not run the tests at all (can be done with an "*" exclude)$/;"	m	struct:doctest::ContextOptions
no_skip	lib/doctest/doctest.h	/^    bool no_skip;              \/\/ don't skip test cases which are marked to be skipped$/;"	m	struct:doctest::ContextOptions
no_skip	tests/embed/src/doctestx.h	/^    bool no_skip;              \/\/ don't skip test cases which are marked to be skipped$/;"	m	struct:doctest::ContextOptions
no_skipped_summary	lib/doctest/doctest.h	/^    bool no_skipped_summary;   \/\/ don't print "skipped" in the summary !!! UNDOCUMENTED !!!$/;"	m	struct:doctest::ContextOptions
no_skipped_summary	tests/embed/src/doctestx.h	/^    bool no_skipped_summary;   \/\/ don't print "skipped" in the summary !!! UNDOCUMENTED !!!$/;"	m	struct:doctest::ContextOptions
no_throw	lib/doctest/doctest.h	/^    bool no_throw;             \/\/ to skip exceptions-related assertion macros$/;"	m	struct:doctest::ContextOptions
no_throw	tests/embed/src/doctestx.h	/^    bool no_throw;             \/\/ to skip exceptions-related assertion macros$/;"	m	struct:doctest::ContextOptions
no_time_in_output	lib/doctest/doctest.h	/^    bool no_time_in_output;    \/\/ omit any time\/timestamps from output !!! UNDOCUMENTED !!!$/;"	m	struct:doctest::ContextOptions
no_time_in_output	tests/embed/src/doctestx.h	/^    bool no_time_in_output;    \/\/ omit any time\/timestamps from output !!! UNDOCUMENTED !!!$/;"	m	struct:doctest::ContextOptions
no_version	lib/doctest/doctest.h	/^    bool no_version;           \/\/ to not print the version of the framework$/;"	m	struct:doctest::ContextOptions
no_version	tests/embed/src/doctestx.h	/^    bool no_version;           \/\/ to not print the version of the framework$/;"	m	struct:doctest::ContextOptions
noneObj	lib/monty/data.cpp	/^None const None::noneObj;$/;"	m	class:None	file:
noneObj	lib/monty/monty.h	/^        static None const noneObj;$/;"	m	struct:monty::None
num	lib/arch-stm32/prelude.h	/^    uint8_t pos :4, num :4, ena;$/;"	m	struct:IrqVec::DevInfo
num	lib/hall-stm32/stm32l4-uart.cpp	/^    uint8_t num :4, ena, irq;$/;"	m	struct:UartInfo	file:
num	lib/mcu/prelude.h	/^    uint8_t pos :4, num :4, ena;$/;"	m	struct:IrqVec::DevInfo
numBufs	lib/boss/boss.cpp	/^    uint8_t numBufs;$/;"	m	namespace:boss::pool	file:
numFree	lib/boss/boss.cpp	/^    uint8_t numFree;$/;"	m	namespace:boss::pool	file:
numSlots	tests/native/memTest.cpp	/^    auto numSlots (size_t n) {$/;"	f	namespace:mem::vec
numsort	src/altpins.py	/^def numsort(s):$/;"	f
numsort	src/device.py	/^def numsort(s):$/;"	f
nvicDisable	lib/hall-stm32/hall.h	/^    inline void nvicDisable (uint8_t irq) {$/;"	f	namespace:hall
nvicDisable	lib/mcu/mcu.h	/^        static void nvicDisable (uint8_t irq) {$/;"	f	struct:mcu::Device
nvicEnable	lib/hall-stm32/hall.h	/^    inline void nvicEnable (uint8_t irq) {$/;"	f	namespace:hall
nvicEnable	lib/mcu/mcu.h	/^        static void nvicEnable (uint8_t irq) {$/;"	f	struct:mcu::Device
o	lib/monty/monty.h	/^        static auto argConv (V (T::*m)(), Object& o, ArgVec const&) -> Value {$/;"	m	struct:monty::Method
o	lib/monty/monty.h	/^        static auto argConv (V (T::*m)(U), Object& o, ArgVec const& a) -> Value {$/;"	m	struct:monty::Method
o	lib/monty/monty.h	/^        static auto argConv (Value (T::*m)(ArgVec const&), Object& o, ArgVec const& a) -> Value {$/;"	m	struct:monty::Method
o100	lib/graphics/twodee.h	/^        uint16_t oUp, oLo, o100;$/;"	m	struct:twodee::Font
oLo	lib/graphics/twodee.h	/^        uint16_t oUp, oLo, o100;$/;"	m	struct:twodee::Font
oUp	lib/graphics/twodee.h	/^        uint16_t oUp, oLo, o100;$/;"	m	struct:twodee::Font
objLow	lib/monty/gc.cpp	/^static ObjSlot* objLow;     \/\/ low water mark of object memory pool$/;"	v	file:
odr	lib/arch-stm32/jee-stm32.h	/^                odr=0x14, bsrr=0x18, afrl=0x20, afrh=0x24, brr=0x28 };$/;"	e	enum:jeeh::Pin::__anon23
odr	lib/arch-stm32/jee-stm32.h	/^        enum { crl=0x00, crh=0x04, idr=0x08, odr=0x0C, bsrr=0x10, brr=0x14 };$/;"	e	enum:jeeh::Pin::__anon22
off	lib/graphics/twodee.h	/^        struct Run { uint8_t off, on; };$/;"	m	struct:twodee::Glyph::Run
offset	lib/arch-stm32/arch.cpp	/^    uint32_t offset = 0, last = 0;$/;"	v
ofile	src/mrfs.py	/^        ofile = io.BytesIO()$/;"	v
ofile	src/mrfs.py	/^        ofile = open(next(args), 'wb')$/;"	v
ofile	src/mrfs.py	/^ofile = None$/;"	v
ok	src/runner.py	/^                ok = False$/;"	v
ok	src/runner.py	/^                ok = True$/;"	v
ok	src/runner.py	/^        ok = False$/;"	v
on	lib/graphics/twodee.h	/^        struct Run { uint8_t off, on; };$/;"	m	struct:twodee::Glyph::Run
one	tests/py/closure.py	/^def one(n):$/;"	f
opBinaryOpMulti	lib/pyvm/pyvm.cpp	/^    void opBinaryOpMulti (uint32_t arg) {$/;"	f	struct:PyVM
opBuildList	lib/pyvm/pyvm.cpp	/^    void opBuildList (int arg) {$/;"	f	struct:PyVM
opBuildMap	lib/pyvm/pyvm.cpp	/^    void opBuildMap (int arg) {$/;"	f	struct:PyVM
opBuildSet	lib/pyvm/pyvm.cpp	/^    void opBuildSet (int arg) {$/;"	f	struct:PyVM
opBuildSlice	lib/pyvm/pyvm.cpp	/^    void opBuildSlice (int arg) {$/;"	f	struct:PyVM
opBuildTuple	lib/pyvm/pyvm.cpp	/^    void opBuildTuple (int arg) {$/;"	f	struct:PyVM
opCallFunction	lib/pyvm/pyvm.cpp	/^    void opCallFunction (int arg) {$/;"	f	struct:PyVM
opCallFunctionVarKw	lib/pyvm/pyvm.cpp	/^    void opCallFunctionVarKw (int arg) {$/;"	f	struct:PyVM
opCallMethod	lib/pyvm/pyvm.cpp	/^    void opCallMethod (int arg) {$/;"	f	struct:PyVM
opCallMethodVarKw	lib/pyvm/pyvm.cpp	/^    void opCallMethodVarKw (int arg) {$/;"	f	struct:PyVM
opDefs	src/codegen.py	/^opDefs = []     # opcodes of type q)str, v)arint, o)ffset, and s)igned$/;"	v
opDeleteDeref	lib/pyvm/pyvm.cpp	/^    void opDeleteDeref (int arg) {$/;"	f	struct:PyVM
opDeleteFast	lib/pyvm/pyvm.cpp	/^    void opDeleteFast (int arg) {$/;"	f	struct:PyVM
opDeleteGlobal	lib/pyvm/pyvm.cpp	/^    void opDeleteGlobal (Q arg) {$/;"	f	struct:PyVM
opDeleteName	lib/pyvm/pyvm.cpp	/^    void opDeleteName (Q arg) {$/;"	f	struct:PyVM
opDupTop	lib/pyvm/pyvm.cpp	/^    void opDupTop () {$/;"	f	struct:PyVM
opDupTopTwo	lib/pyvm/pyvm.cpp	/^    void opDupTopTwo () {$/;"	f	struct:PyVM
opEndFinally	lib/pyvm/pyvm.cpp	/^    void opEndFinally () {$/;"	f	struct:PyVM
opForIter	lib/pyvm/pyvm.cpp	/^    void opForIter (int arg) {$/;"	f	struct:PyVM
opGetIter	lib/pyvm/pyvm.cpp	/^    void opGetIter () {$/;"	f	struct:PyVM
opGetIterStack	lib/pyvm/pyvm.cpp	/^    void opGetIterStack () {$/;"	f	struct:PyVM
opImportFrom	lib/pyvm/pyvm.cpp	/^    void opImportFrom (Q arg) {$/;"	f	struct:PyVM
opImportName	lib/pyvm/pyvm.cpp	/^    void opImportName (Q arg) {$/;"	f	struct:PyVM
opImportStar	lib/pyvm/pyvm.cpp	/^    void opImportStar () {$/;"	f	struct:PyVM
opJump	lib/pyvm/pyvm.cpp	/^    void opJump (int arg) {$/;"	f	struct:PyVM
opJumpIfFalseOrPop	lib/pyvm/pyvm.cpp	/^    void opJumpIfFalseOrPop (int arg) {$/;"	f	struct:PyVM
opJumpIfTrueOrPop	lib/pyvm/pyvm.cpp	/^    void opJumpIfTrueOrPop (int arg) {$/;"	f	struct:PyVM
opLoadAttr	lib/pyvm/pyvm.cpp	/^    void opLoadAttr (Q arg) {$/;"	f	struct:PyVM
opLoadBuildClass	lib/pyvm/pyvm.cpp	/^    void opLoadBuildClass () {$/;"	f	struct:PyVM
opLoadConstFalse	lib/pyvm/pyvm.cpp	/^    void opLoadConstFalse () {$/;"	f	struct:PyVM
opLoadConstNone	lib/pyvm/pyvm.cpp	/^    void opLoadConstNone () {$/;"	f	struct:PyVM
opLoadConstObj	lib/pyvm/pyvm.cpp	/^    void opLoadConstObj (int arg) {$/;"	f	struct:PyVM
opLoadConstSmallInt	lib/pyvm/pyvm.cpp	/^    void opLoadConstSmallInt () {$/;"	f	struct:PyVM
opLoadConstSmallIntMulti	lib/pyvm/pyvm.cpp	/^    void opLoadConstSmallIntMulti (uint32_t arg) {$/;"	f	struct:PyVM
opLoadConstString	lib/pyvm/pyvm.cpp	/^    void opLoadConstString (Q arg) {$/;"	f	struct:PyVM
opLoadConstTrue	lib/pyvm/pyvm.cpp	/^    void opLoadConstTrue () {$/;"	f	struct:PyVM
opLoadDeref	lib/pyvm/pyvm.cpp	/^    void opLoadDeref (int arg) {$/;"	f	struct:PyVM
opLoadFastMulti	lib/pyvm/pyvm.cpp	/^    void opLoadFastMulti (uint32_t arg) {$/;"	f	struct:PyVM
opLoadFastN	lib/pyvm/pyvm.cpp	/^    void opLoadFastN (int arg) {$/;"	f	struct:PyVM
opLoadGlobal	lib/pyvm/pyvm.cpp	/^    void opLoadGlobal (Q arg) {$/;"	f	struct:PyVM
opLoadMethod	lib/pyvm/pyvm.cpp	/^    void opLoadMethod (Q arg) {$/;"	f	struct:PyVM
opLoadName	lib/pyvm/pyvm.cpp	/^    void opLoadName (Q arg) {$/;"	f	struct:PyVM
opLoadNull	lib/pyvm/pyvm.cpp	/^    void opLoadNull () {$/;"	f	struct:PyVM
opLoadSubscr	lib/pyvm/pyvm.cpp	/^    void opLoadSubscr () {$/;"	f	struct:PyVM
opLoadSuperMethod	lib/pyvm/pyvm.cpp	/^    void opLoadSuperMethod (Q arg) {$/;"	f	struct:PyVM
opMakeClosure	lib/pyvm/pyvm.cpp	/^    void opMakeClosure (int arg) {$/;"	f	struct:PyVM
opMakeClosureDefargs	lib/pyvm/pyvm.cpp	/^    void opMakeClosureDefargs (int arg) {$/;"	f	struct:PyVM
opMakeFunction	lib/pyvm/pyvm.cpp	/^    void opMakeFunction (int arg) {$/;"	f	struct:PyVM
opMakeFunctionDefargs	lib/pyvm/pyvm.cpp	/^    void opMakeFunctionDefargs (int arg) {$/;"	f	struct:PyVM
opMulti	src/codegen.py	/^opMulti = []    # opcodes of type m)ulti are emitted separately$/;"	v
opPopExceptJump	lib/pyvm/pyvm.cpp	/^    void opPopExceptJump (int arg) {$/;"	f	struct:PyVM
opPopJumpIfFalse	lib/pyvm/pyvm.cpp	/^    void opPopJumpIfFalse (int arg) {$/;"	f	struct:PyVM
opPopJumpIfTrue	lib/pyvm/pyvm.cpp	/^    void opPopJumpIfTrue (int arg) {$/;"	f	struct:PyVM
opPopTop	lib/pyvm/pyvm.cpp	/^    void opPopTop () {$/;"	f	struct:PyVM
opRaiseFrom	lib/pyvm/pyvm.cpp	/^    void opRaiseFrom () {$/;"	f	struct:PyVM
opRaiseLast	lib/pyvm/pyvm.cpp	/^    void opRaiseLast () {$/;"	f	struct:PyVM
opRaiseObj	lib/pyvm/pyvm.cpp	/^    void opRaiseObj () {$/;"	f	struct:PyVM
opReturnValue	lib/pyvm/pyvm.cpp	/^    void opReturnValue () {$/;"	f	struct:PyVM
opRotThree	lib/pyvm/pyvm.cpp	/^    void opRotThree () {$/;"	f	struct:PyVM
opRotTwo	lib/pyvm/pyvm.cpp	/^    void opRotTwo () {$/;"	f	struct:PyVM
opSetupExcept	lib/pyvm/pyvm.cpp	/^    void opSetupExcept (int arg) {$/;"	f	struct:PyVM
opSetupFinally	lib/pyvm/pyvm.cpp	/^    void opSetupFinally (int arg) {$/;"	f	struct:PyVM
opSetupWith	lib/pyvm/pyvm.cpp	/^    void opSetupWith (int arg) {$/;"	f	struct:PyVM
opStoreAttr	lib/pyvm/pyvm.cpp	/^    void opStoreAttr (Q arg) {$/;"	f	struct:PyVM
opStoreComp	lib/pyvm/pyvm.cpp	/^    void opStoreComp (int arg) {$/;"	f	struct:PyVM
opStoreDeref	lib/pyvm/pyvm.cpp	/^    void opStoreDeref (int arg) {$/;"	f	struct:PyVM
opStoreFastMulti	lib/pyvm/pyvm.cpp	/^    void opStoreFastMulti (uint32_t arg) {$/;"	f	struct:PyVM
opStoreFastN	lib/pyvm/pyvm.cpp	/^    void opStoreFastN (int arg) {$/;"	f	struct:PyVM
opStoreGlobal	lib/pyvm/pyvm.cpp	/^    void opStoreGlobal (Q arg) {$/;"	f	struct:PyVM
opStoreMap	lib/pyvm/pyvm.cpp	/^    void opStoreMap () {$/;"	f	struct:PyVM
opStoreName	lib/pyvm/pyvm.cpp	/^    void opStoreName (Q arg) {$/;"	f	struct:PyVM
opStoreSubscr	lib/pyvm/pyvm.cpp	/^    void opStoreSubscr () {$/;"	f	struct:PyVM
opUnaryOpMulti	lib/pyvm/pyvm.cpp	/^    void opUnaryOpMulti (uint32_t arg) {$/;"	f	struct:PyVM
opUnpackEx	lib/pyvm/pyvm.cpp	/^    void opUnpackEx (int arg) {$/;"	f	struct:PyVM
opUnpackSequence	lib/pyvm/pyvm.cpp	/^    void opUnpackSequence (int arg) {$/;"	f	struct:PyVM
opUnwindJump	lib/pyvm/pyvm.cpp	/^    void opUnwindJump (int arg) {$/;"	f	struct:PyVM
opWithCleanup	lib/pyvm/pyvm.cpp	/^    void opWithCleanup () {$/;"	f	struct:PyVM
opYieldFrom	lib/pyvm/pyvm.cpp	/^    void opYieldFrom () {$/;"	f	struct:PyVM
opYieldValue	lib/pyvm/pyvm.cpp	/^    void opYieldValue () {$/;"	f	struct:PyVM
openSerialPort	src/mrfs.py	/^from runner import openSerialPort, compileIfOutdated, genHex$/;"	i
openSerialPort	src/runner.py	/^def openSerialPort():$/;"	f
openSerialPort	src/watcher.py	/^from runner import openSerialPort, compileIfOutdated, compileAndSend$/;"	i
operator ()	lib/hall-stm32/hall.h	/^        auto operator() (int off, int bit, uint8_t num =1) const {$/;"	f	struct:hall::Io32
operator ()	lib/hall-stm32/hall.h	/^        auto& operator() (int off) const {$/;"	f	struct:hall::IoBase
operator ()	lib/hall-stm32/hall.h	/^        auto& operator() (int off, int bit) const {$/;"	f	struct:hall::Io32b
operator ()	lib/mcu/printer.h	/^    auto operator() (const char* fmt, ...) {$/;"	f	struct:Printer
operator ()	tests/gpio/gpio.cpp	/^            auto operator() (int off, int bit, uint8_t num =1) const {$/;"	f	struct:gpio::Io32
operator ()	tests/gpio/gpio.cpp	/^            auto& operator() (int off) const {$/;"	f	struct:gpio::IoBase
operator *	lib/monty/monty.h	/^        auto operator* () { return _val; }$/;"	f	struct:monty::RawIter
operator ++	lib/monty/monty.h	/^        void operator++ () { _val = {}; }$/;"	f	struct:monty::RawIter
operator ->	lib/monty/monty.h	/^        auto operator-> () const { return _o; }$/;"	f	struct:monty::Value
operator =	lib/arch-stm32/jee-stm32.h	/^        void operator= (int v) const { write(v); }$/;"	f	struct:jeeh::Pin
operator =	lib/hall-stm32/hall.h	/^        void operator= (int v) const { write(v); }$/;"	f	struct:hall::Pin
operator =	lib/mcu/mcu.h	/^            void operator= (uint32_t v) const {$/;"	f	struct:mcu::IOWord::IOBit
operator =	lib/mcu/mcu.h	/^            void operator= (uint32_t v) const {$/;"	f	struct:mcu::IOWord::IOMask
operator =	lib/mcu/mcu.h	/^        void operator= (int v) const { write(v); }$/;"	f	struct:mcu::Pin
operator =	tests/gpio/gpio.cpp	/^        void operator= (int v) const { write(v); }$/;"	f	struct:gpio::Pin
operator =	tests/tdd/main.cpp	/^    S& operator= (S const& s) { printf("S%d = const& S%d\\n", id, s.id); return *this; }$/;"	f	struct:S
operator =	tests/tdd/main.cpp	/^    S& operator= (S&& s) { printf("S%d = && S%d\\n", id, s.id); return *this; }$/;"	f	struct:S
operator Value	lib/monty/monty.h	/^            operator Value () const { return ((Dict const&) d).at(k); }$/;"	f	struct:monty::Dict::Proxy
operator []	lib/mcu/mcu.h	/^        auto operator[] (int b) {$/;"	f	struct:mcu::IOWord
operator []	lib/mcu/mcu.h	/^        auto& operator[] (int b) {$/;"	f	struct:mcu::IOWord
operator bool	lib/graphics/twodee.h	/^        operator bool () const { return seen < w * h; }$/;"	f	struct:twodee::Glyph
operator bool	lib/graphics/twodee.h	/^        operator bool () const { return x <= 0; }$/;"	f	struct:twodee::ArcIter
operator bool	lib/graphics/twodee.h	/^        operator bool () const { return x0 <= x1; }$/;"	f	struct:twodee::LineIter
operator bool	lib/monty/monty.h	/^            operator bool () const { return ((Set const&) s).has(v); }$/;"	f	struct:monty::Set::Proxy
operator bool	lib/monty/monty.h	/^        operator bool () const { return _value; }$/;"	f	struct:monty::Event
operator bool	tests/buffers/main.cpp	/^        operator bool () const { return id != 0; }$/;"	f	struct:buf::Buf
operator char const*	lib/monty/data.cpp	/^Value::operator char const* () const {$/;"	f	class:Value
operator char const*	lib/monty/monty.h	/^        operator char const* () const { return (char const*) begin(); }$/;"	f	struct:monty::Str
operator char const*	lib/monty/monty.h	/^        operator char const* () const { return str(_id); }$/;"	f	struct:monty::Q
operator delete	lib/boss/boss.cpp	/^    void Buf::operator delete (void* p) {$/;"	f	class:boss::pool::Buf
operator delete	lib/monty/gc.cpp	/^    void Obj::operator delete (void* p) {$/;"	f	class:monty::Obj
operator delete	lib/monty/monty.h	/^        void operator delete (void*) {}$/;"	f	struct:monty::StaticObj
operator int	lib/arch-stm32/jee-stm32.h	/^        operator int () const { return read(); }$/;"	f	struct:jeeh::Pin
operator int	lib/hall-stm32/hall.h	/^        operator int () const { return read(); }$/;"	f	struct:hall::Pin
operator int	lib/mcu/mcu.h	/^        operator int () const { return read(); }$/;"	f	struct:mcu::Pin
operator int	lib/monty/monty.h	/^        operator int () const { return (intptr_t) _v >> 1; }$/;"	f	struct:monty::Value
operator int	tests/gpio/gpio.cpp	/^        operator int () const { return read(); }$/;"	f	struct:gpio::Pin
operator int64_t	lib/monty/monty.h	/^        operator int64_t () const { return _i64; }$/;"	f	struct:monty::Int
operator uint16_t	lib/monty/monty.h	/^        constexpr operator uint16_t () const { return _id; }$/;"	f	struct:monty::Q
operator uint32_t	lib/mcu/mcu.h	/^            operator uint32_t () const { return (addr >> bit) & 1; }$/;"	f	struct:mcu::IOWord::IOBit
operator uint32_t	lib/mcu/mcu.h	/^            operator uint32_t () const {$/;"	f	struct:mcu::IOWord::IOMask
operator uint32_t	lib/mcu/mcu.h	/^        operator uint32_t () const { return addr; }$/;"	f	struct:mcu::IOWord
operator uint8_t*	tests/buffers/main.cpp	/^    Buf::operator uint8_t* () const {$/;"	f	class:buf::Buf
order_by	lib/doctest/doctest.h	/^    String   order_by;  \/\/ how tests should be ordered$/;"	m	struct:doctest::ContextOptions
order_by	tests/embed/src/doctestx.h	/^    String   order_by;  \/\/ how tests should be ordered$/;"	m	struct:doctest::ContextOptions
os	lib/mrfs/test.py	/^import doctest, os, subprocess$/;"	i
os	src/altpins.py	/^import os, re, sys$/;"	i
os	src/codegen.py	/^import os, re, sys, subprocess$/;"	i
os	src/device.py	/^import configparser, os, re, sys$/;"	i
os	src/mrfs.py	/^import io, os, sys, time$/;"	i
os	src/runner.py	/^import os, re, subprocess, sys, time$/;"	i
os	src/tdd.py	/^import os, subprocess, sys, time$/;"	i
os	src/watcher.py	/^import os, subprocess, sys, time$/;"	i
ospeedr	lib/arch-stm32/jee-stm32.h	/^        enum { moder=0x00, typer=0x04, ospeedr=0x08, pupdr=0x0C, idr=0x10,$/;"	e	enum:jeeh::Pin::__anon23
other	lib/monty/gc.cpp	/^    Object* other;$/;"	m	struct:MarkObj	file:
other	tests/unit/mem/main.cpp	/^    Object* other;$/;"	m	struct:MarkObj	file:
out	lib/doctest/doctest.h	/^    String   out;       \/\/ output filename$/;"	m	struct:doctest::ContextOptions
out	lib/graphics/mod-graphics.cpp	/^    static void out () { pos({0,0}); printf("\\x1B[m"); fflush(stdout); }$/;"	f	struct:Tft
out	tests/embed/src/doctestx.h	/^    String   out;       \/\/ output filename$/;"	m	struct:doctest::ContextOptions
outCh	tests/smoke/src/main3.cpp	/^void outCh (int ch) {$/;"	f
outCh	tests/smoke/src/main4.cpp	/^void outCh (int ch) {$/;"	f
outCh	tests/smoke/src/main5.cpp	/^void outCh (void*, int ch) {$/;"	f
outCh	tests/smoke/src/main6.cpp	/^void outCh (void*, int ch) {$/;"	f
outFun	lib/arch-stm32/arch.cpp	/^static auto outFun = outch;$/;"	v	file:
outOfObjs	tests/unit/mem/main.cpp	/^void outOfObjs () {$/;"	f
outOfVecs	tests/unit/mem/main.cpp	/^void outOfVecs () {$/;"	f
outQueue	lib/arch-stm32/arch.cpp	/^    static Event outQueue;$/;"	m	struct:LineSerial	file:
outQueue	lib/arch-stm32/arch.cpp	/^Event LineSerial::outQueue;$/;"	m	class:LineSerial	file:
outch	lib/arch-stm32/arch.cpp	/^static void outch (int c) {$/;"	f	file:
override	lib/extend/typ-array.h	/^        auto copy (Range const&) const -> Value override;$/;"	m	struct:monty::Array
override	lib/extend/typ-array.h	/^        auto getAt (Value k) const -> Value override;$/;"	m	struct:monty::Array
override	lib/extend/typ-array.h	/^        auto len () const -> uint32_t override;$/;"	m	struct:monty::Array
override	lib/extend/typ-array.h	/^        auto setAt (Value k, Value v) -> Value override;$/;"	m	struct:monty::Array
override	lib/extend/typ-array.h	/^        auto store (Range const&, Object const&) -> Value override;$/;"	m	struct:monty::Array
override	lib/monty/monty.h	/^        auto binop (BinOp, Value) const -> Value override;$/;"	m	struct:monty::Bytes
override	lib/monty/monty.h	/^        auto binop (BinOp, Value) const -> Value override;$/;"	m	struct:monty::Exception
override	lib/monty/monty.h	/^        auto binop (BinOp, Value) const -> Value override;$/;"	m	struct:monty::Int
override	lib/monty/monty.h	/^        auto binop (BinOp, Value) const -> Value override;$/;"	m	struct:monty::None
override	lib/monty/monty.h	/^        auto binop (BinOp, Value) const -> Value override;$/;"	m	struct:monty::Set
override	lib/monty/monty.h	/^        auto binop (BinOp, Value) const -> Value override;$/;"	m	struct:monty::Str
override	lib/monty/monty.h	/^        auto call (ArgVec const& args) const -> Value override;$/;"	m	struct:monty::Function
override	lib/monty/monty.h	/^        auto copy (Range const&) const -> Value override;$/;"	m	struct:monty::Bytes
override	lib/monty/monty.h	/^        auto copy (Range const&) const -> Value override;$/;"	m	struct:monty::Tuple
override	lib/monty/monty.h	/^        auto getAt (Value k) const -> Value override;$/;"	m	struct:monty::Bytes
override	lib/monty/monty.h	/^        auto getAt (Value k) const -> Value override;$/;"	m	struct:monty::Lookup
override	lib/monty/monty.h	/^        auto getAt (Value k) const -> Value override;$/;"	m	struct:monty::Set
override	lib/monty/monty.h	/^        auto getAt (Value k) const -> Value override;$/;"	m	struct:monty::Str
override	lib/monty/monty.h	/^        auto getAt (Value k) const -> Value override;$/;"	m	struct:monty::Tuple
override	lib/monty/monty.h	/^        auto len () const -> uint32_t override;$/;"	m	struct:monty::Range
override	lib/monty/monty.h	/^        auto setAt (Value k, Value v) -> Value override;$/;"	m	struct:monty::List
override	lib/monty/monty.h	/^        auto setAt (Value k, Value v) -> Value override;$/;"	m	struct:monty::Set
override	lib/monty/monty.h	/^        auto store (Range const&, Object const&) -> Value override;$/;"	m	struct:monty::List
override	lib/monty/monty.h	/^        auto unop (UnOp) const -> Value override;$/;"	m	struct:monty::Bool
override	lib/monty/monty.h	/^        auto unop (UnOp) const -> Value override;$/;"	m	struct:monty::Bytes
override	lib/monty/monty.h	/^        auto unop (UnOp) const -> Value override;$/;"	m	struct:monty::Event
override	lib/monty/monty.h	/^        auto unop (UnOp) const -> Value override;$/;"	m	struct:monty::Int
override	lib/monty/monty.h	/^        auto unop (UnOp) const -> Value override;$/;"	m	struct:monty::Str
override	lib/monty/monty.h	/^        void marker () const override;$/;"	m	struct:monty::Context
override	lib/monty/monty.h	/^        void marker () const override;$/;"	m	struct:monty::Dict
override	lib/monty/monty.h	/^        void marker () const override;$/;"	m	struct:monty::Exception
override	lib/monty/monty.h	/^        void repr (Buffer&) const override;$/;"	m	struct:monty::Exception
override	lib/monty/monty.h	/^        void repr (Buffer&) const override;$/;"	m	struct:monty::Inst
override	lib/monty/monty.h	/^        void repr (Buffer&) const override;$/;"	m	struct:monty::Module
override	lib/monty/monty.h	/^        void repr (Buffer&) const override;$/;"	m	struct:monty::None
override	lib/monty/monty.h	/^        ~Buffer () override;$/;"	m	struct:monty::Buffer
override	lib/monty/type.cpp	/^    auto getAt (Value k) const -> Value override;$/;"	m	struct:DictView	file:
override	lib/pyvm/pyvm.cpp	/^    auto call (ArgVec const&) const -> Value override;$/;"	m	struct:Callable	file:
override	lib/pyvm/pyvm.cpp	/^    void marker () const override;$/;"	m	struct:Callable	file:
override	lib/pyvm/pyvm.cpp	/^    void repr (Buffer& buf) const override;$/;"	m	struct:Closure	file:
owner	tests/native/memTest.cpp	/^        Vec* owner;$/;"	m	struct:mem::vec::Slot	file:
p	tests/py/array.py	/^def p(a):$/;"	f
p	tests/py/features.py	/^    p = 37$/;"	v
p	tests/py/features.py	/^    p = p + 1$/;"	v
p	tests/py/features.py	/^def p(s):$/;"	f
p	tests/py/features.py	/^p = 0$/;"	v
p	tests/py/features.py	/^p = 36$/;"	v
pack	src/mrfs.py	/^from struct import pack, unpack$/;"	i
pad	lib/mcu/printer.h	/^    int8_t pad, width, radix, fill, limit;$/;"	m	struct:Printer
pad	src/mrfs.py	/^        pad = (-size&31) * b'\\0'$/;"	v
panic	lib/arch-stm32/arch.cpp	/^void panic (char const* msg) {$/;"	f
panicOutOfMemory	lib/monty/gc.cpp	/^    void* (*panicOutOfMemory)() = defaultOutOfMemoryHandler;$/;"	m	namespace:monty	file:
parity	lib/arch-stm32/jee-rf69.h	/^        uint8_t parity;$/;"	m	struct:jeeh::RF69
parse	src/xmltodict.py	/^def parse(xml_input, encoding=None, expat=expat, process_namespaces=False,$/;"	f
parseArgs	src/codegen.py	/^def parseArgs(params):$/;"	f
parsed	src/device.py	/^    parsed = xmltodict.parse(f)$/;"	v
patch	src/device.py	/^def patch(name):$/;"	f
patches	src/device.py	/^patches = cfg[svdName[:7].upper()]$/;"	v
path	src/codegen.py	/^from os import path$/;"	i
path	src/device.py	/^from os import path$/;"	i
payload	tests/native/memTest.cpp	/^        auto payload () { return (uint8_t*) &next; }$/;"	f	struct:mem::vec::Slot
pending	lib/boss/boss.h	/^        static volatile uint32_t pending;$/;"	m	struct:boss::boss::Device
pending	lib/hall-stm32/hall.cpp	/^volatile uint32_t Device::pending;$/;"	m	class:Device	file:
pending	lib/mcu/mcu.cpp	/^    uint32_t Device::pending;$/;"	m	class:mcu::Device	file:
pending	lib/mcu/mcu.h	/^        static uint32_t pending;$/;"	m	struct:mcu::Device
pending	lib/monty/monty.h	/^        static volatile uint32_t pending;$/;"	m	struct:monty::Stacklet
pending	lib/monty/stack.cpp	/^uint32_t volatile Stacklet::pending;$/;"	m	class:Stacklet	file:
periphs	src/device.py	/^periphs = []$/;"	v
persist	lib/arch-stm32/arch.cpp	/^    static char* persist; \/\/ pointer to a buffer which persists across resets$/;"	v	file:
pin	lib/arch-stm32/altpins.h	/^struct AltPins { uint8_t pin, dev :4, alt :4; };$/;"	m	struct:AltPins
pin	lib/hall-stm32/hall.h	/^        uint8_t port :4, pin :4;$/;"	m	struct:hall::Pin
pin	lib/mcu/altpins.h	/^struct AltPins { uint8_t pin, dev :4, alt :4; };$/;"	m	struct:AltPins
pin	tests/gpio/gpio.cpp	/^        uint8_t port :4, pin :4;$/;"	m	struct:gpio::Pin	file:
pins	lib/arch-stm32/mod-machine.cpp	/^static Pins pins; \/\/ there is one static pins object, used via attr access$/;"	v	file:
pixFlood	lib/graphics/twodee.h	/^        static void pixFlood (Rect const& r, unsigned c) {$/;"	f	struct:twodee::TwoDee
pixel	lib/graphics/twodee.h	/^        static void pixel (Point p, unsigned c =fg) {$/;"	f	struct:twodee::TwoDee
pixel	lib/graphics/twodee.h	/^        static void pixel (int x, int y, unsigned c =fg) { pixel({x,y}, c); }$/;"	f	struct:twodee::TwoDee
pool	lib/arch-native/arch.cpp	/^static void* pool;$/;"	v	file:
pool	lib/boss/boss.cpp	/^namespace boss::pool {$/;"	n	class:boss	file:
pool	lib/boss/boss.h	/^namespace boss::pool {$/;"	n	class:boss
pop	lib/monty/monty.h	/^        auto pop () { return pull(_fill-1); } \/\/ pull from end$/;"	f	struct:monty::VecOf
port	lib/hall-stm32/hall.h	/^        uint8_t port :4, pin :4;$/;"	m	struct:hall::Pin
port	tests/gpio/gpio.cpp	/^        uint8_t port :4, pin :4;$/;"	m	struct:gpio::Pin	file:
pos	lib/arch-stm32/prelude.h	/^    uint8_t pos :4, num :4, ena;$/;"	m	struct:IrqVec::DevInfo
pos	lib/graphics/mod-graphics.cpp	/^    static void pos (Point p)       { printf("\\x1B[%d;%dH", p.y+1, p.x+1); }$/;"	f	struct:Tft
pos	lib/mcu/prelude.h	/^    uint8_t pos :4, num :4, ena;$/;"	m	struct:IrqVec::DevInfo
prevIsr	lib/arch-stm32/arch.cpp	/^    static void (*prevIsr)();$/;"	m	struct:LineSerial	file:
prevIsr	lib/arch-stm32/arch.cpp	/^void (*LineSerial::prevIsr)();$/;"	v
print	lib/monty/type.cpp	/^void Buffer::print (char const* fmt, ...) {$/;"	f	class:Buffer
print	tests/py/features.py	/^    def print(self):$/;"	m	class:A
printSeparator	src/runner.py	/^def printSeparator(fn, e=None):$/;"	f
printer	lib/monty/type.cpp	/^void Tuple::printer (Buffer& buf, char const* sep) const {$/;"	f	class:Tuple
printf	lib/arch-stm32/arch.cpp	/^int printf(char const* fmt, ...) {$/;"	f
printf	lib/mcu/mcu.cpp	/^int printf (const char* fmt, ...) {$/;"	f
printf	tests/smoke/src/main5.cpp	/^extern "C" int printf (const char* fmt, ...) {$/;"	f
printf	tests/smoke/src/main6.cpp	/^extern "C" int printf (const char* fmt, ...) {$/;"	f
printf	tests/smoke/src/main7.cpp	/^extern "C" int printf (const char* fmt, ...) {$/;"	f
printf	tests/smoke/src/main8.cpp	/^extern "C" int printf (const char* fmt, ...) {$/;"	f
process	lib/boss/boss.h	/^        virtual void process () {}$/;"	f	struct:boss::boss::Device
processFile	src/codegen.py	/^def processFile(fpath):$/;"	f
processLines	src/codegen.py	/^def processLines(lines):$/;"	f
processPending	lib/boss/boss.cpp	/^void Fiber::processPending () {$/;"	f	class:Fiber
processPin	src/altpins.py	/^    def processPin():$/;"	f	function:extract
ptr	lib/doctest/doctest.h	/^        char*    ptr;$/;"	m	struct:doctest::String::view
ptr	lib/monty/monty.h	/^        auto ptr () const { return _data; }$/;"	f	struct:monty::Vec
ptr	tests/embed/src/doctestx.h	/^        char*    ptr;$/;"	m	struct:doctest::String::view
ptr	tests/native/memTest.cpp	/^        auto ptr () { return _data; }$/;"	f	struct:mem::Vec
publicTypes	src/codegen.py	/^publicTypes = []$/;"	v
pupdr	lib/arch-stm32/jee-stm32.h	/^        enum { moder=0x00, typer=0x04, ospeedr=0x08, pupdr=0x0C, idr=0x10,$/;"	e	enum:jeeh::Pin::__anon23
push	lib/monty/monty.h	/^        void push (T v, uint32_t idx =0) {$/;"	f	struct:monty::VecOf
push_data	src/xmltodict.py	/^    def push_data(self, item, key, data):$/;"	m	class:_DictSAXHandler
putFiller	lib/mcu/printer.h	/^    void putFiller (int n) {$/;"	f	struct:Printer
putFiller	lib/monty/type.cpp	/^void Buffer::putFiller (int n, char fill) {$/;"	f	class:Buffer
putInt	lib/monty/type.cpp	/^void Buffer::putInt (int val, int base, int width, char fill) {$/;"	f	class:Buffer
putc	lib/hall-stm32/stm32l4-uart.cpp	/^    void putc (int n, int c) {$/;"	f	namespace:hall::uart
putc	lib/monty/monty.h	/^        void putc (char v) { write((uint8_t const*) &v, 1); }$/;"	f	struct:monty::Buffer
putcEsc	lib/monty/type.cpp	/^static void putcEsc (Buffer& buf, char const* fmt, uint8_t ch) {$/;"	f	file:
putchar	lib/arch-stm32/arch.cpp	/^extern "C" int putchar (int ch) { return printf("%c", ch); }$/;"	f
putchar	lib/mcu/mcu.cpp	/^int putchar (int c) { return printf("%c", c); }$/;"	f
puts	lib/arch-stm32/arch.cpp	/^extern "C" int puts (char const* s) { return printf("%s\\n", s); }$/;"	f
puts	lib/mcu/mcu.cpp	/^int puts (char const* s) { return printf("%s\\n", s); }$/;"	f
puts	lib/monty/monty.h	/^        void puts (char const* s) { write((uint8_t const*) s, strlen(s)); }$/;"	f	struct:monty::Buffer
putsEsc	lib/monty/type.cpp	/^static void putsEsc (Buffer& buf, Value s) {$/;"	f	file:
py	src/watcher.py	/^    py = sys.argv[2]$/;"	v
py	src/watcher.py	/^py = sys.argv[1]$/;"	v
q	src/codegen.py	/^def q(s, a=None):$/;"	f
qWin	lib/pyvm/loader.h	/^    VecOf<uint16_t> qWin;$/;"	m	struct:Loader
qarch	src/codegen.py	/^def qarch(name):$/;"	f
qfix	src/codegen.py	/^    def qfix(m):$/;"	f	function:processLines
qid	src/codegen.py	/^def qid(s):$/;"	f
qstrBase	lib/monty/qstr.cpp	/^extern char const monty::qstrBase [] =$/;"	m	class:monty	file:
qstrBaseLen	lib/monty/qstr.cpp	/^int const monty::qstrBaseLen = sizeof qstrBase;$/;"	m	class:monty	file:
qstrCleanup	lib/monty/data.cpp	/^void monty::qstrCleanup () {$/;"	f	class:monty
qstrData	lib/monty/qstr.h	/^    char const qstrData [] =$/;"	m	namespace:monty
qstrLen	src/codegen.py	/^qstrLen = []    # per id, the symbol length + 1$/;"	v
qstrMap	src/codegen.py	/^qstrMap = {}    # map string to id$/;"	v
qstrRamMap	lib/monty/data.cpp	/^static VaryVec qstrRamMap;$/;"	v	file:
queued	lib/monty/monty.h	/^        static int queued;$/;"	m	struct:monty::Event
queued	lib/monty/stack.cpp	/^int Event::queued;$/;"	m	class:Event	file:
r	lib/graphics/twodee.h	/^        int16_t r, x, y, err;$/;"	m	struct:twodee::ArcIter
r	src/device.py	/^        r = drxBits[n-1] if n-1 < len(drxBits) else "1c0s0"$/;"	v
r	tests/py/range.py	/^r = range(1,11,3)$/;"	v
rFill	lib/graphics/twodee.h	/^        static void rFill (Point p, unsigned w, unsigned h, unsigned n) {$/;"	f	struct:twodee::TwoDee
rFill	lib/graphics/twodee.h	/^        static void rFill (Point p1, Point p2, unsigned n) { rFill({p1, p2}, n); }$/;"	f	struct:twodee::TwoDee
rFill	lib/graphics/twodee.h	/^        static void rFill (Rect const& r, unsigned n) { rFill(r, r.w, r.h, n); }$/;"	f	struct:twodee::TwoDee
radix	lib/mcu/printer.h	/^    int8_t pad, width, radix, fill, limit;$/;"	m	struct:Printer
raise	lib/monty/stack.cpp	/^void Context::raise (Value v) {$/;"	f	class:Context
rand_seed	lib/doctest/doctest.h	/^    unsigned rand_seed; \/\/ the seed for rand ordering$/;"	m	struct:doctest::ContextOptions
rand_seed	tests/embed/src/doctestx.h	/^    unsigned rand_seed; \/\/ the seed for rand ordering$/;"	m	struct:doctest::ContextOptions
rate	lib/hall-stm32/hall.cpp	/^        rate = ms;$/;"	m	namespace:hall::systick	file:
re	src/altpins.py	/^import os, re, sys$/;"	i
re	src/codegen.py	/^import os, re, sys, subprocess$/;"	i
re	src/device.py	/^import configparser, os, re, sys$/;"	i
re	src/runner.py	/^import os, re, subprocess, sys, time$/;"	i
read	lib/hall-stm32/hall.h	/^        auto read () const { return (gpio32(IDR)>>pin) & 1; }$/;"	f	struct:hall::Pin
read	lib/mcu/mcu.h	/^        auto read () const { return (gpio32(IDR)>>_pin) & 1; }$/;"	f	struct:mcu::Pin
read	lib/mcu/mcu.h	/^        auto read(bool last) const {$/;"	f	struct:mcu::I2cGpio
read	lib/mcu/mcu.h	/^        void read (int offset, uint8_t* buf, int len) {$/;"	f	struct:mcu::SpiFlash
read	lib/mcu/mcu.h	/^        void read (uint8_t* buf, int len) const {$/;"	f	struct:mcu::SpiGpio
read	tests/gpio/gpio.cpp	/^        auto read () const { return GPIO(LEV0, pin); }$/;"	f	struct:gpio::Pin
read	tests/py/other/d_test.py	/^def read(self, data, limit=-1, start=0):$/;"	f
readcount	tests/py/other/d_test.py	/^def readcount(self, data, count):$/;"	f
readline	tests/py/other/d_test.py	/^def readline(self, data, delim=10):$/;"	f
ready	lib/boss/boss.cpp	/^pool::Queue Fiber::ready;$/;"	m	class:Fiber	file:
ready	lib/monty/monty.h	/^        static List ready;$/;"	m	struct:monty::Context
receive	lib/arch-stm32/jee-stm32.h	/^        void receive (uint8_t* buf, int len) const {$/;"	f	struct:jeeh::SpiGpio
regs	src/device.py	/^regs = []$/;"	v
relPos	lib/monty/monty.h	/^        auto relPos (int i) const { return i < 0 ? i + _fill : i; }$/;"	f	struct:monty::VecOf
remove	lib/boss/boss.h	/^        auto remove (F f) {$/;"	f	struct:boss::pool::Queue
remove	lib/extend/typ-array.cpp	/^void Array::remove (uint32_t idx, uint32_t num) {$/;"	f	class:Array
remove	lib/monty/monty.h	/^        void remove (uint32_t idx, uint32_t num =1) {$/;"	f	struct:monty::VecOf
remove	lib/monty/type.cpp	/^void VaryVec::remove (uint32_t idx, uint32_t num) {$/;"	f	class:VaryVec
removeBuild	src/tdd.py	/^def removeBuild(bn):$/;"	f
remove_const	lib/doctest/doctest.h	/^    template<class T> struct remove_const          { typedef T type; };$/;"	s	namespace:doctest::detail
remove_const	lib/doctest/doctest.h	/^    template<class T> struct remove_const<const T> { typedef T type; };$/;"	s	namespace:doctest::detail
remove_const	tests/embed/src/doctestx.h	/^    template<class T> struct remove_const          { typedef T type; };$/;"	s	namespace:doctest::detail
remove_const	tests/embed/src/doctestx.h	/^    template<class T> struct remove_const<const T> { typedef T type; };$/;"	s	namespace:doctest::detail
remove_reference	lib/doctest/doctest.h	/^    template<class T> struct remove_reference      { typedef T type; };$/;"	s	namespace:doctest::detail
remove_reference	lib/doctest/doctest.h	/^    template<class T> struct remove_reference<T&&> { typedef T type; };$/;"	s	namespace:doctest::detail
remove_reference	lib/doctest/doctest.h	/^    template<class T> struct remove_reference<T&>  { typedef T type; };$/;"	s	namespace:doctest::detail
remove_reference	tests/embed/src/doctestx.h	/^    template<class T> struct remove_reference      { typedef T type; };$/;"	s	namespace:doctest::detail
remove_reference	tests/embed/src/doctestx.h	/^    template<class T> struct remove_reference<T&&> { typedef T type; };$/;"	s	namespace:doctest::detail
remove_reference	tests/embed/src/doctestx.h	/^    template<class T> struct remove_reference<T&>  { typedef T type; };$/;"	s	namespace:doctest::detail
repr	lib/extend/typ-array.cpp	/^void Array::repr (Buffer& buf) const {$/;"	f	class:Array
repr	lib/monty/builtin.cpp	/^void Exception::repr (Buffer& buf) const {$/;"	f	class:Exception
repr	lib/monty/data.cpp	/^void Bool::repr (Buffer& buf) const {$/;"	f	class:Bool
repr	lib/monty/data.cpp	/^void Int::repr (Buffer& buf) const {$/;"	f	class:Int
repr	lib/monty/data.cpp	/^void None::repr (Buffer& buf) const {$/;"	f	class:None
repr	lib/monty/data.cpp	/^void Object::repr (Buffer& buf) const {$/;"	f	class:Object
repr	lib/monty/data.cpp	/^void Range::repr (Buffer& buf) const {$/;"	f	class:Range
repr	lib/monty/data.cpp	/^void Slice::repr (Buffer& buf) const {$/;"	f	class:Slice
repr	lib/monty/stack.cpp	/^void Event::repr (Buffer& buf) const {$/;"	f	class:Event
repr	lib/monty/stack.cpp	/^void Module::repr (Buffer& buf) const {$/;"	f	class:Module
repr	lib/monty/type.cpp	/^void Bytes::repr (Buffer& buf) const {$/;"	f	class:Bytes
repr	lib/monty/type.cpp	/^void Class::repr (Buffer& buf) const {$/;"	f	class:Class
repr	lib/monty/type.cpp	/^void Dict::repr (Buffer& buf) const {$/;"	f	class:Dict
repr	lib/monty/type.cpp	/^void Inst::repr (Buffer& buf) const {$/;"	f	class:Inst
repr	lib/monty/type.cpp	/^void List::repr (Buffer& buf) const {$/;"	f	class:List
repr	lib/monty/type.cpp	/^void Set::repr (Buffer& buf) const {$/;"	f	class:Set
repr	lib/monty/type.cpp	/^void Str::repr (Buffer& buf) const {$/;"	f	class:Str
repr	lib/monty/type.cpp	/^void Super::repr (Buffer& buf) const {$/;"	f	class:Super
repr	lib/monty/type.cpp	/^void Tuple::repr (Buffer& buf) const {$/;"	f	class:Tuple
repr	lib/monty/type.cpp	/^void Type::repr (Buffer& buf) const {$/;"	f	class:Type
repr	lib/pyvm/pyvm.cpp	/^void Closure::repr (Buffer& buf) const {$/;"	f	class:Closure
reprBasics	tests/unit/repr/main.cpp	/^static void reprBasics () {$/;"	f	file:
reprTypeSizes	tests/unit/repr/main.cpp	/^void reprTypeSizes () {$/;"	f
reserveLimit	lib/mcu/mcu.cpp	/^    uint8_t *reserveNext, *reserveLimit;$/;"	m	namespace:mcu	file:
reserveNext	lib/mcu/mcu.cpp	/^    uint8_t *reserveNext, *reserveLimit;$/;"	m	namespace:mcu	file:
reset	lib/arch-stm32/arch.h	/^        static void reset [[noreturn]] () {$/;"	f	struct:arch::Device
reset	lib/mcu/mcu.h	/^        void reset () {$/;"	f	struct:mcu::SpiFlash
resizeVec	tests/unit/mem/main.cpp	/^void resizeVec () {$/;"	f
rest	lib/extend/typ-array.cpp	/^    constexpr static auto rest = (1 << shft) - 1;   \/\/ 7 3 1$/;"	m	struct:AccessAsBits	file:
result	lib/pyvm/pyvm.cpp	/^        Value base, spOff, ipOff, callee, ep, locals, result, stack [];$/;"	m	struct:PyVM::Frame	file:
results	src/runner.py	/^                results = []$/;"	v
results	src/runner.py	/^        results = []$/;"	v
resume	lib/boss/boss.h	/^        void resume (int i) { result = i; ready.append(id()); }$/;"	f	struct:boss::boss::Fiber
resumeCaller	lib/monty/stack.cpp	/^void Context::resumeCaller (Value v) {$/;"	f	class:Context
resumeFixer	lib/boss/boss.cpp	/^auto resumeFixer (void* top) {$/;"	f
resumer	lib/monty/stack.cpp	/^static jmp_buf* resumer;$/;"	v	file:
returner	lib/boss/boss.cpp	/^jmp_buf returner;$/;"	v
reuseObjs	tests/unit/mem/main.cpp	/^void reuseObjs () {$/;"	f
reuseVecs	tests/unit/mem/main.cpp	/^void reuseVecs () {$/;"	f
rf69	tests/py/s_rf69.py	/^rf69 = machine.rf69("B7,B6,B0,A12", 63, 42, 868)$/;"	v
root	src/codegen.py	/^root = os.environ.get("MONTY_ROOT", "") # set when used out-of-tree$/;"	v
round	lib/graphics/twodee.h	/^        static void round (Point p, unsigned w, unsigned h, unsigned n) {$/;"	f	struct:twodee::TwoDee
round	lib/graphics/twodee.h	/^        static void round (Point p1, Point p2, unsigned n) { round({p1, p2}, n); }$/;"	f	struct:twodee::TwoDee
round	lib/graphics/twodee.h	/^        static void round (Rect const& r, unsigned n) { round(r, r.w, r.h, n); }$/;"	f	struct:twodee::TwoDee
rssi	lib/arch-stm32/jee-rf69.h	/^        uint8_t rssi;$/;"	m	struct:jeeh::RF69
rtc	lib/hall-stm32/hall.h	/^    namespace rtc {$/;"	n	namespace:hall
rtc	lib/hall-stm32/stm32l4.cpp	/^    namespace rtc {$/;"	n	namespace:hall	file:
rtc	lib/mcu/mcu.h	/^    namespace rtc {$/;"	n	namespace:mcu
run	lib/graphics/twodee.h	/^        Run run;$/;"	m	struct:twodee::Glyph
rwCounts	src/codegen.py	/^rwCounts = 0        # number of files which have been rewritten$/;"	v
rxBuf	lib/arch-stm32/uart-f1.h	/^    uint8_t rxBuf [100];$/;"	m	struct:Uart
rxBuf	lib/arch-stm32/uart-f4.h	/^    uint8_t rxBuf [100];$/;"	m	struct:Uart
rxBuf	lib/arch-stm32/uart-l0.h	/^    uint8_t rxBuf [100];$/;"	m	struct:Uart
rxBuf	lib/arch-stm32/uart-l4.h	/^    uint8_t rxBuf [100];$/;"	m	struct:Uart
rxBuf	lib/hall-stm32/stm32l4-uart.cpp	/^    uint8_t* rxBuf;$/;"	m	struct:Uart	file:
rxBuf	lib/mcu/uart-stm32f4f7.h	/^    uint8_t rxBuf [100], txBuf [100];$/;"	m	struct:Uart
rxBuf	lib/mcu/uart-stm32l4.h	/^    uint8_t rxBuf [100], txBuf [100];$/;"	m	struct:Uart
rxChan	lib/arch-stm32/prelude.h	/^    uint8_t rxDma :1, rxChan :4, rxStream :3;$/;"	m	struct:IrqVec::DevInfo
rxChan	lib/hall-stm32/stm32l4-uart.cpp	/^    uint16_t dma :1, rxChan :4, rxStream :3, txChan :4, txStream :3;$/;"	m	struct:UartInfo	file:
rxChan	lib/mcu/prelude.h	/^    uint8_t rxDma :1, rxChan :4, rxStream :3;$/;"	m	struct:IrqVec::DevInfo
rxDma	lib/arch-stm32/prelude.h	/^    uint8_t rxDma :1, rxChan :4, rxStream :3;$/;"	m	struct:IrqVec::DevInfo
rxDma	lib/mcu/prelude.h	/^    uint8_t rxDma :1, rxChan :4, rxStream :3;$/;"	m	struct:IrqVec::DevInfo
rxId	lib/arch-stm32/arch.cpp	/^    static uint8_t rxId, txId;$/;"	m	struct:LineSerial	file:
rxId	lib/arch-stm32/arch.cpp	/^uint8_t LineSerial::rxId;$/;"	m	class:LineSerial	file:
rxPull	lib/mcu/mcu.h	/^        uint16_t rxPull =0;$/;"	m	struct:mcu::Serial
rxStream	lib/arch-stm32/prelude.h	/^    uint8_t rxDma :1, rxChan :4, rxStream :3;$/;"	m	struct:IrqVec::DevInfo
rxStream	lib/hall-stm32/stm32l4-uart.cpp	/^    uint16_t dma :1, rxChan :4, rxStream :3, txChan :4, txStream :3;$/;"	m	struct:UartInfo	file:
rxStream	lib/mcu/prelude.h	/^    uint8_t rxDma :1, rxChan :4, rxStream :3;$/;"	m	struct:IrqVec::DevInfo
s	lib/monty/monty.h	/^        struct Proxy { Set& s; Value v;$/;"	m	struct:monty::Set::Proxy
s	src/device.py	/^            s = re.search(r"(\\d)_(\\d)$", q)$/;"	v
s	tests/py/set.py	/^s = {1,2,3,"a"}$/;"	v
s	tests/py/slice.py	/^s = slice(1,2,3)$/;"	v
s	tests/py/slice.py	/^s = slice(4)$/;"	v
s	tests/py/slice.py	/^s = slice(None)$/;"	v
s	tests/py/slice.py	/^s = slice(None,5)$/;"	v
s	tests/py/slice.py	/^s = slice(None,None,6)$/;"	v
sTop	lib/pyvm/loader.h	/^    int8_t sTop;    \/\/ stack top$/;"	m	struct:CodePrefix
save	lib/mrfs/mrfs.cpp	/^static void save (int ac, char const** av) {$/;"	f	file:
saveToFlash	lib/arch-stm32/arch.cpp	/^    void saveToFlash (uint32_t off, void const* buf, int len) {$/;"	f
saveToFlash	lib/mrfs/mrfs.cpp	/^static void saveToFlash (void* addr, mrfs::Info& info, void const* buf) {$/;"	f	file:
scan	src/altpins.py	/^def scan():$/;"	f
scanSources	src/tdd.py	/^def scanSources():$/;"	f
sclHi	lib/mcu/mcu.h	/^        void sclHi () const {$/;"	f	struct:mcu::I2cGpio
sclLo	lib/mcu/mcu.h	/^        void sclLo () const {$/;"	f	struct:mcu::I2cGpio
seen	lib/graphics/twodee.h	/^        uint16_t seen, bits;$/;"	m	struct:twodee::Glyph
send	lib/arch-stm32/jee-rf69.h	/^    void RF69<SPI>::send (uint8_t header, const void* ptr, int len) {$/;"	f	class:jeeh::RF69
send	lib/arch-stm32/jee-stm32.h	/^        void send (uint8_t const* buf, int len) const {$/;"	f	struct:jeeh::SpiGpio
send	lib/mcu/mcu.h	/^        virtual void send (uint32_t) {}$/;"	f	struct:mcu::Stream
seq	tests/tdd/main.cpp	/^int seq;$/;"	v
ser	src/mrfs.py	/^    ser = openSerialPort()$/;"	v
ser	src/runner.py	/^    ser = openSerialPort()$/;"	v
ser	src/watcher.py	/^    ser = openSerialPort()$/;"	v
ser	src/watcher.py	/^ser = None$/;"	v
serial	src/runner.py	/^    import serial$/;"	i
serial	src/runner.py	/^    import serial.tools.list_ports$/;"	i
set	lib/graphics/mod-graphics.cpp	/^    static void set (unsigned c)    { printf("\\x1B[%dm ", 40 + c); }$/;"	f	struct:Tft
set	lib/hall-stm32/stm32l4.cpp	/^        void set (DateTime dt) {$/;"	f	namespace:hall::rtc
set	tests/py/features.py	/^    def set(self, b):$/;"	m	class:A
setData	lib/hall-stm32/stm32l4.cpp	/^        void setData (int reg, uint32_t val) {$/;"	f	namespace:hall::rtc
setFrequency	lib/arch-stm32/jee-rf69.h	/^    void RF69<SPI>::setFrequency (uint32_t hz) const {$/;"	f	class:jeeh::RF69
setInsDel	tests/unit/array/main.cpp	/^static void setInsDel () {$/;"	f	file:
setMark	lib/monty/gc.cpp	/^    void setMark ()                { flag |= 1; }$/;"	f	struct:ObjSlot
setMode	lib/arch-stm32/jee-rf69.h	/^    void RF69<SPI>::setMode (uint8_t newMode) {$/;"	f	class:jeeh::RF69
setPending	lib/monty/monty.h	/^        static void setPending (uint32_t n) {$/;"	f	struct:monty::Stacklet
setUp	tests/unit/array/main.cpp	/^void setUp () {$/;"	f
setUp	tests/unit/data/main.cpp	/^void setUp () {$/;"	f
setUp	tests/unit/mem/main.cpp	/^void setUp () {$/;"	f
setUp	tests/unit/repr/main.cpp	/^void setUp () {$/;"	f
setupFaultHandlers	lib/arch-stm32/arch.cpp	/^void setupFaultHandlers () {$/;"	f
setupWatcher	src/tdd.py	/^def setupWatcher():$/;"	f
shft	lib/extend/typ-array.cpp	/^    constexpr static auto shft = 3 - L;             \/\/ 3 2 1$/;"	m	struct:AccessAsBits	file:
siz	src/mrfs.py	/^            siz = unpack('I', dat[4:8])[0]$/;"	v
size	lib/doctest/doctest.h	/^        unsigned size;$/;"	m	struct:doctest::String::view
size	lib/mcu/mcu.h	/^        auto size () { \/\/ e.g. W25Q64: 0xC84017 => 8192 KB$/;"	f	struct:mcu::SpiFlash
size	lib/monty/monty.h	/^        auto size () const { return (uint8_t) _num; }$/;"	f	struct:monty::ArgVec
size	lib/monty/monty.h	/^        constexpr auto size () const { return _fill; }$/;"	f	struct:monty::VecOf
size	lib/mrfs/mrfs.h	/^        uint32_t size :24;$/;"	m	struct:mrfs::Info
size	src/mrfs.py	/^    size = info.st_size$/;"	v
size	tests/embed/src/doctestx.h	/^        unsigned size;$/;"	m	struct:doctest::String::view
size	tests/gpio/gpio.cpp	/^constexpr auto size = 0x0100'0000;$/;"	v
skip	lib/mrfs/mrfs.cpp	/^    int skip;$/;"	m	namespace:mrfs	file:
skip	lib/pyvm/loader.h	/^    uint8_t const* skip (uint32_t n) {$/;"	f	struct:Loader
sleep	lib/arch-stm32/jee-rf69.h	/^    void RF69<SPI>::sleep () {$/;"	f	class:jeeh::RF69
smallBuf	lib/mcu/mcu.cpp	/^    SmallBuf smallBuf;$/;"	m	namespace:mcu	file:
smokeTest	tests/unit/array/main.cpp	/^void smokeTest () {$/;"	f
smokeTest	tests/unit/data/main.cpp	/^void smokeTest () {$/;"	f
smokeTest	tests/unit/mem/main.cpp	/^void smokeTest () {$/;"	f
smokeTest	tests/unit/repr/main.cpp	/^void smokeTest () {$/;"	f
spOff	lib/pyvm/pyvm.cpp	/^        Value base, spOff, ipOff, callee, ep, locals, result, stack [];$/;"	m	struct:PyVM::Frame	file:
spi	lib/arch-stm32/jee-rf69.h	/^        SPI spi;$/;"	m	struct:jeeh::RF69
spi	tests/py/s_spi.py	/^spi = machine.spi("B7,B6,B0,A12")$/;"	v
spiInfo	lib/arch-stm32/prelude.h	/^DevInfo const spiInfo [] = {$/;"	m	struct:IrqVec
spiInfo	lib/mcu/prelude.h	/^DevInfo const spiInfo [] = {$/;"	m	struct:IrqVec
spis	src/device.py	/^spis = []$/;"	v
splitFreeVec	lib/monty/gc.cpp	/^static void splitFreeVec (VecSlot& slot, VecSlot* tail) {$/;"	f	file:
splitFreeVec	tests/native/memTest.cpp	/^static void splitFreeVec (vec::Slot& slot, vec::Slot* tail) {$/;"	f	file:
ss	lib/hall-stm32/hall.h	/^        struct DateTime { uint8_t yr, mo, dy, hh, mm, ss; };$/;"	m	struct:hall::rtc::DateTime
ss	lib/mcu/mcu.h	/^        struct DateTime { uint8_t yr, mo, dy, hh, mm, ss; };$/;"	m	struct:mcu::rtc::DateTime
stack	lib/monty/parser.h	/^    Vector stack; \/\/ TODO mark for GC!$/;"	v
stack	lib/pyvm/pyvm.cpp	/^        Value base, spOff, ipOff, callee, ep, locals, result, stack [];$/;"	m	struct:PyVM::Frame	file:
stacker	lib/monty/stack.cpp	/^Stacker stacker;$/;"	v
start	lib/arch-native/mod-machine.cpp	/^uint32_t start, last;$/;"	v
start	lib/arch-stm32/mod-machine.cpp	/^static uint32_t start, last;$/;"	v	file:
start	lib/mcu/mcu.h	/^        auto start(uint8_t addr) const {$/;"	f	struct:mcu::I2cGpio
start	lib/monty/gc.cpp	/^static uintptr_t* start;    \/\/ start of memory pool, aligned to VS_SZ-PTR_SZ$/;"	v	file:
startElement	src/xmltodict.py	/^    def startElement(self, full_name, attrs):$/;"	m	class:_DictSAXHandler
startNamespaceDecl	src/xmltodict.py	/^    def startNamespaceDecl(self, prefix, uri):$/;"	m	class:_DictSAXHandler
state	lib/monty/parser.h	/^    State state =Ini;$/;"	v
std	lib/mcu/mcu.cpp	/^namespace std { void terminate () __attribute__ ((alias ("abort"))); }$/;"	n	file:
stdIn	lib/mcu/mcu.cpp	/^    Stream* stdIn;$/;"	m	namespace:mcu	file:
stdOut	lib/mcu/mcu.cpp	/^Printer* stdOut = &swoOut;$/;"	v
stdin	src/xmltodict.py	/^        stdin = sys.stdin$/;"	v
stdin	src/xmltodict.py	/^        stdin = sys.stdin.buffer$/;"	v
stdout	src/xmltodict.py	/^        stdout = sys.stdout$/;"	v
stdout	src/xmltodict.py	/^        stdout = sys.stdout.buffer$/;"	v
steep	lib/graphics/twodee.h	/^        bool steep;$/;"	m	struct:twodee::LineIter
stop	lib/mcu/mcu.h	/^        void stop() const {$/;"	f	struct:mcu::I2cGpio
storeQstr	lib/pyvm/loader.h	/^    int storeQstr () {$/;"	f	struct:Loader
str	tests/py/features.py	/^str = "0123456789"$/;"	v
streams	lib/arch-stm32/prelude.h	/^struct DmaInfo { uint32_t base; uint8_t streams [8]; };$/;"	m	struct:IrqVec::DmaInfo
streams	lib/hall-stm32/stm32l4-uart.cpp	/^struct DmaInfo { uint32_t base; uint8_t streams [8]; };$/;"	m	struct:DmaInfo	file:
streams	lib/mcu/prelude.h	/^struct DmaInfo { uint32_t base; uint8_t streams [8]; };$/;"	m	struct:IrqVec::DmaInfo
streams	src/device.py	/^    streams = 8 * ["0"]$/;"	v
strip	src/codegen.py	/^            strip = True$/;"	v
strip	src/codegen.py	/^strip = False       # strip most auto-generated code if set$/;"	v
subcase_filter_levels	lib/doctest/doctest.h	/^    int subcase_filter_levels; \/\/ apply the subcase filters for the first N levels$/;"	m	struct:doctest::ContextOptions
subcase_filter_levels	tests/embed/src/doctestx.h	/^    int subcase_filter_levels; \/\/ apply the subcase filters for the first N levels$/;"	m	struct:doctest::ContextOptions
subprocess	lib/mrfs/test.py	/^import doctest, os, subprocess$/;"	i
subprocess	src/codegen.py	/^import os, re, sys, subprocess$/;"	i
subprocess	src/runner.py	/^import os, re, subprocess, sys, time$/;"	i
subprocess	src/tdd.py	/^import os, subprocess, sys, time$/;"	i
subprocess	src/watcher.py	/^import os, subprocess, sys, time$/;"	i
success	lib/doctest/doctest.h	/^    bool success;              \/\/ include successful assertions in output$/;"	m	struct:doctest::ContextOptions
success	tests/embed/src/doctestx.h	/^    bool success;              \/\/ include successful assertions in output$/;"	m	struct:doctest::ContextOptions
svdDir	src/device.py	/^    svdDir = path.expanduser("~\/.platformio\/platforms\/ststm32\/misc\/svd")$/;"	v
svdDir	src/device.py	/^    svdDir = sys.argv[2]$/;"	v
svdName	src/device.py	/^svdName = sys.argv[1]$/;"	v
swap	lib/graphics/twodee.h	/^    void swap (T& a, T& b)       { T t = a; a = b; b = t; }$/;"	f	namespace:twodee
sweep	lib/monty/gc.cpp	/^    void Obj::sweep () {$/;"	f	class:monty::Obj
sweeps	lib/monty/monty.h	/^                checks, sweeps, compacts,$/;"	m	struct:monty::GCStats::__anon8
sweeps	tests/native/memTest.cpp	/^            checks, sweeps, compacts,$/;"	m	struct:GCStats::__anon35	file:
sys	src/altpins.py	/^import os, re, sys$/;"	i
sys	src/codegen.py	/^import os, re, sys, subprocess$/;"	i
sys	src/device.py	/^import configparser, os, re, sys$/;"	i
sys	src/mrfs.py	/^import io, os, sys, time$/;"	i
sys	src/runner.py	/^import os, re, subprocess, sys, time$/;"	i
sys	src/tdd.py	/^import os, subprocess, sys, time$/;"	i
sys	src/watcher.py	/^import os, subprocess, sys, time$/;"	i
sys	src/xmltodict.py	/^    import sys$/;"	i
sys	tests/py/builtins.py	/^import sys$/;"	i
sys	tests/py/dir.py	/^import sys$/;"	i
sys	tests/py/features.py	/^import sys, machine$/;"	i
sys	tests/py/gcoll.py	/^import sys, machine$/;"	i
sys	tests/py/hello.py	/^import sys$/;"	i
sys	tests/py/import.py	/^import sys$/;"	i
sys	tests/py/other/x_await.py	/^import sys, machine$/;"	i
sys	tests/py/s_blinker.py	/^import sys, machine$/;"	i
sys	tests/py/s_rf69.py	/^import sys, machine$/;"	i
sys	tests/py/serout.py	/^import sys, machine$/;"	i
sys	tests/py/tasks.py	/^import sys, machine$/;"	i
sys	tests/py/timer.py	/^import sys, machine$/;"	i
sys	tests/py/tracebk.py	/^import sys$/;"	i
sys_map	lib/extend/mod-sys.cpp	/^static Lookup::Item const sys_map [] = {$/;"	m	class:Lookup	file:
systemReset	lib/arch-stm32/arch.cpp	/^static void systemReset [[noreturn]] () {$/;"	f	file:
systemReset	lib/hall-stm32/hall.cpp	/^void hall::systemReset () {$/;"	f	class:hall
systemReset	lib/mcu/mcu.cpp	/^    void systemReset () {$/;"	f	namespace:mcu
systick	lib/hall-native/hall.h	/^    namespace systick {$/;"	n	namespace:hall
systick	lib/hall-stm32/hall.cpp	/^namespace hall::systick {$/;"	n	class:hall	file:
systick	lib/hall-stm32/hall.h	/^    namespace systick {$/;"	n	namespace:hall
t	src/device.py	/^        t = dtxBits[n-1] if n-1 < len(dtxBits) else "1c0s0"$/;"	v
t0	tests/smoke/tasks.py	/^def t0(c):$/;"	f
t1	tests/smoke/tasks.py	/^def t1(c):$/;"	f
t2	tests/smoke/tasks.py	/^def t2(c):$/;"	f
t3	tests/smoke/tasks.py	/^def t3(c):$/;"	f
t4	tests/smoke/tasks.py	/^def t4(c):$/;"	f
t5	tests/smoke/tasks.py	/^def t5(c):$/;"	f
t6	tests/smoke/tasks.py	/^def t6(c):$/;"	f
t7	tests/smoke/tasks.py	/^def t7(c):$/;"	f
t8	tests/smoke/tasks.py	/^def t8(c):$/;"	f
t9	tests/smoke/tasks.py	/^def t9(c):$/;"	f
tFill	lib/graphics/twodee.h	/^        static void tFill (Point p1, Point p2, Point p3) {$/;"	f	struct:twodee::TwoDee
tag	lib/monty/monty.h	/^        auto tag () const {$/;"	f	struct:monty::Value
tag	lib/monty/parser.h	/^    uint8_t tag, fill, chk;$/;"	v
take	lib/monty/monty.h	/^        auto take () { Value r = *this; *this = {}; return r; }$/;"	f	struct:monty::Value
take	tests/tdd/main.cpp	/^    auto take () {$/;"	f	struct:S
task	tests/py/s_blinker.py	/^async def task(rate):$/;"	f
task	tests/py/serout.py	/^async def task(rate, msg):$/;"	f
task	tests/py/tasks.py	/^async def task(rate):$/;"	f
task	tests/smoke/tasks.py	/^from invoke import task$/;"	i
tearDown	tests/unit/array/main.cpp	/^void tearDown () {$/;"	f
tearDown	tests/unit/data/main.cpp	/^void tearDown () {$/;"	f
tearDown	tests/unit/mem/main.cpp	/^void tearDown () {$/;"	f
tearDown	tests/unit/repr/main.cpp	/^void tearDown () {$/;"	f
ten	tests/py/features.py	/^def ten():$/;"	f
three	tests/py/closure.py	/^def three(n):$/;"	f
three	tests/py/features.py	/^three = 3$/;"	v
tick	tests/py/other/x_await.py	/^tick = machine.ticker(100)$/;"	v
tickEvent	lib/arch-stm32/mod-machine.cpp	/^static Event tickEvent;$/;"	v	file:
ticker	lib/hall-stm32/hall.cpp	/^    Ticker ticker;$/;"	v
tickerId	lib/arch-native/mod-machine.cpp	/^int ms, tickerId;$/;"	v
tickerId	lib/arch-stm32/mod-machine.cpp	/^static int ms, tickerId;$/;"	v	file:
ticks	lib/hall-stm32/hall.cpp	/^            ticks = millis();$/;"	m	namespace:hall::systick	file:
ticks	lib/mcu/mcu.cpp	/^    uint32_t volatile ticks;$/;"	m	namespace:mcu	file:
time	lib/mrfs/mrfs.h	/^        uint32_t time;$/;"	m	struct:mrfs::Info
time	src/mrfs.py	/^import io, os, sys, time$/;"	i
time	src/runner.py	/^import os, re, subprocess, sys, time$/;"	i
time	src/tdd.py	/^import os, subprocess, sys, time$/;"	i
time	src/watcher.py	/^import os, subprocess, sys, time$/;"	i
timeout	tests/py/other/d_test.py	/^timeout = 1000000000$/;"	v
timeout	tests/py/s_blinker.py	/^async def timeout():$/;"	f
timeout	tests/py/serout.py	/^async def timeout():$/;"	f
timeout	tests/py/tasks.py	/^async def timeout():$/;"	f
timerHook	lib/arch-native/mod-machine.cpp	/^void timerHook () {$/;"	f
timers	lib/boss/boss.cpp	/^pool::Queue Fiber::timers;$/;"	m	class:Fiber	file:
toString	lib/boss/boss.cpp	/^    doctest::String toString(Buf* p) {$/;"	f	namespace:boss::pool
toa	lib/monty/monty.h	/^                toa, tob, tva, tvb, \/\/ total Obj\/Vec Allocs\/Bytes$/;"	m	struct:monty::GCStats::__anon8
toa	tests/native/memTest.cpp	/^            toa, tob, tva, tvb, \/\/ total Obj\/Vec Allocs\/Bytes$/;"	m	struct:GCStats::__anon35	file:
tob	lib/monty/monty.h	/^                toa, tob, tva, tvb, \/\/ total Obj\/Vec Allocs\/Bytes$/;"	m	struct:monty::GCStats::__anon8
tob	tests/native/memTest.cpp	/^            toa, tob, tva, tvb, \/\/ total Obj\/Vec Allocs\/Bytes$/;"	m	struct:GCStats::__anon35	file:
toggle	lib/arch-stm32/jee-stm32.h	/^        void toggle () const { write(read() ^ 1); }$/;"	f	struct:jeeh::Pin
toggle	lib/hall-stm32/hall.h	/^        void toggle () const { write(!read()); }$/;"	f	struct:hall::Pin
toggle	lib/mcu/mcu.h	/^        void toggle () const { write(read() ^ 1); }$/;"	f	struct:mcu::Pin
toggle	tests/gpio/gpio.cpp	/^        void toggle () const { write(!read()); }$/;"	f	struct:gpio::Pin
tools	src/runner.py	/^    import serial.tools.list_ports$/;"	i
top	tests/native/memTest.cpp	/^        uint8_t* top;$/;"	m	namespace:mem::vec	file:
transfer	lib/arch-stm32/jee-stm32.h	/^        void transfer (uint8_t* buf, int len) const {$/;"	f	struct:jeeh::SpiGpio
triangle	lib/graphics/twodee.h	/^        static void triangle (Point p1, Point p2, Point p3) {$/;"	f	struct:twodee::TwoDee
trigger	lib/arch-stm32/arch.h	/^        void trigger () {$/;"	f	struct:arch::Device
trigger	lib/mcu/mcu.h	/^        void trigger () { pending |= 1<<_id; } \/\/ called at interrupt time$/;"	f	struct:mcu::Device
triggers	lib/monty/monty.h	/^        static Vector triggers;$/;"	m	struct:monty::Event
triggers	lib/monty/stack.cpp	/^Vector Event::triggers;$/;"	m	class:Event	file:
trueObj	lib/monty/data.cpp	/^Bool const Bool::trueObj;$/;"	m	class:Bool	file:
trueObj	lib/monty/monty.h	/^        static Bool const trueObj, falseObj;$/;"	m	struct:monty::Bool
tva	lib/monty/monty.h	/^                toa, tob, tva, tvb, \/\/ total Obj\/Vec Allocs\/Bytes$/;"	m	struct:monty::GCStats::__anon8
tva	tests/native/memTest.cpp	/^            toa, tob, tva, tvb, \/\/ total Obj\/Vec Allocs\/Bytes$/;"	m	struct:GCStats::__anon35	file:
tvb	lib/monty/monty.h	/^                toa, tob, tva, tvb, \/\/ total Obj\/Vec Allocs\/Bytes$/;"	m	struct:monty::GCStats::__anon8
tvb	tests/native/memTest.cpp	/^            toa, tob, tva, tvb, \/\/ total Obj\/Vec Allocs\/Bytes$/;"	m	struct:GCStats::__anon35	file:
two	tests/py/closure.py	/^def two():$/;"	f
twodee	lib/graphics/twodee.h	/^namespace twodee {$/;"	n
txBuf	lib/mcu/uart-stm32f4f7.h	/^    uint8_t rxBuf [100], txBuf [100];$/;"	m	struct:Uart
txBuf	lib/mcu/uart-stm32l4.h	/^    uint8_t rxBuf [100], txBuf [100];$/;"	m	struct:Uart
txChan	lib/arch-stm32/prelude.h	/^    uint8_t txDma :1, txChan :4, txStream :3;$/;"	m	struct:IrqVec::DevInfo
txChan	lib/hall-stm32/stm32l4-uart.cpp	/^    uint16_t dma :1, rxChan :4, rxStream :3, txChan :4, txStream :3;$/;"	m	struct:UartInfo	file:
txChan	lib/mcu/prelude.h	/^    uint8_t txDma :1, txChan :4, txStream :3;$/;"	m	struct:IrqVec::DevInfo
txDma	lib/arch-stm32/prelude.h	/^    uint8_t txDma :1, txChan :4, txStream :3;$/;"	m	struct:IrqVec::DevInfo
txDma	lib/mcu/prelude.h	/^    uint8_t txDma :1, txChan :4, txStream :3;$/;"	m	struct:IrqVec::DevInfo
txId	lib/arch-stm32/arch.cpp	/^    static uint8_t rxId, txId;$/;"	m	struct:LineSerial	file:
txId	lib/arch-stm32/arch.cpp	/^uint8_t LineSerial::txId;$/;"	m	class:LineSerial	file:
txLast	lib/mcu/uart-stm32f4f7.h	/^    uint16_t txNext =0, txLast =0;$/;"	m	struct:Uart
txLast	lib/mcu/uart-stm32l4.h	/^    uint16_t txNext =0, txLast =0;$/;"	m	struct:Uart
txNext	lib/mcu/uart-stm32f4f7.h	/^    uint16_t txNext =0, txLast =0;$/;"	m	struct:Uart
txNext	lib/mcu/uart-stm32l4.h	/^    uint16_t txNext =0, txLast =0;$/;"	m	struct:Uart
txPower	lib/arch-stm32/jee-rf69.h	/^    void RF69<SPI>::txPower (uint8_t level) const {$/;"	f	class:jeeh::RF69
txStart	lib/arch-stm32/uart-f1.h	/^    void txStart (void const* ptr, uint16_t len) {$/;"	f	struct:Uart
txStart	lib/arch-stm32/uart-f4.h	/^    void txStart (void const* ptr, uint16_t len) {$/;"	f	struct:Uart
txStart	lib/arch-stm32/uart-l0.h	/^    void txStart (void const* ptr, uint16_t len) {$/;"	f	struct:Uart
txStart	lib/arch-stm32/uart-l4.h	/^    void txStart (void const* ptr, uint16_t len) {$/;"	f	struct:Uart
txStart	lib/hall-stm32/stm32l4-uart.cpp	/^    void txStart (uint8_t const* ptr, uint16_t len) {$/;"	f	struct:Uart
txStart	lib/mcu/uart-stm32f4f7.h	/^    void txStart () {$/;"	f	struct:Uart
txStart	lib/mcu/uart-stm32l4.h	/^    void txStart () {$/;"	f	struct:Uart
txStream	lib/arch-stm32/prelude.h	/^    uint8_t txDma :1, txChan :4, txStream :3;$/;"	m	struct:IrqVec::DevInfo
txStream	lib/hall-stm32/stm32l4-uart.cpp	/^    uint16_t dma :1, rxChan :4, rxStream :3, txChan :4, txStream :3;$/;"	m	struct:UartInfo	file:
txStream	lib/mcu/prelude.h	/^    uint8_t txDma :1, txChan :4, txStream :3;$/;"	m	struct:IrqVec::DevInfo
type	lib/doctest/doctest.h	/^    template<class T> struct remove_const          { typedef T type; };$/;"	t	struct:doctest::detail::remove_const
type	lib/doctest/doctest.h	/^    template<class T> struct remove_const<const T> { typedef T type; };$/;"	t	struct:doctest::detail::remove_const
type	lib/doctest/doctest.h	/^    template<class T> struct remove_reference      { typedef T type; };$/;"	t	struct:doctest::detail::remove_reference
type	lib/doctest/doctest.h	/^    template<class T> struct remove_reference<T&&> { typedef T type; };$/;"	t	struct:doctest::detail::remove_reference
type	lib/doctest/doctest.h	/^    template<class T> struct remove_reference<T&>  { typedef T type; };$/;"	t	struct:doctest::detail::remove_reference
type	lib/doctest/doctest.h	/^    template<class T> struct underlying_type { typedef __underlying_type(T) type; };$/;"	t	struct:doctest::detail::underlying_type
type	lib/doctest/doctest.h	/^    { typedef TYPE type; };$/;"	t	struct:doctest::detail::enable_if
type	tests/embed/src/doctestx.h	/^    template<class T> struct remove_const          { typedef T type; };$/;"	t	struct:doctest::detail::remove_const
type	tests/embed/src/doctestx.h	/^    template<class T> struct remove_const<const T> { typedef T type; };$/;"	t	struct:doctest::detail::remove_const
type	tests/embed/src/doctestx.h	/^    template<class T> struct remove_reference      { typedef T type; };$/;"	t	struct:doctest::detail::remove_reference
type	tests/embed/src/doctestx.h	/^    template<class T> struct remove_reference<T&&> { typedef T type; };$/;"	t	struct:doctest::detail::remove_reference
type	tests/embed/src/doctestx.h	/^    template<class T> struct remove_reference<T&>  { typedef T type; };$/;"	t	struct:doctest::detail::remove_reference
type	tests/embed/src/doctestx.h	/^    template<class T> struct underlying_type { typedef __underlying_type(T) type; };$/;"	t	struct:doctest::detail::underlying_type
type	tests/embed/src/doctestx.h	/^    { typedef TYPE type; };$/;"	t	struct:doctest::detail::enable_if
typer	lib/arch-stm32/jee-stm32.h	/^        enum { moder=0x00, typer=0x04, ospeedr=0x08, pupdr=0x0C, idr=0x10,$/;"	e	enum:jeeh::Pin::__anon23
u	src/device.py	/^        u = r.upper()$/;"	v
u	src/device.py	/^        u = uartfix(p)$/;"	v
u	src/device.py	/^    u = uartfix(k)$/;"	v
u	tests/py/features.py	/^def u(p):$/;"	f
u49	tests/py/features.py	/^def u49():$/;"	f
u64	lib/monty/parser.h	/^    uint64_t u64;$/;"	v
uart	lib/hall-stm32/hall.h	/^    namespace uart {$/;"	n	namespace:hall
uart	lib/hall-stm32/stm32l4-uart.cpp	/^namespace hall::uart {$/;"	n	class:hall	file:
uart	tests/py/other/d_test.py	/^uart = machine.uart()$/;"	v
uart	tests/py/other/uart.py	/^uart = machine.uart()$/;"	v
uartInfo	lib/arch-stm32/prelude.h	/^DevInfo const uartInfo [] = {$/;"	m	struct:IrqVec
uartInfo	lib/mcu/prelude.h	/^DevInfo const uartInfo [] = {$/;"	m	struct:IrqVec
uartfix	src/device.py	/^def uartfix(s):$/;"	f
uarts	lib/hall-stm32/stm32l4-uart.cpp	/^Uart uarts [] = {$/;"	v
uarts	src/device.py	/^uarts = []$/;"	v
uartsort	src/device.py	/^def uartsort(s):$/;"	f
uint16_t	lib/monty/monty.h	/^        static auto find (char const*) -> uint16_t;$/;"	m	struct:monty::Q
uint16_t	lib/monty/monty.h	/^        static auto last () -> uint16_t;$/;"	m	struct:monty::Q
uint16_t	lib/monty/monty.h	/^        static auto make (char const*) -> uint16_t;$/;"	m	struct:monty::Q
uint32_t	lib/hall-native/hall.h	/^        auto micros () -> uint32_t;$/;"	m	namespace:hall::systick
uint32_t	lib/hall-native/hall.h	/^        auto millis () -> uint32_t;$/;"	m	namespace:hall::systick
uint32_t	lib/hall-stm32/hall.h	/^        auto getData (int reg) -> uint32_t;$/;"	m	namespace:hall::rtc
uint32_t	lib/hall-stm32/hall.h	/^        auto micros () -> uint32_t;$/;"	m	namespace:hall::systick
uint32_t	lib/hall-stm32/hall.h	/^        auto millis () -> uint32_t;$/;"	m	namespace:hall::systick
uint32_t	lib/hall-stm32/hall.h	/^    auto fastClock (bool pll =true) -> uint32_t;$/;"	m	namespace:hall
uint32_t	lib/hall-stm32/hall.h	/^    auto slowClock (bool low =true) -> uint32_t;$/;"	m	namespace:hall
uint32_t	lib/hall-stm32/hall.h	/^    auto systemHz () -> uint32_t;$/;"	m	namespace:hall
uint32_t	lib/mcu/mcu.h	/^        auto getData (int reg) -> uint32_t;$/;"	m	namespace:mcu::rtc
uint32_t	lib/mcu/mcu.h	/^    auto fastClock (bool pll =true) -> uint32_t;$/;"	m	namespace:mcu
uint32_t	lib/mcu/mcu.h	/^    auto micros () -> uint32_t;$/;"	m	namespace:mcu
uint32_t	lib/mcu/mcu.h	/^    auto millis () -> uint32_t;$/;"	m	namespace:mcu
uint32_t	lib/mcu/mcu.h	/^    auto reserveNonCached (int bits) -> uint32_t;$/;"	m	namespace:mcu
uint32_t	lib/mcu/mcu.h	/^    auto slowClock (bool low =true) -> uint32_t;$/;"	m	namespace:mcu
uint32_t	lib/mcu/mcu.h	/^    auto systemClock () -> uint32_t;$/;"	m	namespace:mcu
uint32_t	lib/monty/monty.h	/^        auto find (Value v) const -> uint32_t;$/;"	m	struct:monty::Set
uint32_t	lib/monty/monty.h	/^        auto regHandler () -> uint32_t;$/;"	m	struct:monty::Event
uint32_t	lib/monty/monty.h	/^        auto slots () const -> uint32_t; \/\/ capacity in vecslots$/;"	m	struct:monty::Vec
uint32_t	lib/monty/monty.h	/^        auto triggerExpired (uint32_t now) -> uint32_t;$/;"	m	struct:monty::Event
uint32_t	lib/monty/monty.h	/^        static auto hash (void const*, int =-1) -> uint32_t;$/;"	m	struct:monty::Q
uint32_t	lib/monty/monty.h	/^        virtual auto len   () const -> uint32_t;$/;"	m	struct:monty::Object
uint32_t	lib/monty/monty.h	/^    auto nowAsTicks () -> uint32_t; \/\/ defined by the arch-dependent code$/;"	m	namespace:monty
uint32_t	tests/native/memTest.cpp	/^        auto slots () const -> uint32_t; \/\/ capacity in vecslots$/;"	m	struct:mem::Vec	file:
uint8_t	lib/pyvm/pyvm.cpp	/^enum Op : uint8_t {$/;"	g	file:
underlying_type	lib/doctest/doctest.h	/^    template<class T> struct underlying_type : public std::underlying_type<T> {};$/;"	s	namespace:doctest::detail
underlying_type	lib/doctest/doctest.h	/^    template<class T> struct underlying_type { typedef __underlying_type(T) type; };$/;"	s	namespace:doctest::detail
underlying_type	tests/embed/src/doctestx.h	/^    template<class T> struct underlying_type : public std::underlying_type<T> {};$/;"	s	namespace:doctest::detail
underlying_type	tests/embed/src/doctestx.h	/^    template<class T> struct underlying_type { typedef __underlying_type(T) type; };$/;"	s	namespace:doctest::detail
unpack	src/mrfs.py	/^from struct import pack, unpack$/;"	i
unparse	src/xmltodict.py	/^def unparse(input_dict, output=None, encoding='utf-8', full_document=True,$/;"	f
updateMaps	src/tdd.py	/^def updateMaps(fn):$/;"	f
upload	src/mrfs.py	/^        upload = int(next(args), 0)$/;"	v
upload	src/mrfs.py	/^upload = None$/;"	v
v	lib/monty/monty.h	/^        int v [15];$/;"	m	union:monty::GCStats
v	lib/monty/monty.h	/^        struct Item { Q k; Value v; };$/;"	m	struct:monty::Lookup::Item
v	lib/monty/monty.h	/^        struct Proxy { Set& s; Value v;$/;"	m	struct:monty::Set::Proxy
v	src/mrfs.py	/^            v = files[k]$/;"	v
v	tests/native/memTest.cpp	/^    int v [15];$/;"	m	union:GCStats	file:
v	tests/py/dir.py	/^    v = 1$/;"	v	class:A
v	tests/py/x_cycles.py	/^v = 1$/;"	v
v	tests/unit/array/main.cpp	/^VecOf<int> v;$/;"	v
vLine	lib/graphics/twodee.h	/^        static void vLine (Point p, unsigned h, unsigned c =fg) {$/;"	f	struct:twodee::TwoDee
val	lib/monty/parser.h	/^    Value val; \/\/ TODO mark for GC!$/;"	v
value	lib/doctest/doctest.h	/^            static constexpr bool value = false;$/;"	m	struct:doctest::detail::has_insertion_operator_impl::check
value	lib/doctest/doctest.h	/^    template<class T> struct is_enum { constexpr static bool value = __is_enum(T); };$/;"	m	struct:doctest::detail::is_enum
value	lib/doctest/doctest.h	/^    template<class T> struct is_lvalue_reference { const static bool value=false; };$/;"	m	struct:doctest::detail::is_lvalue_reference
value	lib/doctest/doctest.h	/^    template<class T> struct is_lvalue_reference<T&> { const static bool value=true; };$/;"	m	struct:doctest::detail::is_lvalue_reference
value	lib/doctest/doctest.h	/^    { static const bool value = false; };$/;"	m	struct:doctest::detail::deferred_false
value	tests/embed/src/doctestx.h	/^            static constexpr bool value = false;$/;"	m	struct:doctest::detail::has_insertion_operator_impl::check
value	tests/embed/src/doctestx.h	/^    template<class T> struct is_enum { constexpr static bool value = __is_enum(T); };$/;"	m	struct:doctest::detail::is_enum
value	tests/embed/src/doctestx.h	/^    template<class T> struct is_lvalue_reference { const static bool value=false; };$/;"	m	struct:doctest::detail::is_lvalue_reference
value	tests/embed/src/doctestx.h	/^    template<class T> struct is_lvalue_reference<T&> { const static bool value=true; };$/;"	m	struct:doctest::detail::is_lvalue_reference
value	tests/embed/src/doctestx.h	/^    { static const bool value = false; };$/;"	m	struct:doctest::detail::deferred_false
varInt	lib/pyvm/loader.h	/^    uint32_t varInt () {$/;"	f	struct:Loader
varyVecTests	tests/unit/data/main.cpp	/^void varyVecTests () {$/;"	f
vec	lib/monty/gc.cpp	/^    Vec* vec;$/;"	m	struct:VecSlot	file:
vec	tests/native/memTest.cpp	/^    namespace vec {$/;"	n	namespace:mem	file:
vec	tests/native/memTest.cpp	/^namespace mem::vec {$/;"	n	class:mem	file:
vecData	tests/unit/mem/main.cpp	/^void vecData () {$/;"	f
vecHigh	lib/monty/gc.cpp	/^static VecSlot* vecHigh;    \/\/ high water mark of vector memory pool$/;"	v	file:
vecOfCopyMove	tests/unit/array/main.cpp	/^void vecOfCopyMove () {$/;"	f
vecOfInited	tests/unit/array/main.cpp	/^void vecOfInited () {$/;"	f
vecOfMoveAndWipe	tests/unit/array/main.cpp	/^void vecOfMoveAndWipe () {$/;"	f
vecOfTypeSizes	tests/unit/array/main.cpp	/^void vecOfTypeSizes () {$/;"	f
verLine	lib/graphics/twodee.h	/^        static void verLine (Point p, unsigned h, unsigned c) {$/;"	f	struct:twodee::TwoDee
verbose	src/codegen.py	/^verbose = 0         # 0=summary, 1=quiet, 2=stats, 3=full$/;"	v
verbose	src/tdd.py	/^    verbose = True$/;"	v
verbose	src/tdd.py	/^verbose = False$/;"	v
verify	lib/boss/boss.cpp	/^void Queue::verify () const {$/;"	f	class:boss::Queue
verify	lib/monty/data.cpp	/^void Value::verify (Type const& t) const {$/;"	f	class:Value
version	lib/doctest/doctest.h	/^    bool version;          \/\/ to print the version$/;"	m	struct:doctest::ContextOptions
version	tests/embed/src/doctestx.h	/^    bool version;          \/\/ to print the version$/;"	m	struct:doctest::ContextOptions
view	lib/doctest/doctest.h	/^    struct view \/\/ len should be more than sizeof(view) - because of the final byte for flags$/;"	s	class:doctest::String
view	tests/embed/src/doctestx.h	/^    struct view \/\/ len should be more than sizeof(view) - because of the final byte for flags$/;"	s	class:doctest::String
vprintf	lib/mcu/printer.h	/^    auto vprintf(char const* fmt, va_list ap) {$/;"	f	struct:Printer
vt	lib/monty/gc.cpp	/^    void* vt; \/\/ null for deleted objects$/;"	m	struct:ObjSlot	file:
vvec	lib/pyvm/loader.h	/^    VaryVec* vvec;          \/\/ convert: new module format if converting, else 0$/;"	m	struct:Loader
w	lib/graphics/twodee.h	/^        uint16_t w, h;$/;"	m	struct:twodee::Rect
w24b	lib/mcu/mcu.h	/^        void w24b (int offset) {$/;"	f	struct:mcu::SpiFlash
wait	lib/mcu/mcu.h	/^        void wait () {$/;"	f	struct:mcu::SpiFlash
waitWhile	lib/mcu/mcu.h	/^        void waitWhile (F fun) {$/;"	f	struct:mcu::Device
waiter	tests/py/other/x_await.py	/^async def waiter(evt,num):$/;"	f
watchdog	lib/hall-stm32/hall.h	/^    namespace watchdog {$/;"	n	namespace:hall
watchdog	lib/mcu/mcu.h	/^    namespace watchdog {  \/\/ [1] pp.495$/;"	n	namespace:mcu
watcher	src/watcher.py	/^def watcher(fname):$/;"	f
wcmd	lib/mcu/mcu.h	/^        void wcmd (int arg) {$/;"	f	struct:mcu::SpiFlash
width	lib/graphics/twodee.h	/^        auto width (char c) const {$/;"	f	struct:twodee::Font
width	lib/mcu/mcu.h	/^            uint8_t bit, width;$/;"	m	struct:mcu::IOWord::IOMask
width	lib/mcu/printer.h	/^    int8_t pad, width, radix, fill, limit;$/;"	m	struct:Printer
winQstr	lib/pyvm/loader.h	/^    int winQstr (int i) {$/;"	f	struct:Loader
wipe	lib/mcu/mcu.h	/^        void wipe () { \/\/ 0x60 doesn't work on Micron Tech (N25Q)$/;"	f	struct:mcu::SpiFlash
wipe	lib/monty/monty.h	/^        void wipe (uint32_t pos, uint32_t num) {$/;"	f	struct:monty::VecOf
wipe	lib/mrfs/mrfs.cpp	/^void mrfs::wipe () {$/;"	f	class:mrfs
wrappedCall	lib/pyvm/pyvm.cpp	/^    void wrappedCall (Value callee, ArgVec const& args) {$/;"	f	struct:PyVM
write	lib/arch-stm32/jee-stm32.h	/^        void write (int v) const {$/;"	f	struct:jeeh::Pin
write	lib/hall-stm32/hall.h	/^        void write (int v) const { gpio32(BSRR) = (v ? 1 : 1<<16)<<pin; }$/;"	f	struct:hall::Pin
write	lib/mcu/mcu.h	/^        void write (int offset, uint8_t const* buf, int len) {$/;"	f	struct:mcu::SpiFlash
write	lib/mcu/mcu.h	/^        void write (int v) const { gpio32(BSRR) = (v ? 1 : 1<<16)<<_pin; }$/;"	f	struct:mcu::Pin
write	lib/mcu/mcu.h	/^        void write (uint8_t const* buf, int len) const {$/;"	f	struct:mcu::SpiGpio
write	lib/monty/type.cpp	/^void Buffer::write (uint8_t const* ptr, uint32_t len) {$/;"	f	class:Buffer
write	tests/gpio/gpio.cpp	/^        void write (int v) const { GPIO(v ? SET0 : CLR0, pin) = 1; }$/;"	f	struct:gpio::Pin
write	tests/py/other/d_test.py	/^def write(self, data, limit=-1, start=0):$/;"	f
write1	lib/graphics/twodee.h	/^        static void write1 (Glyph& g, Rect& r, char c) {$/;"	f	struct:twodee::TwoDee
writeReg	lib/arch-stm32/jee-rf69.h	/^        void writeReg (uint8_t addr, uint8_t val) const {$/;"	f	struct:jeeh::RF69
writeReg	lib/mcu/mcu.h	/^        auto writeReg (uint8_t addr, uint8_t reg, uint8_t val) const {$/;"	f	struct:mcu::I2cGpio
writeReg16	lib/mcu/mcu.h	/^        auto writeReg16 (uint8_t addr, uint16_t reg, uint16_t val) const {$/;"	f	struct:mcu::I2cGpio
writer	lib/arch-stm32/arch.cpp	/^    static void writer (int c) {$/;"	f	struct:LineSerial
writes	lib/graphics/twodee.h	/^        static auto writes (Font const& f, Point p, char const* s, int n =-1) {$/;"	f	struct:twodee::TwoDee
x	lib/graphics/twodee.h	/^        int16_t r, x, y, err;$/;"	m	struct:twodee::ArcIter
x	lib/graphics/twodee.h	/^    struct Point { int16_t x, y; };$/;"	m	struct:twodee::Point
x	tests/py/features.py	/^            x = 25$/;"	v	class:.set.c25
x	tests/py/s_spi.py	/^x = spi.xfer(0x12)$/;"	v
x0	lib/graphics/twodee.h	/^        int16_t x0 =0, y0 =0, x1, y1, err, dx, dy;$/;"	m	struct:twodee::LineIter
x1	lib/graphics/twodee.h	/^        int16_t x0 =0, y0 =0, x1, y1, err, dx, dy;$/;"	m	struct:twodee::LineIter
xmltodict	src/device.py	/^import xmltodict$/;"	i
xp	src/device.py	/^xp = parsed['device']['peripherals']['peripheral']$/;"	v
y	lib/graphics/twodee.h	/^        int16_t r, x, y, err;$/;"	m	struct:twodee::ArcIter
y	lib/graphics/twodee.h	/^    struct Point { int16_t x, y; };$/;"	m	struct:twodee::Point
y	tests/py/s_spi.py	/^y = spi.xfer(0x34)$/;"	v
y0	lib/graphics/twodee.h	/^        int16_t x0 =0, y0 =0, x1, y1, err, dx, dy;$/;"	m	struct:twodee::LineIter
y1	lib/graphics/twodee.h	/^        int16_t x0 =0, y0 =0, x1, y1, err, dx, dy;$/;"	m	struct:twodee::LineIter
yr	lib/hall-stm32/hall.h	/^        struct DateTime { uint8_t yr, mo, dy, hh, mm, ss; };$/;"	m	struct:hall::rtc::DateTime
yr	lib/mcu/mcu.h	/^        struct DateTime { uint8_t yr, mo, dy, hh, mm, ss; };$/;"	m	struct:mcu::rtc::DateTime
z	tests/py/int64.py	/^z = a-a$/;"	v
zero	lib/mrfs/mrfs.h	/^        char name [15], zero;$/;"	m	struct:mrfs::Info
zero	tests/py/features.py	/^zero = 0$/;"	v
~BlockIRQ	lib/hall-stm32/hall.h	/^        ~BlockIRQ () { asm ("cpsie i"); }$/;"	f	struct:hall::BlockIRQ
~BlockIRQ	lib/mcu/mcu.h	/^        ~BlockIRQ () { asm ("cpsie i"); }$/;"	f	struct:mcu::BlockIRQ
~Buf	tests/buffers/main.cpp	/^    Buf::~Buf() {$/;"	f	class:buf::Buf
~Buffer	lib/monty/type.cpp	/^Buffer::~Buffer () {$/;"	f	class:Buffer
~S	tests/tdd/main.cpp	/^    ~S () { printf("~S%d ()\\n", id); }$/;"	f	struct:S
~SizeFix	lib/monty/builtin.cpp	/^    ~SizeFix () {$/;"	f	struct:SizeFix
~Uart	lib/mcu/uart-stm32f4f7.h	/^    ~Uart () { deinit(); }$/;"	f	struct:Uart
~Uart	lib/mcu/uart-stm32l4.h	/^    ~Uart () { deinit(); }$/;"	f	struct:Uart
~Vec	lib/monty/monty.h	/^        ~Vec () { (void) adj(0); }$/;"	f	struct:monty::Vec
~Vec	tests/native/memTest.cpp	/^        ~Vec () { (void) adj(0); }$/;"	f	struct:mem::Vec
